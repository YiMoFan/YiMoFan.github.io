<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>胥帆</title>
  <icon>https://www.gravatar.com/avatar/f90a8deeb07db0e48636ee95a27b26f3</icon>
  <subtitle>不善言辞，胆小认生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-08-09T16:36:39.712Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>胥帆</name>
    <email>1747380107@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode_Hot100题</title>
    <link href="http://yoursite.com/2022/08/10/LeetCode-Hot100%E9%A2%98/"/>
    <id>http://yoursite.com/2022/08/10/LeetCode-Hot100题/</id>
    <published>2022-08-09T16:26:17.056Z</published>
    <updated>2022-08-09T16:36:39.712Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-两数之和-力扣（LeetCode）-https-leetcode-cn-problems-two-sum"><a href="#1-两数之和-力扣（LeetCode）-https-leetcode-cn-problems-two-sum" class="headerlink" title="1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/)"></a>1. 两数之和 - 力扣（LeetCode）](<a href="https://leetcode.cn/problems/two-sum/" target="_blank" rel="noopener">https://leetcode.cn/problems/two-sum/</a>)</h4><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] == <span class="number">9</span> ，返回 [<span class="number">0</span>, <span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">3</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> target - nums[i] <span class="keyword">in</span> d.keys():</span><br><span class="line">                <span class="keyword">return</span> [i, d.get(target - nums[i])]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h4 id="2-两数相加-力扣（LeetCode）"><a href="#2-两数相加-力扣（LeetCode）" class="headerlink" title="2. 两数相加 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/add-two-numbers/" target="_blank" rel="noopener">2. 两数相加 - 力扣（LeetCode）</a></h4><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>], l2 = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">7</span>,<span class="number">0</span>,<span class="number">8</span>]</span><br><span class="line">解释：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="string">[0]</span>, l2 = <span class="string">[0]</span></span><br><span class="line">输出：<span class="string">[0]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>], l2 = [<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>]</span><br><span class="line">输出：[<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: Optional[ListNode], l2: Optional[ListNode])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">        nums1, nums2 = [], []</span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            nums1.append(l1.val)</span><br><span class="line">            l1 = l1.next</span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            nums2.append(l2.val)</span><br><span class="line">            l2 = l2.next</span><br><span class="line">        head, cur, jinwei = <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(max(len(nums1), len(nums2))):</span><br><span class="line">            num = ((nums1[i] <span class="keyword">if</span> i &lt; len(nums1) <span class="keyword">else</span> <span class="number">0</span>) + (nums2[i] <span class="keyword">if</span> i &lt; len(nums2) <span class="keyword">else</span> <span class="number">0</span>) + jinwei)</span><br><span class="line">            temp = ListNode(num % <span class="number">10</span>)</span><br><span class="line">            jinwei = num // <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> i:</span><br><span class="line">                head= temp</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next = temp</span><br><span class="line">            cur = temp</span><br><span class="line">        <span class="keyword">if</span> jinwei:</span><br><span class="line">            cur.next = ListNode(jinwei)</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: Optional[ListNode], l2: Optional[ListNode])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">        head, cur, curry = <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> curry <span class="keyword">or</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            num = curry</span><br><span class="line">            <span class="keyword">if</span> l1: num, l1 = num + l1.val, l1.next</span><br><span class="line">            <span class="keyword">if</span> l2: num, l2 = num + l2.val, l2.next</span><br><span class="line"></span><br><span class="line">            temp = ListNode(num % <span class="number">10</span>)</span><br><span class="line">            curry = num // <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">                head = temp</span><br><span class="line">            <span class="comment"># cur = cur.next = temp</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                cur.next = temp</span><br><span class="line">            cur = temp</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h4 id="3-无重复字符的最长子串-力扣（LeetCode）"><a href="#3-无重复字符的最长子串-力扣（LeetCode）" class="headerlink" title="3. 无重复字符的最长子串 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></h4><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。 </p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = "abcabcbb"</span></span><br><span class="line"><span class="section">输出: 3 </span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = "bbbbb"</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。</span></span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = "pwwkew"</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。</span></span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">"pwke"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><p>滑动窗口，保持窗口内没有重复的元素，用一个字典存下面每个字符出现的下标，然后每次更新窗口的左边界，使得窗口内没有重复的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        res, left, d = <span class="number">0</span>, <span class="number">0</span>, &#123;&#125;</span><br><span class="line">        s = list(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            left = max(left, d.get(s[i], <span class="number">-1</span>))</span><br><span class="line">            d[s[i]] = i + <span class="number">1</span></span><br><span class="line">            res = max(res, i - left + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="4-寻找两个正序数组的中位数-力扣（LeetCode）"><a href="#4-寻找两个正序数组的中位数-力扣（LeetCode）" class="headerlink" title="4. 寻找两个正序数组的中位数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数 - 力扣（LeetCode）</a></h4><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p><p>算法的时间复杂度应该为 O(log (m+n)) 。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">3</span>], nums2 = [<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">2.00000</span></span><br><span class="line">解释：合并数组 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ，中位数 <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>], nums2 = [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">2.50000</span></span><br><span class="line">解释：合并数组 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] ，中位数 (<span class="number">2</span> + <span class="number">3</span>) / <span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure><p><strong>不会做，看都看不懂</strong></p><h4 id="5-最长回文子串-力扣（LeetCode）"><a href="#5-最长回文子串-力扣（LeetCode）" class="headerlink" title="5. 最长回文子串 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串 - 力扣（LeetCode）</a></h4><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。 </p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"babad"</span></span><br><span class="line">输出：<span class="string">"bab"</span></span><br><span class="line">解释：<span class="string">"aba"</span> 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"cbbd"</span></span><br><span class="line">输出：<span class="string">"bb"</span></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><p>中心扩展法，对于每个元素，从当前元素开始向左右两边扩展，分两种情况，一种是，当前元素是回文的中间元素，一种是当前元素与右边元素相等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        res, i, j = [<span class="number">0</span>] * <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        s = list(s)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            i, j = k, k</span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; len(s) <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">                i, j = i - <span class="number">1</span>, j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j - i - <span class="number">1</span> &gt; res[<span class="number">0</span>]:</span><br><span class="line">                res = [j - i - <span class="number">1</span>, i + <span class="number">1</span>, j]</span><br><span class="line">            <span class="keyword">if</span> k + <span class="number">1</span> &lt; len(s) <span class="keyword">and</span> s[k] == s[k + <span class="number">1</span>]:</span><br><span class="line">                i, j = k, k + <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; len(s) <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">                    i, j = i - <span class="number">1</span>, j + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j - i - <span class="number">1</span> &gt; res[<span class="number">0</span>]:</span><br><span class="line">                    res = [j - i - <span class="number">1</span>, i + <span class="number">1</span>, j]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(s[res[<span class="number">1</span>]:res[<span class="number">2</span>]])</span><br></pre></td></tr></table></figure><h4 id="6-Z-字形变换-力扣（LeetCode）"><a href="#6-Z-字形变换-力扣（LeetCode）" class="headerlink" title="6. Z 字形变换 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/zigzag-conversion/" target="_blank" rel="noopener">6. Z 字形变换 - 力扣（LeetCode）</a></h4><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">P</span>   A   H   N</span><br><span class="line">A <span class="keyword">P</span> L S I I G</span><br><span class="line"><span class="keyword">Y</span>   I   <span class="keyword">R</span></span><br></pre></td></tr></table></figure><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;PAHNAPLSIIGYIR&quot;</code>。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"PAYPALISHIRING"</span>, <span class="attr">numRows</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="string">"PAHNAPLSIIGYIR"</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"PAYPALISHIRING"</span>, numRows = <span class="number">4</span></span><br><span class="line">输出：<span class="string">"PINALSIGYAHRPI"</span></span><br><span class="line">解释：</span><br><span class="line"><span class="keyword">P</span>     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line"><span class="keyword">Y</span> A   H <span class="keyword">R</span></span><br><span class="line"><span class="keyword">P</span>     I</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"A"</span>, <span class="attr">numRows</span> = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"A"</span></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><p>找规律问题！！！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s: str, numRows: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        res = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(numRows)]</span><br><span class="line">        s = list(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            temp = i % ( numRows + numRows <span class="number">-2</span> )</span><br><span class="line">            <span class="keyword">if</span> temp &lt; numRows:</span><br><span class="line">                res[temp].append(s[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[(numRows - <span class="number">1</span>) - temp % (numRows - <span class="number">1</span>)].append(s[i])</span><br><span class="line">        ans = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> res:</span><br><span class="line">            ans = ans + <span class="string">""</span>.join(row)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="7-整数反转-力扣（LeetCode）"><a href="#7-整数反转-力扣（LeetCode）" class="headerlink" title="7. 整数反转 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/reverse-integer/" target="_blank" rel="noopener">7. 整数反转 - 力扣（LeetCode）</a></h4><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 [−2^31,  2^31 − 1] ，就返回 0。</p><p>假设环境不允许存储 64 位整数（有符号或无符号）。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">123</span></span><br><span class="line">输出：<span class="number">321</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">-123</span></span><br><span class="line">输出：<span class="number">-321</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">120</span></span><br><span class="line">输出：<span class="number">21</span></span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">0</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><p>简单的反转整数加一个越界判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        symbol, ans = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        maxnum, minnum = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>, <span class="number">-1</span> * <span class="number">2</span> ** <span class="number">31</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>: symbol, x = <span class="number">-1</span>, abs(x)</span><br><span class="line">        <span class="keyword">while</span> x:</span><br><span class="line">            ans = ans * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> (symbol &gt; <span class="number">0</span> <span class="keyword">and</span> ans &gt; maxnum) <span class="keyword">or</span> (symbol &lt; <span class="number">0</span> <span class="keyword">and</span> ans * symbol &lt; minnum): <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> symbol * ans</span><br></pre></td></tr></table></figure><h4 id="8-字符串转换整数-atoi-力扣（LeetCode）"><a href="#8-字符串转换整数-atoi-力扣（LeetCode）" class="headerlink" title="8. 字符串转换整数 (atoi) - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8. 字符串转换整数 (atoi) - 力扣（LeetCode）</a></h4><p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。</p><p>函数 myAtoi(string s) 的算法如下：</p><p>读入字符串并丢弃无用的前导空格<br>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。<br>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。<br>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。<br>如果整数数超过 32 位有符号整数范围 [−2^31,  2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。<br>返回整数作为最终结果。<br>注意：</p><p>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。</p><p><strong>示例1</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"42"</span></span><br><span class="line">输出：<span class="number">42</span></span><br><span class="line">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。</span><br><span class="line">第 <span class="number">1</span> 步：<span class="string">"42"</span>（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 <span class="number">2</span> 步：<span class="string">"42"</span>（当前没有读入字符，因为这里不存在 '-' 或者 '+'）</span><br><span class="line">         ^</span><br><span class="line">第 <span class="number">3</span> 步：<span class="string">"42"</span>（读入 <span class="string">"42"</span>）</span><br><span class="line">           ^</span><br><span class="line">解析得到整数 <span class="number">42</span> 。</span><br><span class="line">由于 <span class="string">"42"</span> 在范围 [<span class="number">-231</span>, <span class="number">231</span> - <span class="number">1</span>] 内，最终结果为 <span class="number">42</span> 。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"4193 with words"</span></span><br><span class="line">输出：<span class="number">4193</span></span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">1</span> 步：<span class="string">"4193 with words"</span>（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 <span class="number">2</span> 步：<span class="string">"4193 with words"</span>（当前没有读入字符，因为这里不存在 '-' 或者 '+'）</span><br><span class="line">         ^</span><br><span class="line">第 <span class="number">3</span> 步：<span class="string">"4193 with words"</span>（读入 <span class="string">"4193"</span>；由于下一个字符不是一个数字，所以读入停止）</span><br><span class="line">             ^</span><br><span class="line">解析得到整数 <span class="number">4193</span> 。</span><br><span class="line">由于 <span class="string">"4193"</span> 在范围 [<span class="number">-231</span>, <span class="number">231</span> - <span class="number">1</span>] 内，最终结果为 <span class="number">4193</span> 。</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><p>字符串转数字加一个越界判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        s = list(s.strip())</span><br><span class="line">        symbol, ans = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        maxnum, minnum = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>, <span class="number">-1</span> * <span class="number">2</span> ** <span class="number">31</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> (s[i] == <span class="string">'-'</span> <span class="keyword">or</span> s[i] == <span class="string">'+'</span>):</span><br><span class="line">                symbol = <span class="number">-1</span> <span class="keyword">if</span> s[i] == <span class="string">'-'</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="string">'0'</span> &lt;= s[i] &lt;= <span class="string">'9'</span>:</span><br><span class="line">                <span class="keyword">if</span> symbol &gt; <span class="number">0</span> <span class="keyword">and</span> (ans &gt; maxnum // <span class="number">10</span> <span class="keyword">or</span> (ans == maxnum // <span class="number">10</span> <span class="keyword">and</span> int(s[i]) &gt; maxnum % <span class="number">10</span>)):</span><br><span class="line">                    <span class="keyword">return</span> maxnum</span><br><span class="line">                <span class="keyword">if</span> symbol &lt; <span class="number">0</span> <span class="keyword">and</span> (ans &gt; abs(minnum) // <span class="number">10</span> <span class="keyword">or</span> (ans == abs(minnum) // <span class="number">10</span> <span class="keyword">and</span> int(s[i]) &gt; abs(maxnum) % <span class="number">10</span>)):</span><br><span class="line">                    <span class="keyword">return</span> minnum</span><br><span class="line">                ans = ans * <span class="number">10</span> + int(s[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans * symbol</span><br></pre></td></tr></table></figure><h4 id="9-回文数-力扣（LeetCode）"><a href="#9-回文数-力扣（LeetCode）" class="headerlink" title="9. 回文数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/palindrome-number/" target="_blank" rel="noopener">9. 回文数 - 力扣（LeetCode）</a></h4><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>例如，121 是回文，而 123 不是。</p><p><strong>示例 1：</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">x</span> = <span class="number">121</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">-121</span></span><br><span class="line">输出：false</span><br><span class="line">解释：从左向右读, 为 <span class="number">-121</span> 。 从右向左读, 为 <span class="number">121</span>- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">x</span> = <span class="number">10</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：从右向左读, 为 <span class="number">01</span> 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> bool(str(x) == str(x)[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h4 id="10-正则表达式匹配-力扣（LeetCode）"><a href="#10-正则表达式匹配-力扣（LeetCode）" class="headerlink" title="10. 正则表达式匹配 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/regular-expression-matching/" target="_blank" rel="noopener">10. 正则表达式匹配 - 力扣（LeetCode）</a></h4><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"aa"</span>, <span class="attr">p</span> = <span class="string">"a"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：<span class="string">"a"</span> 无法匹配 <span class="string">"aa"</span> 整个字符串。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="comment">"aa"</span>, p = <span class="comment">"a*"</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：因为 <span class="string">'*'</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="string">'a'</span>。因此，字符串 <span class="comment">"aa"</span> 可被视为 <span class="string">'a'</span> 重复了一次。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"ab"</span>, <span class="selector-tag">p</span> = <span class="string">".*"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：<span class="string">".*"</span> 表示可匹配零个或多个（<span class="string">'*'</span>）任意字符（<span class="string">'.'</span>）。</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        s, p = list(s), list(p)</span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(p) + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(p) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = bool(j == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> p[i - <span class="number">1</span>] != <span class="string">"*"</span>:</span><br><span class="line">                        <span class="keyword">if</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> (p[i - <span class="number">1</span>] == s[j - <span class="number">1</span>] <span class="keyword">or</span> p[i - <span class="number">1</span>] == <span class="string">'.'</span>):</span><br><span class="line">                            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> i &gt;= <span class="number">2</span>:</span><br><span class="line">                            dp[i][j] = dp[i][j] <span class="keyword">or</span> dp[i - <span class="number">2</span>][j]</span><br><span class="line">                        <span class="keyword">if</span> i &gt;= <span class="number">2</span> <span class="keyword">and</span> j &gt;= <span class="number">1</span> <span class="keyword">and</span> (p[i - <span class="number">2</span>] == s[j - <span class="number">1</span>] <span class="keyword">or</span> p[i - <span class="number">2</span>] == <span class="string">'.'</span>):</span><br><span class="line">                            dp[i][j] = dp[i][j] <span class="keyword">or</span> dp[i][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[len(p)][len(s)]</span><br></pre></td></tr></table></figure><h4 id="11-盛最多水的容器-力扣（LeetCode）"><a href="#11-盛最多水的容器-力扣（LeetCode）" class="headerlink" title="11. 盛最多水的容器 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器 - 力扣（LeetCode）</a></h4><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><p><strong>示例1</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">49</span> </span><br><span class="line">解释：图中垂直线代表输入数组 [<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="number">49</span>。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><p>双指针，每次移动height值较小的那一边。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(height) - <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            res = max(res, min(height[left], height[right]) * (right - left))</span><br><span class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="12-整数转罗马数字-力扣（LeetCode）"><a href="#12-整数转罗马数字-力扣（LeetCode）" class="headerlink" title="12. 整数转罗马数字 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/integer-to-roman/" target="_blank" rel="noopener">12. 整数转罗马数字 - 力扣（LeetCode）</a></h4><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给你一个整数，将其转为罗马数字。</p><p><strong>示例 1:</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="built_in">num</span> = <span class="number">3</span></span><br><span class="line">输出: <span class="string">"III"</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">num</span> = <span class="number">58</span></span><br><span class="line">输出: <span class="string">"LVIII"</span></span><br><span class="line">解释: <span class="attr">L</span> = <span class="number">50</span>, <span class="attr">V</span> = <span class="number">5</span>, <span class="attr">III</span> = <span class="number">3</span>.</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">num</span> = <span class="number">1994</span></span><br><span class="line">输出: <span class="string">"MCMXCIV"</span></span><br><span class="line">解释: <span class="attr">M</span> = <span class="number">1000</span>, <span class="attr">CM</span> = <span class="number">900</span>, <span class="attr">XC</span> = <span class="number">90</span>, <span class="attr">IV</span> = <span class="number">4</span>.</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    symbol = [(<span class="number">1000</span>, <span class="string">'M'</span>),</span><br><span class="line">            (<span class="number">900</span>, <span class="string">'CM'</span>),</span><br><span class="line">            (<span class="number">500</span>, <span class="string">'D'</span>),</span><br><span class="line">            (<span class="number">400</span>, <span class="string">'CD'</span>),</span><br><span class="line">            (<span class="number">100</span>, <span class="string">'C'</span>),</span><br><span class="line">            (<span class="number">90</span>, <span class="string">'XC'</span>),</span><br><span class="line">            (<span class="number">50</span>, <span class="string">'L'</span>),</span><br><span class="line">            (<span class="number">40</span>, <span class="string">'XL'</span>),</span><br><span class="line">            (<span class="number">10</span>, <span class="string">'X'</span>),</span><br><span class="line">            (<span class="number">9</span>, <span class="string">'IX'</span>),</span><br><span class="line">            (<span class="number">5</span>, <span class="string">'V'</span>),</span><br><span class="line">            (<span class="number">4</span>, <span class="string">'IV'</span>),</span><br><span class="line">            (<span class="number">1</span>, <span class="string">'I'</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line"></span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> value, s <span class="keyword">in</span> Solution.symbol:</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= value):</span><br><span class="line">                num -= value</span><br><span class="line">                res += s</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="13-罗马数字转整数-力扣（LeetCode）"><a href="#13-罗马数字转整数-力扣（LeetCode）" class="headerlink" title="13. 罗马数字转整数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/roman-to-integer/" target="_blank" rel="noopener">13. 罗马数字转整数 - 力扣（LeetCode）</a></h4><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。 </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             <span class="number">1</span></span><br><span class="line">V             <span class="number">5</span></span><br><span class="line">X             <span class="number">10</span></span><br><span class="line">L             <span class="number">50</span></span><br><span class="line">C             <span class="number">100</span></span><br><span class="line">D             <span class="number">500</span></span><br><span class="line">M             <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。</p><p> <strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = "III"</span></span><br><span class="line"><span class="section">输出: 3</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">"LVIII"</span></span><br><span class="line">输出: <span class="number">58</span></span><br><span class="line">解释: <span class="attr">L</span> = <span class="number">50</span>, <span class="attr">V=</span> <span class="number">5</span>, <span class="attr">III</span> = <span class="number">3</span>.</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">"MCMXCIV"</span></span><br><span class="line">输出: <span class="number">1994</span></span><br><span class="line">解释: <span class="attr">M</span> = <span class="number">1000</span>, <span class="attr">CM</span> = <span class="number">900</span>, <span class="attr">XC</span> = <span class="number">90</span>, <span class="attr">IV</span> = <span class="number">4</span>.</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><p>直接模拟</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    symbol = &#123;<span class="string">'M'</span>: <span class="number">1000</span>,</span><br><span class="line">            <span class="string">'CM'</span>: <span class="number">900</span>,</span><br><span class="line">            <span class="string">'D'</span>: <span class="number">500</span>,</span><br><span class="line">            <span class="string">'CD'</span>: <span class="number">400</span>,</span><br><span class="line">            <span class="string">'C'</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="string">'XC'</span>: <span class="number">90</span>,</span><br><span class="line">            <span class="string">'L'</span>: <span class="number">50</span>,</span><br><span class="line">            <span class="string">'XL'</span>: <span class="number">40</span>,</span><br><span class="line">            <span class="string">'X'</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="string">'IX'</span>: <span class="number">9</span>,</span><br><span class="line">            <span class="string">'V'</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">'IV'</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="string">'I'</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        ans, s, i = <span class="number">0</span>, list(s), <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'C'</span>:</span><br><span class="line">                <span class="keyword">if</span> i + <span class="number">1</span> &lt; len(s) <span class="keyword">and</span> (s[i + <span class="number">1</span>] == <span class="string">'D'</span> <span class="keyword">or</span> s[i + <span class="number">1</span>] == <span class="string">'M'</span>):</span><br><span class="line">                    ans += Solution.symbol[<span class="string">''</span>.join(s[i:(i + <span class="number">2</span>)])]</span><br><span class="line">                    i += <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans += Solution.symbol[s[i]]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'X'</span>:</span><br><span class="line">                <span class="keyword">if</span> i + <span class="number">1</span> &lt; len(s) <span class="keyword">and</span> (s[i + <span class="number">1</span>] == <span class="string">'C'</span> <span class="keyword">or</span> s[i + <span class="number">1</span>] == <span class="string">'L'</span>):</span><br><span class="line">                    ans += Solution.symbol[<span class="string">''</span>.join(s[i:(i + <span class="number">2</span>)])]</span><br><span class="line">                    i += <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans += Solution.symbol[s[i]]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'I'</span>:</span><br><span class="line">                <span class="keyword">if</span> i + <span class="number">1</span> &lt; len(s) <span class="keyword">and</span> (s[i + <span class="number">1</span>] == <span class="string">'X'</span> <span class="keyword">or</span> s[i + <span class="number">1</span>] == <span class="string">'V'</span>):</span><br><span class="line">                    ans += Solution.symbol[<span class="string">''</span>.join(s[i:(i + <span class="number">2</span>)])]</span><br><span class="line">                    i += <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans += Solution.symbol[s[i]]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'M'</span>:</span><br><span class="line">                ans, i = ans + <span class="number">1000</span>, i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'D'</span>:</span><br><span class="line">                ans, i = ans + <span class="number">500</span>, i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'L'</span>:</span><br><span class="line">                ans, i = ans + <span class="number">50</span>, i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'V'</span>:</span><br><span class="line">                ans, i = ans + <span class="number">5</span>, i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>可以判断后面一个字符的值是否比当前的大，如果大，可以通过减法减去当前字符的值。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    SYMBOL_VALUES = &#123;</span><br><span class="line">        <span class="string">'I'</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">'V'</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">'X'</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="string">'L'</span>: <span class="number">50</span>,</span><br><span class="line">        <span class="string">'C'</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="string">'D'</span>: <span class="number">500</span>,</span><br><span class="line">        <span class="string">'M'</span>: <span class="number">1000</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            value = Solution.SYMBOL_VALUES[ch]</span><br><span class="line">            <span class="keyword">if</span> i &lt; n - <span class="number">1</span> <span class="keyword">and</span> value &lt; Solution.SYMBOL_VALUES[s[i + <span class="number">1</span>]]:</span><br><span class="line">                ans -= value</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += value</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode.cn/problems/roman-to-integer/solution/luo-ma-shu-zi-zhuan-zheng-shu-by-leetcod-w55p/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="14-最长公共前缀-力扣（LeetCode）"><a href="#14-最长公共前缀-力扣（LeetCode）" class="headerlink" title="14. 最长公共前缀 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-common-prefix/" target="_blank" rel="noopener">14. 最长公共前缀 - 力扣（LeetCode）</a></h4><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">strs </span>= [<span class="string">"flower"</span>,<span class="string">"flow"</span>,<span class="string">"flight"</span>]</span><br><span class="line">输出：<span class="string">"fl"</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">strs </span>= [<span class="string">"dog"</span>,<span class="string">"racecar"</span>,<span class="string">"car"</span>]</span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        ans, l = [], <span class="number">200</span></span><br><span class="line">        strs = [list(row) <span class="keyword">for</span> row <span class="keyword">in</span> strs]</span><br><span class="line">        l = min(len(row) <span class="keyword">for</span> row <span class="keyword">in</span> strs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            c = strs[<span class="number">0</span>][i]</span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> strs[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> row[i] != c:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">""</span>.join(ans)</span><br><span class="line">            ans.append(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(ans)</span><br></pre></td></tr></table></figure><h4 id="15-三数之和-力扣（LeetCode）"><a href="#15-三数之和-力扣（LeetCode）" class="headerlink" title="15. 三数之和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/3sum/" target="_blank" rel="noopener">15. 三数之和 - 力扣（LeetCode）</a></h4><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-4</span>]</span><br><span class="line">输出：[[<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">2</span>],[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="string">[]</span></span><br><span class="line">输出：<span class="string">[]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="string">[0]</span></span><br><span class="line">输出：<span class="string">[]</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>三个数之和为0，其实还是双指针。</p><p>排序，先枚举第一个数nums[a]，然后在剩下的数组中用双指针找和为-nums[a]的两个数，需要判断重复的时候跳出当前循环继续循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        n, ans = len(nums), []</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">3</span>: <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> a &gt; <span class="number">0</span> <span class="keyword">and</span> nums[a] == nums[a - <span class="number">1</span>]: <span class="keyword">continue</span> <span class="comment"># 如果当前的值与前面的一个值相同，跳出，因为这个值已经计算过了</span></span><br><span class="line"></span><br><span class="line">            c = n - <span class="number">1</span>  <span class="comment"># c从末尾往前找</span></span><br><span class="line">            target = <span class="number">-1</span> * nums[a]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> range(a + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> b &gt; a + <span class="number">1</span> <span class="keyword">and</span> nums[b] == nums[b - <span class="number">1</span>]: <span class="keyword">continue</span>  <span class="comment"># 如果当前的值与前面的一个b相同，跳出</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> b &lt; c <span class="keyword">and</span> nums[b] + nums[c] &gt; target:  <span class="comment"># 如果最小的b与当前的c相加都大于target，则将c的值减小</span></span><br><span class="line">                    c -= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> b == c: <span class="keyword">break</span>  <span class="comment"># b和c指向同一个值</span></span><br><span class="line">                <span class="keyword">if</span> nums[b] + nums[c] == target:</span><br><span class="line">                    ans.append([nums[a], nums[b], nums[c]])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="16-最接近的三数之和-力扣（LeetCode）"><a href="#16-最接近的三数之和-力扣（LeetCode）" class="headerlink" title="16. 最接近的三数之和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和 - 力扣（LeetCode）</a></h4><p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。</p><p>返回这三个数的和。</p><p>假定每组输入只存在恰好一个解。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-4</span>], target = <span class="number">1</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：与 target 最接近的和是 <span class="number">2</span> (<span class="number">-1</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">2</span>) 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], target = <span class="number">1</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><p>与上面方法一样，先枚举一个数a，然后在剩下的数组中用双指针找出和最接近target的三个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        n, ans = len(nums), <span class="number">10</span>**<span class="number">7</span></span><br><span class="line"></span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> a &gt; <span class="number">0</span> <span class="keyword">and</span> nums[a] == nums[a - <span class="number">1</span>]: <span class="keyword">continue</span>  <span class="comment"># 去除相同的a</span></span><br><span class="line"></span><br><span class="line">            b, c = a + <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> b &lt; c:</span><br><span class="line">                s = nums[a] + nums[b] + nums[c]</span><br><span class="line">                <span class="keyword">if</span> s == target:</span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> abs(s - target) &lt; abs(ans - target): ans = s</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> s &gt; target:</span><br><span class="line">                    c -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> (c &gt; b <span class="keyword">and</span> nums[c] == nums[c + <span class="number">1</span>]):  <span class="comment"># 去除相同的c</span></span><br><span class="line">                        c -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    b += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> c &gt; b <span class="keyword">and</span> nums[b] == nums[b - <span class="number">1</span>]:  <span class="comment"># 去除相同的b</span></span><br><span class="line">                        b += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="17-电话号码的字母组合-力扣（LeetCode）"><a href="#17-电话号码的字母组合-力扣（LeetCode）" class="headerlink" title="17. 电话号码的字母组合 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合 - 力扣（LeetCode）</a></h4><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt></p><p><strong>示例 1：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">digits</span> = <span class="string">"23"</span></span><br><span class="line">输出：[<span class="string">"ad"</span>,<span class="string">"ae"</span>,<span class="string">"af"</span>,<span class="string">"bd"</span>,<span class="string">"be"</span>,<span class="string">"bf"</span>,<span class="string">"cd"</span>,<span class="string">"ce"</span>,<span class="string">"cf"</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = <span class="string">""</span></span><br><span class="line">输出：<span class="string">[]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">digits</span> = <span class="string">"2"</span></span><br><span class="line">输出：[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><p>先递归得到digits前n-1个字符的所有结果，然后再将得到的前n-1个字符的结果与最后一个字符的字母组合进行一个全排列。</p><p>注意递归结束条件为当前字符串长度为1， 直接返回当前字符所对应的字母组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    d = &#123;<span class="string">'2'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">        <span class="string">'3'</span>: [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>],</span><br><span class="line">        <span class="string">'4'</span>: [<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>],</span><br><span class="line">        <span class="string">'5'</span>: [<span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>],</span><br><span class="line">        <span class="string">'6'</span>: [<span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>],</span><br><span class="line">        <span class="string">'7'</span>: [<span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>],</span><br><span class="line">        <span class="string">'8'</span>: [<span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>],</span><br><span class="line">        <span class="string">'9'</span>: [<span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits: <span class="keyword">return</span> []</span><br><span class="line">        digits = list(digits)</span><br><span class="line">        <span class="keyword">if</span> len(digits) == <span class="number">1</span>: <span class="keyword">return</span> Solution.d[digits[<span class="number">-1</span>]]</span><br><span class="line"></span><br><span class="line">        res = self.letterCombinations(digits[:<span class="number">-1</span>])  <span class="comment"># 得到前n-1个字符的结果</span></span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> res:  <span class="comment"># 然后将前n-1个字符的结果与最后一个字符的字母矩阵进行一个全排列</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> Solution.d[digits[<span class="number">-1</span>]]:</span><br><span class="line">                ans.append(i + j)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="18-四数之和-力扣（LeetCode）"><a href="#18-四数之和-力扣（LeetCode）" class="headerlink" title="18. 四数之和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/4sum/" target="_blank" rel="noopener">18. 四数之和 - 力扣（LeetCode）</a></h4><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p><p>0 &lt;= a, b, c, d &lt; n<br>a、b、c 和 d 互不相同<br>nums[a] + nums[b] + nums[c] + nums[d] == target<br>你可以按 任意顺序 返回答案 。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-2</span>,<span class="number">2</span>], target = <span class="number">0</span></span><br><span class="line">输出：[[<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">-2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>],[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>], target = <span class="number">8</span></span><br><span class="line">输出：[[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><p>仿照前面的三个数之和，先排序，枚举前面两个数，然后在剩余的数组中用双指针找出剩余的两个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        quadruplets = list()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> len(nums) &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> quadruplets</span><br><span class="line">        </span><br><span class="line">        nums.sort()</span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length - <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[length - <span class="number">3</span>] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, length - <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                left, right = j + <span class="number">1</span>, length - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    total = nums[i] + nums[j] + nums[left] + nums[right]</span><br><span class="line">                    <span class="keyword">if</span> total == target:</span><br><span class="line">                        quadruplets.append([nums[i], nums[j], nums[left], nums[right]])</span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                            left += <span class="number">1</span></span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> total &lt; target:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> quadruplets</span><br></pre></td></tr></table></figure><h4 id="19-删除链表的倒数第-N-个结点-力扣（LeetCode）"><a href="#19-删除链表的倒数第-N-个结点-力扣（LeetCode）" class="headerlink" title="19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></h4><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。 </p><p><strong>示例1</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1]</span>, n = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>], n = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><p>双指针，先将两个指针指向head，然后一个指针往后面走n位，再两个同时往后面走，当后面那个指针到链表尾时，前面的一个指针指向的就是倒数第n个节点，注意判断，要删除的就是头节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head: ListNode, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head.next == <span class="literal">None</span> <span class="keyword">and</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        pre, cur = head, head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> cur == <span class="literal">None</span>: <span class="keyword">return</span> pre.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur.next != <span class="literal">None</span>:</span><br><span class="line">            pre, cur = pre.next, cur.next</span><br><span class="line">        </span><br><span class="line">        pre.next = pre.next.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h4 id="20-有效的括号-力扣（LeetCode）"><a href="#20-有效的括号-力扣（LeetCode）" class="headerlink" title="20. 有效的括号 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号 - 力扣（LeetCode）</a></h4><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"()[]&#123;&#125;"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"&#123;[]&#125;"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"([)]"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><p>栈，当遇到左括号时，压入栈中，当遇到右括号时，先判断当前栈是否为空，然后将栈顶出栈，判断当前出栈的元素是否与当前的右括号匹配。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        stack, s = [], list(s)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">'('</span> <span class="keyword">or</span> c == <span class="string">'&#123;'</span> <span class="keyword">or</span> c == <span class="string">"["</span>:</span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack.pop() != <span class="string">'('</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'&#125;'</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack.pop() != <span class="string">'&#123;'</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">']'</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack.pop() != <span class="string">'['</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> bool(<span class="keyword">not</span> stack)</span><br></pre></td></tr></table></figure><h4 id="21-合并两个有序链表-力扣（LeetCode）"><a href="#21-合并两个有序链表-力扣（LeetCode）" class="headerlink" title="21. 合并两个有序链表 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表 - 力扣（LeetCode）</a></h4><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。  </p><p><strong>示例1</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], l2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="string">[]</span>, l2 = <span class="string">[]</span></span><br><span class="line">输出：<span class="string">[]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="string">[]</span>, l2 = <span class="string">[0]</span></span><br><span class="line">输出：<span class="string">[0]</span></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, list1: Optional[ListNode], list2: Optional[ListNode])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list1 <span class="keyword">and</span> <span class="keyword">not</span> list2: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list1: <span class="keyword">return</span> list2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list2: <span class="keyword">return</span> list1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> list1.val &lt;= list2.val:</span><br><span class="line">            head, pre, cur, ins = list1, list1, list1.next, list2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            head, pre, cur, ins = list2, list2, list2.next, list1</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> ins:</span><br><span class="line">            <span class="keyword">if</span> pre.val &lt;= ins.val &lt; cur.val:</span><br><span class="line">                pre.next = ins</span><br><span class="line">                temp = ins.next</span><br><span class="line">                ins.next = cur</span><br><span class="line"></span><br><span class="line">                pre, ins = ins, temp</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre, cur = cur, cur.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur: pre.next = ins</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p><strong>递归写法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, list1: Optional[ListNode], list2: Optional[ListNode])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list1:</span><br><span class="line">            <span class="keyword">return</span> list2</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> list2:</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">elif</span> list1.val &lt;= list2.val:</span><br><span class="line">            list1.next = self.mergeTwoLists(list1.next, list2)</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            list2.next = self.mergeTwoLists(list1, list2.next)</span><br><span class="line">            <span class="keyword">return</span> list2</span><br></pre></td></tr></table></figure><p><strong>迭代写法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, list1: Optional[ListNode], list2: Optional[ListNode])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">        prehead = ListNode(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        cur = prehead</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &lt;= list2.val:</span><br><span class="line">                cur.next = list1</span><br><span class="line">                list1 = list1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next = list2</span><br><span class="line">                list2 = list2.next</span><br><span class="line">                </span><br><span class="line">            cur = cur.next</span><br><span class="line">        </span><br><span class="line">        cur.next = list1 <span class="keyword">if</span> <span class="keyword">not</span> list2 <span class="keyword">else</span> list2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prehead.next</span><br></pre></td></tr></table></figure><h4 id="22-括号生成-力扣（LeetCode）"><a href="#22-括号生成-力扣（LeetCode）" class="headerlink" title="22. 括号生成 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成 - 力扣（LeetCode）</a></h4><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。 </p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">3</span></span><br><span class="line">输出：[<span class="string">"((()))"</span>,<span class="string">"(()())"</span>,<span class="string">"(())()"</span>,<span class="string">"()(())"</span>,<span class="string">"()()()"</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">1</span></span><br><span class="line">输出：[<span class="string">"()"</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>dp</p><p>dp[i]为一个矩阵，里面保存的是i对括号的所有可能。</p><p>然后可以发现，每次加一对括号时，dp[i + 1]的结果，就是将前面的i对括号的结果分别可以分开放在当前()的里面或者外面，</p><p>假设放在括号里面的为p，放在外面的为q，那么当前的dp[i + 1]就为 ( + p + ) + q。</p><p>所有遍历p和q所有的可能就行，p + q = i</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line"></span><br><span class="line">        dp = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = [<span class="string">""</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                p = dp[j]</span><br><span class="line">                q = dp[i - <span class="number">1</span> - j]</span><br><span class="line">                <span class="keyword">for</span> k1 <span class="keyword">in</span> p:</span><br><span class="line">                    <span class="keyword">for</span> k2 <span class="keyword">in</span> q:</span><br><span class="line">                        dp[i].append(<span class="string">'('</span> + k1 + <span class="string">')'</span> + k2)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h4 id="23-合并K个升序链表-力扣（LeetCode）"><a href="#23-合并K个升序链表-力扣（LeetCode）" class="headerlink" title="23. 合并K个升序链表 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个升序链表 - 力扣（LeetCode）</a></h4><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = <span class="string">[]</span></span><br><span class="line">输出：<span class="string">[]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = <span class="string">[[]]</span></span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>归并排序的思想，</p><p>写一个合并两个有序链表的子函数，然后将k个有序的链表每次两两分开，然后再调用合并两个有序链表的子函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[Optional[ListNode]])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.merge(lists, <span class="number">0</span>, len(lists) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, lists, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == right: <span class="keyword">return</span> lists[left]</span><br><span class="line">        <span class="keyword">if</span> left &gt; right: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> self.mergeTwoLists(self.merge(lists, left, mid), self.merge(lists, mid + <span class="number">1</span>, right))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        prehead = ListNode(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        cur = prehead</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                cur.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        </span><br><span class="line">        cur.next = l1 <span class="keyword">if</span> <span class="keyword">not</span> l2 <span class="keyword">else</span> l2</span><br><span class="line">        <span class="keyword">return</span> prehead.next</span><br></pre></td></tr></table></figure><h4 id="24-两两交换链表中的节点-力扣（LeetCode）"><a href="#24-两两交换链表中的节点-力扣（LeetCode）" class="headerlink" title="24. 两两交换链表中的节点 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></h4><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 </p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[]</span></span><br><span class="line">输出：<span class="string">[]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1]</span></span><br><span class="line">输出：<span class="string">[1]</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>前后指针，双指针。每次指向要交换的两个节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        pre = ListNode(<span class="number">-1</span>)</span><br><span class="line">        pre.next = head</span><br><span class="line"></span><br><span class="line">        newhead = pre</span><br><span class="line"></span><br><span class="line">        left, right = head, head.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> right:</span><br><span class="line">            temp = right.next</span><br><span class="line">            pre.next = right</span><br><span class="line">            right.next = left</span><br><span class="line">            left.next = temp</span><br><span class="line"></span><br><span class="line">            right = temp</span><br><span class="line">            right = right.next <span class="keyword">if</span> right <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            left, pre = temp, left</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newhead.next</span><br></pre></td></tr></table></figure><p><strong>递归</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        newHead = head.next</span><br><span class="line">        head.next = self.swapPairs(newHead.next)</span><br><span class="line">        newHead.next = head</span><br><span class="line">        <span class="keyword">return</span> newHead</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode.cn/problems/swap-nodes-<span class="keyword">in</span>-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di<span class="number">-91</span>/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p><strong>迭代</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        dummyHead = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummyHead.next = head</span><br><span class="line">        temp = dummyHead</span><br><span class="line">        <span class="keyword">while</span> temp.next <span class="keyword">and</span> temp.next.next:</span><br><span class="line">            node1 = temp.next</span><br><span class="line">            node2 = temp.next.next</span><br><span class="line">            temp.next = node2</span><br><span class="line">            node1.next = node2.next</span><br><span class="line">            node2.next = node1</span><br><span class="line">            temp = node1</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode.cn/problems/swap-nodes-<span class="keyword">in</span>-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di<span class="number">-91</span>/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="25-K-个一组翻转链表-力扣（LeetCode）"><a href="#25-K-个一组翻转链表-力扣（LeetCode）" class="headerlink" title="25. K 个一组翻转链表 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. K 个一组翻转链表 - 力扣（LeetCode）</a></h4><p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>先实现前面k个链表的反转，然后再递归调用实现后面链表的反转。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: Optional[ListNode], k: int)</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k == <span class="number">1</span>: <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            count, cur = count + <span class="number">1</span>, cur.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> count &lt; k : <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        newhead, pre, cur = head, head, head.next</span><br><span class="line"></span><br><span class="line">        n = k - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            n = n - <span class="number">1</span></span><br><span class="line">            temp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            pre, cur = cur, temp</span><br><span class="line">        </span><br><span class="line">        newhead.next = self.reverseKGroup(temp, k)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 翻转一个子链表，并且返回新的头与尾</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, head: ListNode, tail: ListNode)</span>:</span></span><br><span class="line">        prev = tail.next</span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> prev != tail:</span><br><span class="line">            nex = p.next</span><br><span class="line">            p.next = prev</span><br><span class="line">            prev = p</span><br><span class="line">            p = nex</span><br><span class="line">        <span class="keyword">return</span> tail, head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        hair = ListNode(<span class="number">0</span>)</span><br><span class="line">        hair.next = head</span><br><span class="line">        pre = hair</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            tail = pre</span><br><span class="line">            <span class="comment"># 查看剩余部分长度是否大于等于 k</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">                tail = tail.next</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">                    <span class="keyword">return</span> hair.next</span><br><span class="line">            nex = tail.next</span><br><span class="line">            head, tail = self.reverse(head, tail)</span><br><span class="line">            <span class="comment"># 把子链表重新接回原链表</span></span><br><span class="line">            pre.next = head</span><br><span class="line">            tail.next = nex</span><br><span class="line">            pre = tail</span><br><span class="line">            head = tail.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> hair.next</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode.cn/problems/reverse-nodes-<span class="keyword">in</span>-k-group/solution/k-ge-yi-zu-fan-zhuan-lian-biao-by-leetcode-solutio/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="26-删除有序数组中的重复项-力扣（LeetCode）"><a href="#26-删除有序数组中的重复项-力扣（LeetCode）" class="headerlink" title="26. 删除有序数组中的重复项 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除有序数组中的重复项 - 力扣（LeetCode）</a></h4><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p><p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p><p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例1</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">2</span>, nums = [<span class="number">1</span>,<span class="number">2</span>,_]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">2</span> ，并且原数组 nums 的前两个元素被修改为 <span class="number">1</span>, <span class="number">2</span> 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span>, nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">5</span> ， 并且原数组 nums 的前五个元素被修改为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>升序</strong> 排列</li></ul><p><strong>思路</strong></p><p>双指针，快慢指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span> <span class="keyword">or</span> len(nums) == <span class="number">0</span>: <span class="keyword">return</span> len(nums)</span><br><span class="line"></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> j &lt; len(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[j] != nums[i]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                nums[i] = nums[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="27-移除元素-力扣（LeetCode）"><a href="#27-移除元素-力扣（LeetCode）" class="headerlink" title="27. 移除元素 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/remove-element/" target="_blank" rel="noopener">27. 移除元素 - 力扣（LeetCode）</a></h4><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例1</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], val = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span>, nums = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">2</span>, 并且 nums 中的前两个元素均为 <span class="number">2</span>。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 <span class="number">2</span> ，而 nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] 或 nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>], val = <span class="number">2</span></span><br><span class="line">输出：<span class="number">5</span>, nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">3</span>]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">5</span>, 并且 nums 中的前五个元素为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><p>双指针，快慢指针。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j] != val:</span><br><span class="line">                nums[i] = nums[j]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><h4 id="28-实现-strStr-力扣（LeetCode）"><a href="#28-实现-strStr-力扣（LeetCode）" class="headerlink" title="28. 实现 strStr() - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/implement-strstr/" target="_blank" rel="noopener">28. 实现 strStr() - 力扣（LeetCode）</a></h4><p>实现 strStr() 函数。</p><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p><p>说明：</p><p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">haystack</span> = <span class="string">"hello"</span>, <span class="attr">needle</span> = <span class="string">"ll"</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">haystack</span> = <span class="string">"aaaaa"</span>, <span class="attr">needle</span> = <span class="string">"bba"</span></span><br><span class="line">输出：-<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><p>直接暴力搜索，或是KMP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle <span class="keyword">or</span> haystack == needle: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        haystack, n = list(haystack), len(needle)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(haystack) - n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">""</span>.join(haystack[i:(i + n)]) == needle:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="29-两数相除-力扣（LeetCode）"><a href="#29-两数相除-力扣（LeetCode）" class="headerlink" title="29. 两数相除 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/divide-two-integers/" target="_blank" rel="noopener">29. 两数相除 - 力扣（LeetCode）</a></h4><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 dividend 除以除数 divisor 得到的商。</p><p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: dividend = 10, divisor = 3</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 10/3 = truncate(3.33333..) = truncate(3) = 3</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: dividend = 7, divisor = <span class="string">-3</span></span><br><span class="line">输出: <span class="string">-2</span></span><br><span class="line">解释: 7/<span class="string">-3</span> = truncate(<span class="string">-2</span>.33333..) = <span class="string">-2</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>被除数和除数均为 32 位有符号整数。<br>除数不为 0。<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。</p><p><strong>代码</strong></p><p>如果被除数减去当前的除数仍然大于0，就把当前的除数x2，并且把结果也x2，然后用被除数减去当前的x2的除数，继续，直到当前的除数比被除数小，然后用当前的差值作为被除数，用原来的除数继续进行这个操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend: int, divisor: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> divisor == <span class="number">1</span>: <span class="keyword">return</span> dividend</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> divisor == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">if</span> dividend == <span class="number">-1</span> * <span class="number">2</span> ** <span class="number">31</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span> * dividend</span><br><span class="line"></span><br><span class="line">        symbol = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dividend &lt; <span class="number">0</span> <span class="keyword">and</span> divisor &gt; <span class="number">0</span>) <span class="keyword">or</span> (dividend &gt; <span class="number">0</span> <span class="keyword">and</span> divisor &lt; <span class="number">0</span>): symbol = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        dividend, divisor = abs(dividend), abs(divisor)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> symbol * self.div(dividend, divisor)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">div</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> a &lt; b: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans, tb = <span class="number">1</span>, b</span><br><span class="line">        <span class="keyword">while</span> ((tb &lt;&lt; <span class="number">1</span>) &lt;= a):</span><br><span class="line">            tb, ans = tb &lt;&lt; <span class="number">1</span>, ans &lt;&lt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans + self.div(a - tb, b)</span><br></pre></td></tr></table></figure><h4 id="hard-30-串联所有单词的子串-力扣（LeetCode）"><a href="#hard-30-串联所有单词的子串-力扣（LeetCode）" class="headerlink" title="(hard) 30. 串联所有单词的子串 - 力扣（LeetCode）"></a>(hard) <a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/" target="_blank" rel="noopener">30. 串联所有单词的子串 - 力扣（LeetCode）</a></h4><p>给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p><p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑 words 中单词串联的顺序。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"barfoothefoobarman"</span>, words = [<span class="string">"foo"</span>,<span class="string">"bar"</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">9</span>]</span><br><span class="line">解释：</span><br><span class="line">从索引 <span class="number">0</span> 和 <span class="number">9</span> 开始的子串分别是 <span class="string">"barfoo"</span> 和 <span class="string">"foobar"</span> 。</span><br><span class="line">输出的顺序不重要, [<span class="number">9</span>,<span class="number">0</span>] 也是有效答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"wordgoodgoodgoodbestword"</span>, <span class="attr">words</span> = [<span class="string">"word"</span>,<span class="string">"good"</span>,<span class="string">"best"</span>,<span class="string">"word"</span>]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"barfoofoobarthefoobarman"</span>, words = [<span class="string">"bar"</span>,<span class="string">"foo"</span>,<span class="string">"the"</span>]</span><br><span class="line">输出：[<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>]</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span><span class="params">(self, s: str, words: List[str])</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        m, n, ls = len(words), len(words[<span class="number">0</span>]), len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i + m * n &gt; ls:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            differ = Counter()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                word = s[i + j * n: i + (j + <span class="number">1</span>) * n]</span><br><span class="line">                differ[word] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">                differ[word] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> differ[word] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> differ[word]</span><br><span class="line">            <span class="keyword">for</span> start <span class="keyword">in</span> range(i, ls - m * n + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> start != i:</span><br><span class="line">                    word = s[start + (m - <span class="number">1</span>) * n: start + m * n]</span><br><span class="line">                    differ[word] += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> differ[word] == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">del</span> differ[word]</span><br><span class="line">                    word = s[start - n: start]</span><br><span class="line">                    differ[word] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> differ[word] == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">del</span> differ[word]</span><br><span class="line">                <span class="keyword">if</span> len(differ) == <span class="number">0</span>:</span><br><span class="line">                    res.append(start)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode.cn/problems/substring-<span class="keyword">with</span>-concatenation-of-all-words/solution/chuan-lian-suo-you-dan-ci-de-zi-chuan-by<span class="number">-244</span>a/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="31-下一个排列-力扣（LeetCode）"><a href="#31-下一个排列-力扣（LeetCode）" class="headerlink" title="31. 下一个排列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/next-permutation/" target="_blank" rel="noopener">31. 下一个排列 - 力扣（LeetCode）</a></h4><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p><p>例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><p>例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</p><p>必须 原地 修改，只允许使用额外常数空间。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>方法一：两遍扫描<br>思路及解法</p><p>注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。具体地：</p><p>我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。</p><p>同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。</p><p>以排列 [4,5,2,6,3,1] 为例：</p><p>我们能找到的符合条件的一对「较小数」与「较大数」的组合为 2 与 3，满足「较小数」尽量靠右，而「较大数」尽可能小。</p><p>当我们完成交换后排列变为 [4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6]。</p><p>具体地，我们这样描述该算法，对于长度为 n 的排列 a：</p><p>首先从后向前查找第一个顺序对 (i,i+1)，满足 a[i] &lt; a[i+1]。这样「较小数」即为 a[i]。此时[i+1,n) 必然是下降序列。</p><p>如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素 jj 满足 a[i] &lt; a[j]。这样「较大数」即为 a[j]。</p><p>交换 a[i]与 a[j]，此时可以证明区间 [i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。</p><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode.cn/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        i = len(nums) - <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i] &gt;=  nums[i + <span class="number">1</span>]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        j = len(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> j &gt; i <span class="keyword">and</span> nums[j] &lt;= nums[i]:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        left, right = i + <span class="number">1</span>, len(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="31-下一个排列-力扣（LeetCode）-1"><a href="#31-下一个排列-力扣（LeetCode）-1" class="headerlink" title="31. 下一个排列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/next-permutation/" target="_blank" rel="noopener">31. 下一个排列 - 力扣（LeetCode）</a></h4><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p><p>例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><p>例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</p><p>必须 原地 修改，只允许使用额外常数空间。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>想法：需要将一个左边的[较小数]与右边的一个[较大数]交换，以能够让当前排列变大，从而得到下一个排列。</p><p>同时需要让这个[较小数]尽量靠右，而[较大数]尽可能小。当交换完成后，需要将[较大数]右边的数需要按照升序重新排列，这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。</p><p>具体思路：对于长度为n的排列a：</p><ol><li>首先从后向前查找第一个顺序对(i, i + 1)，满足<code>a[i] &lt; a[i + 1]</code>。这样[较小数]即为a[i]。此时（[i+1]， n）必然是下降序列。</li><li>如果找到了顺序对，那么在区间[i + 1, n）中从后向前查找第一个元素j满足a[i] &lt; a[j]。这样[较大数]即为a[j]。</li><li>交换a[i]与a[j]，此时可以证明区间[i + 1, n)必为降序，可以直接使用双指针反转区间[i + 1, n)使其变为升序，而无需对该区间进行排序。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        i = len(nums) - <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i] &gt;=  nums[i + <span class="number">1</span>]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        j = len(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> j &gt; i <span class="keyword">and</span> nums[j] &lt;= nums[i]:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        left, right = i + <span class="number">1</span>, len(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="hard-32-最长有效括号-力扣（LeetCode）"><a href="#hard-32-最长有效括号-力扣（LeetCode）" class="headerlink" title="(hard) 32. 最长有效括号 - 力扣（LeetCode）"></a>(hard) <a href="https://leetcode.cn/problems/longest-valid-parentheses/" target="_blank" rel="noopener">32. 最长有效括号 - 力扣（LeetCode）</a></h4><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。 </p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"(()"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最长有效括号子串是 <span class="string">"()"</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">")()())"</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长有效括号子串是 <span class="string">"()()"</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">""</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>dp思路： dp[i]表示以下标i字符结尾的最长有效括号的长度，将dp全部初始化为0，有效的子串一定是以’)’结尾的，返回dp的最大值。</p><p>从前往后遍历字符串求解dp值，每两个字符检查一次：</p><ol><li>s[i] = ‘)’ 且 s[i - 1] = ‘(‘，也就是字符串形如”……..()”，可以得到：<code>dp[i]  = dp[i - 2] + 2</code>。</li><li>s[i] = ‘)’ 且 s[i - 1] = ‘)’，也就是字符串形如”………))”，我们可以推出：如果s[i - dp[i - 1] - 1] = ‘(‘，那么<code>dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2</code>。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        s, dp = list(s), [<span class="number">0</span>] * (len(s))</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> i - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i - <span class="number">1</span>] == <span class="string">'('</span>:</span><br><span class="line">                    dp[i] = (dp[i - <span class="number">2</span>] <span class="keyword">if</span> i - <span class="number">2</span> &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>) + <span class="number">2</span></span><br><span class="line">                <span class="keyword">elif</span> i - <span class="number">1</span> - dp[i - <span class="number">1</span>] &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i - <span class="number">1</span> - dp[i - <span class="number">1</span>]] == <span class="string">'('</span>:</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + (dp[i - <span class="number">1</span> - dp[i - <span class="number">1</span>] - <span class="number">1</span>] <span class="keyword">if</span> i - <span class="number">1</span> - dp[i - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>) + <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            res = max(res, dp[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>栈</strong></p><p>始终保持栈底元素为当前已经遍历过的元素中[最后一个没有被匹配的右括号的下标]，</p><ul><li>对于遇到的每个’(‘，将它的下标放入栈中。</li><li>对于遇到的每个’)’，我们先弹出栈顶元素表示匹配了当前右括号：<ul><li>如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的[最后一个没有被匹配的右括号的下标]</li><li>如果栈不为空，当前右括号的下标减去栈顶元素即为[以该右括号为结尾的最长有效括号的长度]</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        stack, res = [<span class="number">-1</span>], <span class="number">0</span></span><br><span class="line">        s = list(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    stack.append(i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res = max(res, i - stack[<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="33-搜索旋转排序数组-力扣（LeetCode）"><a href="#33-搜索旋转排序数组-力扣（LeetCode）" class="headerlink" title="33. 搜索旋转排序数组 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组 - 力扣（LeetCode）</a></h4><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">0</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>], target = <span class="number">0</span></span><br><span class="line">输出：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>每次二分计算mid时，mid会将当前的数组分成一个有序的数组和一个无序的数组，所以我们可以在有序数组里面判断，然后重新确定二分的上下界。</p><ul><li>如果<code>[l, mid - 1]</code>是有序数组，且<code>target</code>的大小满足<code>[nums[l], nums[mid])</code>，这可以将范围缩小到<code>[l, mid - 1]</code>，否则<code>[mid + 1, r]</code>中寻找。</li><li>如果<code>[mid, r]</code>是有序数组，且<code>target</code>的大小满足<code>(nums[mid + 1], nums[r]]</code>，则可以将范围缩小到<code>[mid + 1, r]</code>，否则<code>[l, mid - 1]</code>中寻找。</li></ul><p>如果判断哪一边是有序的就根据当前的mid与数组的第一个数的大小关系，如果mid指向的数比第一个数大，则说明左边的是有序的，否则就是右边的有序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= nums[mid]:</span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="34-在排序数组中查找元素的第一个和最后一个位置-力扣（LeetCode）"><a href="#34-在排序数组中查找元素的第一个和最后一个位置-力扣（LeetCode）" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></h4><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">8</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [], target = <span class="number">0</span></span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>二分的思想，有O(logN)时间复杂度的一般都是二分的思想，</p><p>思路很简单，通过两次二分分别找出左右边界，注意细节处理就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target: right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: left = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        res_l = right</span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target: right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> res_l + <span class="number">1</span> &gt;= left: <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> [res_l + <span class="number">1</span>, left - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="35-搜索插入位置-力扣（LeetCode）"><a href="#35-搜索插入位置-力扣（LeetCode）" class="headerlink" title="35. 搜索插入位置 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置 - 力扣（LeetCode）</a></h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: nums = [1,3,5,6], target = 5</span></span><br><span class="line"><span class="section">输出: 2</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: nums = [1,3,5,6], target = 2</span></span><br><span class="line"><span class="section">输出: 1</span></span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: nums = [1,3,5,6], target = 7</span></span><br><span class="line"><span class="section">输出: 4</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>标准的二分写法，二分注意细节就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h4 id="36-有效的数独-力扣（LeetCode）"><a href="#36-有效的数独-力扣（LeetCode）" class="headerlink" title="36. 有效的数独 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/valid-sudoku/" target="_blank" rel="noopener">36. 有效的数独 - 力扣（LeetCode）</a></h4><p>请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p><p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</p><p><strong>注意：</strong></p><ul><li>一个有效的数独（部分已被填充）不一定是可解的。</li><li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li><li><p>空白格用 <code>&#39;.&#39;</code> 表示。</p><p><strong>示例1</strong></p></li></ul><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png" alt></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：board = </span><br><span class="line">[[<span class="string">"5"</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"5"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"3"</span>]</span><br><span class="line">,[<span class="string">"4"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>]</span><br><span class="line">,[<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"8"</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"4"</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"5"</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"9"</span>]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：board = </span><br><span class="line">[[<span class="string">"8"</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"5"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"3"</span>]</span><br><span class="line">,[<span class="string">"4"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>]</span><br><span class="line">,[<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"8"</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"4"</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"5"</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"9"</span>]]</span><br><span class="line">输出：false</span><br><span class="line">解释：除了第一行的第一个数字从 <span class="number">5</span> 改为 <span class="number">8</span> 以外，空格内其他数字均与 示例<span class="number">1</span> 相同。 但由于位于左上角的 <span class="number">3</span>x3 宫内有两个 <span class="number">8</span> 存在, 因此这个数独是无效的。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>用三个数组分别存每行每列和每个子矩阵的每个数字出现的次数，当其中有一个元素的次数大于2次时，直接返回False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">        row = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">        col = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">        subbox = [[[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] != <span class="string">'.'</span>:</span><br><span class="line">                    c = int(board[i][j])</span><br><span class="line">                    row[i][c] += <span class="number">1</span></span><br><span class="line">                    col[j][c] += <span class="number">1</span></span><br><span class="line">                    subbox[i // <span class="number">3</span>][j // <span class="number">3</span>][c] += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> row[i][c] &gt; <span class="number">1</span> <span class="keyword">or</span> col[j][c] &gt; <span class="number">1</span> <span class="keyword">or</span> subbox[i // <span class="number">3</span>][j // <span class="number">3</span>][c] &gt; <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="hard-37-解数独-力扣（LeetCode）"><a href="#hard-37-解数独-力扣（LeetCode）" class="headerlink" title="(hard) 37. 解数独 - 力扣（LeetCode）"></a>(hard) <a href="https://leetcode.cn/problems/sudoku-solver/" target="_blank" rel="noopener">37. 解数独 - 力扣（LeetCode）</a></h4><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 遵循如下规则：</p><p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png" alt></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[<span class="string">"5"</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"5"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>],[<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"3"</span>],[<span class="string">"4"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>],[<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>],[<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"8"</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"4"</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"5"</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"9"</span>]]</span><br><span class="line">输出：[[<span class="string">"5"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">"1"</span>,<span class="string">"2"</span>],[<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"2"</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"5"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"8"</span>],[<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"2"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>],[<span class="string">"8"</span>,<span class="string">"5"</span>,<span class="string">"9"</span>,<span class="string">"7"</span>,<span class="string">"6"</span>,<span class="string">"1"</span>,<span class="string">"4"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>],[<span class="string">"4"</span>,<span class="string">"2"</span>,<span class="string">"6"</span>,<span class="string">"8"</span>,<span class="string">"5"</span>,<span class="string">"3"</span>,<span class="string">"7"</span>,<span class="string">"9"</span>,<span class="string">"1"</span>],[<span class="string">"7"</span>,<span class="string">"1"</span>,<span class="string">"3"</span>,<span class="string">"9"</span>,<span class="string">"2"</span>,<span class="string">"4"</span>,<span class="string">"8"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>],[<span class="string">"9"</span>,<span class="string">"6"</span>,<span class="string">"1"</span>,<span class="string">"5"</span>,<span class="string">"3"</span>,<span class="string">"7"</span>,<span class="string">"2"</span>,<span class="string">"8"</span>,<span class="string">"4"</span>],[<span class="string">"2"</span>,<span class="string">"8"</span>,<span class="string">"7"</span>,<span class="string">"4"</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"6"</span>,<span class="string">"3"</span>,<span class="string">"5"</span>],[<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"2"</span>,<span class="string">"8"</span>,<span class="string">"6"</span>,<span class="string">"1"</span>,<span class="string">"7"</span>,<span class="string">"9"</span>]]</span><br><span class="line">解释：输入的数独如上图所示，唯一有效的解决方案如下所示：</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714_solutionsvg.png" alt></p><h4 id="38-外观数列-力扣（LeetCode）"><a href="#38-外观数列-力扣（LeetCode）" class="headerlink" title="38. 外观数列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/count-and-say/submissions/" target="_blank" rel="noopener">38. 外观数列 - 力扣（LeetCode）</a></h4><p>给定一个正整数 n ，输出外观数列的第 n 项。</p><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p><p>你可以将其视作是由递归公式定义的数字字符串序列：</p><p>countAndSay(1) = “1”<br>countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">前五项如下：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>     <span class="number">1</span></span><br><span class="line"><span class="number">2.</span>     <span class="number">11</span></span><br><span class="line"><span class="number">3.</span>     <span class="number">21</span></span><br><span class="line"><span class="number">4.</span>     <span class="number">1211</span></span><br><span class="line"><span class="number">5.</span>     <span class="number">111221</span></span><br><span class="line">第一项是数字 <span class="number">1</span> </span><br><span class="line">描述前一项，这个数是 <span class="number">1</span> 即 “ 一 个 <span class="number">1</span> ”，记作 <span class="string">"11"</span></span><br><span class="line">描述前一项，这个数是 <span class="number">11</span> 即 “ 二 个 <span class="number">1</span> ” ，记作 <span class="string">"21"</span></span><br><span class="line">描述前一项，这个数是 <span class="number">21</span> 即 “ 一 个 <span class="number">2</span> + 一 个 <span class="number">1</span> ” ，记作 <span class="string">"1211"</span></span><br><span class="line">描述前一项，这个数是 <span class="number">1211</span> 即 “ 一 个 <span class="number">1</span> + 一 个 <span class="number">2</span> + 二 个 <span class="number">1</span> ” ，记作 <span class="string">"111221"</span></span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"1"</span></span><br><span class="line">解释：这是一个基本样例。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="string">"1211"</span></span><br><span class="line">解释：</span><br><span class="line"><span class="function"><span class="title">countAndSay</span><span class="params">(<span class="number">1</span>)</span></span> = <span class="string">"1"</span></span><br><span class="line"><span class="function"><span class="title">countAndSay</span><span class="params">(<span class="number">2</span>)</span></span> = 读 <span class="string">"1"</span> = 一 个 <span class="number">1</span> = <span class="string">"11"</span></span><br><span class="line"><span class="function"><span class="title">countAndSay</span><span class="params">(<span class="number">3</span>)</span></span> = 读 <span class="string">"11"</span> = 二 个 <span class="number">1</span> = <span class="string">"21"</span></span><br><span class="line"><span class="function"><span class="title">countAndSay</span><span class="params">(<span class="number">4</span>)</span></span> = 读 <span class="string">"21"</span> = 一 个 <span class="number">2</span> + 一 个 <span class="number">1</span> = <span class="string">"12"</span> + <span class="string">"11"</span> = <span class="string">"1211"</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>递归，模拟，用c表示当前的字符，用count存当前字符出现的次数，当当前的字符与前面一个不一样时，将c和count存到ans中，并更新这两个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line">        res = list(self.countAndSay(n - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        ans = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(res)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                c, count = res[i], <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> res[i] == res[i - <span class="number">1</span>]:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans = ans + str(count) + c</span><br><span class="line">                    c, count = res[i], <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans + str(count) + c</span><br></pre></td></tr></table></figure><h4 id="39-组合总和-力扣（LeetCode）"><a href="#39-组合总和-力扣（LeetCode）" class="headerlink" title="39. 组合总和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和 - 力扣（LeetCode）</a></h4><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">7</span></span><br><span class="line">输出：[[<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">7</span>]]</span><br><span class="line">解释：</span><br><span class="line"><span class="number">2</span> 和 <span class="number">3</span> 可以形成一组候选，<span class="number">2</span> + <span class="number">2</span> + <span class="number">3</span> = <span class="number">7</span> 。注意 <span class="number">2</span> 可以使用多次。</span><br><span class="line"><span class="number">7</span> 也是一个候选， <span class="number">7</span> = <span class="number">7</span> 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = <span class="comment">[2,3,5]</span>, target = 8</span><br><span class="line">输出: <span class="comment">[<span class="comment">[2,2,2,2]</span>,<span class="comment">[2,3,3]</span>,<span class="comment">[3,5]</span>]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = <span class="string">[2]</span>, target = <span class="number">1</span></span><br><span class="line">输出: <span class="string">[]</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>基本的回溯，没有剪枝的思路如下：</p><p>画一个二叉树，对于数组中的每一个元素，有两种状态，一种是path里面包含它，一种是path里面不包含。</p><p>所以用两个dfs来回溯搜索。</p><p>回溯函数包含三个参数，一个是当前的path，一个是当前剩余的target，还一个表示当前指向的值的下标index</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(path, target, index)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> index &gt;= len(candidates):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                res.append(list(path))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            dfs(path, target, index + <span class="number">1</span>)  <span class="comment"># path 里面不包含当前index</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> target - candidates[index] &gt;= <span class="number">0</span>:  <span class="comment"># path 里面能包含当前index</span></span><br><span class="line">                path.append(candidates[index])</span><br><span class="line">                dfs(path, target - candidates[index], index)</span><br><span class="line">                path.pop()  <span class="comment"># 将当前的index的值移除</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        path = []</span><br><span class="line"></span><br><span class="line">        dfs(path, target, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><em>方法二</em></p><p>还有一种回溯的方法：</p><p>先对数组进行排序，然后循环数组，对每个数我都减去当前的值，然后继续dfs。这就不是二叉树了，自己画一遍。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(path, target, index)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                res.append(list(path))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, len(candidates)):</span><br><span class="line">                <span class="keyword">if</span> candidates[i] &gt; target: <span class="keyword">break</span></span><br><span class="line">                path.append(candidates[i])</span><br><span class="line">                dfs(path, target - candidates[i], i)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        path = []</span><br><span class="line"></span><br><span class="line">        candidates.sort()</span><br><span class="line">        dfs(path, target, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="40-组合总和-II-力扣（LeetCode）"><a href="#40-组合总和-II-力扣（LeetCode）" class="headerlink" title="40. 组合总和 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II - 力扣（LeetCode）</a></h4><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用 一次 。</p><p>注意：解集不能包含重复的组合。 </p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = <span class="comment">[10,1,2,7,6,1,5]</span>, target = 8,</span><br><span class="line">输出:</span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment"><span class="comment">[1,1,6]</span>,</span></span><br><span class="line"><span class="comment"><span class="comment">[1,2,5]</span>,</span></span><br><span class="line"><span class="comment"><span class="comment">[1,7]</span>,</span></span><br><span class="line"><span class="comment"><span class="comment">[2,6]</span></span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = <span class="comment">[2,5,2,1,2]</span>, target = 5,</span><br><span class="line">输出:</span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment"><span class="comment">[1,2,2]</span>,</span></span><br><span class="line"><span class="comment"><span class="comment">[5]</span></span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><p>跟上一题的思路是一样的，只不过这里的每个元素不能重复，循环的时候每次将这个数减掉之后要下标要加1，并且有一个set存下面当前加入了哪些数，然后后面再进来这些数的时候直接跳过。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(path, target, index)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                res.append(list(path))</span><br><span class="line"></span><br><span class="line">            flag = set()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, len(candidates)):</span><br><span class="line">                <span class="keyword">if</span> candidates[i] <span class="keyword">in</span> flag: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> target &lt; candidates[i]: <span class="keyword">break</span></span><br><span class="line">                flag.add(candidates[i])</span><br><span class="line">                path.append(candidates[i])</span><br><span class="line">                dfs(path, target - candidates[i], i + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">        </span><br><span class="line">        res, path = [], []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        dfs(path, target, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="hard-41-缺失的第一个正数-力扣（LeetCode）"><a href="#hard-41-缺失的第一个正数-力扣（LeetCode）" class="headerlink" title="(hard) 41. 缺失的第一个正数 - 力扣（LeetCode）"></a>(hard) <a href="https://leetcode.cn/problems/first-missing-positive/" target="_blank" rel="noopener">41. 缺失的第一个正数 - 力扣（LeetCode）</a></h4><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为O(n)并且只使用常数级别额外空间的解决方案。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p><strong>原地哈希</strong></p><p>假设数组的长度为N，则最小的正整数只可能在[1, N+1]里面，</p><p>所以考虑原地哈希的方式，我们将所有的nums[i]存到下标i-1的位置，意思就是使得nums的前0到N个元素都放的是对应下标加1的数，如i下标放的数为i+1，即nums[i] = i + 1。</p><p>所以我们遍历数组的0到N，然后循环，将i下标的值放i+1的数，即如果 i - 1的值不等于nums[i]，那么每次把当前的数放到对应的下标下面，即num[i] 放到 nums[nums[i] - 1] 下面，就是交换他们两个的值，然后继续判断，使得 每一项的值比它的下标多1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums)</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">while</span> <span class="number">1</span> &lt;= nums[i] &lt;= n <span class="keyword">and</span> nums[i] != nums[nums[i] - <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># nums[i], nums[nums[i] - 1] = nums[nums[i] - 1], nums[i]  # 报错</span></span><br><span class="line">                nums[nums[i] - <span class="number">1</span>], nums[i] = nums[i], nums[nums[i] - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> != nums[i]:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="42-接雨水-力扣（LeetCode）"><a href="#42-接雨水-力扣（LeetCode）" class="headerlink" title="42. 接雨水 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水 - 力扣（LeetCode）</a></h4><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 </p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：上面是由数组 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 表示的高度图，在这种情况下，可以接 <span class="number">6</span> 个单位的雨水（蓝色部分表示雨水）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><p><strong>思路</strong></p><p>双指针，维护两个指针，max_left和max_right，里面分别存的是从左到右和从右到左的最大的左边界和右边界。</p><p>然后双指针left和right分别向中间移动，当那边的高度较小时进行操作，如果当前的高度比保存的max大，那么更新max，否则用max减去当前的高度就为当前位置能够接的雨水数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        left, right = <span class="number">0</span>, len(height) - <span class="number">1</span></span><br><span class="line">        max_left, max_right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> height[left] &lt;= height[right]:</span><br><span class="line">                <span class="keyword">if</span> height[left] &gt;= max_left:</span><br><span class="line">                    max_left = height[left]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += max_left - height[left]</span><br><span class="line">                </span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> height[right] &gt;= max_right:</span><br><span class="line">                    max_right = height[right]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += max_right - height[right]</span><br><span class="line"></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>dp</strong></p><p>dp也能做，分别用两个dp数组保存从左到右和从右到左的当前位置的最高的高度。然后在从左到右循环，每次通过dp数组找到当前位置的左最高和右最高取最小减去当前位置的高度就为当前位置能够接的雨水。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        n = len(height)</span><br><span class="line">        dp_left, dp_right = [<span class="number">0</span>] * n, [<span class="number">0</span>] * n</span><br><span class="line">        dp_left[<span class="number">0</span>] = height[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp_left[i] = max(dp_left[i - <span class="number">1</span>], height[i])</span><br><span class="line">        dp_right[n - <span class="number">1</span>] = height[n - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp_right[i] = max(dp_right[i + <span class="number">1</span>], height[i])</span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">            res += min(dp_left[i], dp_right[i]) - height[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="43-字符串相乘-力扣（LeetCode）"><a href="#43-字符串相乘-力扣（LeetCode）" class="headerlink" title="43. 字符串相乘 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/multiply-strings/" target="_blank" rel="noopener">43. 字符串相乘 - 力扣（LeetCode）</a></h4><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p>注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p><p><strong>示例 1:</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="symbol">num1</span> = <span class="string">"2"</span>, <span class="symbol">num2</span> = <span class="string">"3"</span></span><br><span class="line">输出: <span class="string">"6"</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="symbol">num1</span> = <span class="string">"123"</span>, <span class="symbol">num2</span> = <span class="string">"456"</span></span><br><span class="line">输出: <span class="string">"56088"</span></span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= num1.length, num2.length &lt;= 200</li><li>num1 和 num2 只能由数字组成。</li><li>num1 和 num2 都不包含任何前导零，除了数字0本身</li></ul><p><strong>思路</strong></p><p>两个长度分为n和m的字符串长度相乘，其结果的长度m + n 或者 m + n - 1。</p><p>所以我们初始化一个结果的矩阵，然后逆序遍历两个字符数组，每次提取两个数进行相乘，并根据当前两个数的下标计算出结果的下标，然后做求余和取整分别存到对应的结果位中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, num1: str, num2: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> num1 == <span class="string">"0"</span> <span class="keyword">or</span> num2 == <span class="string">"0"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span></span><br><span class="line">        </span><br><span class="line">        res = [<span class="number">0</span>] * (len(num1) + len(num2))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num1) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(num2) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                temp = (ord(num1[i]) - ord(<span class="string">'0'</span>)) * (ord(num2[j]) - ord(<span class="string">'0'</span>)) + res[i + j + <span class="number">1</span>]</span><br><span class="line">                res[i + j + <span class="number">1</span>] = temp % <span class="number">10</span></span><br><span class="line">                res[i + j] += temp // <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(res)):</span><br><span class="line">            <span class="keyword">if</span> res[i]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(str(res[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(i, len(res)))</span><br></pre></td></tr></table></figure><h4 id="44-通配符匹配-力扣（LeetCode）"><a href="#44-通配符匹配-力扣（LeetCode）" class="headerlink" title="44. 通配符匹配 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/wildcard-matching/" target="_blank" rel="noopener">44. 通配符匹配 - 力扣（LeetCode）</a></h4><p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p><p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。</p><p>两个字符串完全匹配才算匹配成功。</p><p>说明:</p><p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入:</span></span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"*"</span></span><br><span class="line"><span class="section">输出: true</span></span><br><span class="line"><span class="section">解释: '*' 可以匹配任意字符串。</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入:</span></span><br><span class="line">s = <span class="string">"adceb"</span></span><br><span class="line">p = <span class="string">"ab"</span></span><br><span class="line"><span class="section">输出: true</span></span><br><span class="line"><span class="section">解释: 第一个 '' 可以匹配空字符串, 第二个 '' 可以匹配字符串 "dce".</span></span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入:</span></span><br><span class="line">s = <span class="string">"acdcb"</span></span><br><span class="line">p = <span class="string">"a*c?b"</span></span><br><span class="line"><span class="section">输出: false</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>dp数组定义：<code>dp[i][j]</code>表示p的前i个字符与s的前j个字符是否配对。</p><p>对p字符串进行考虑：</p><ol><li>当p[i]不为’*’时，说明当前的字符只能表示一个字符，即判断当前的s[j]与p[i]是否相同或者p[i]是否为’?’，若是，则<code>dp[i][j] = dp[i-1][j-1]</code>。</li><li>当p[i]为’*’时，说明当前的字符可以表示任意的字符或者不表示字符，当不表示字符串时，<code>dp[i][j] = dp[i - 1][j]</code>，当表示任意字符时，即表示去掉s中的当前字符，看当前的p是否与当前的s仍匹配，所以<code>dp[i][j] = dp[i][j - 1]</code>。这两种情况只要有一种为True，结果便为True。</li></ol><p>dp数组的长度为len(p) + 1 * len(s) + 1，所以需要考虑当s或者p为空字符串时候的初始化。</p><ol><li>当s和p都为空时， 是匹配的。True</li><li>当s不为空，p为空时，是不匹配的，False。</li><li>当s为空，p不为空时，这种情况是需要算出来的。因为p可能为’*’。</li><li>当s不为空，p不为空时，需要计算。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(p) + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(p) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = bool(j == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> p[i - <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                        dp[i][j] = dp[i][j] <span class="keyword">or</span> dp[i - <span class="number">1</span>][j]</span><br><span class="line">                        <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                            dp[i][j] = dp[i][j] <span class="keyword">or</span> dp[i][j - <span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> (s[j - <span class="number">1</span>] == p[i - <span class="number">1</span>] <span class="keyword">or</span> p[i - <span class="number">1</span>] == <span class="string">'?'</span>):</span><br><span class="line">                            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[len(p)][len(s)]</span><br></pre></td></tr></table></figure><h4 id="45-跳跃游戏-II-力扣（LeetCode）"><a href="#45-跳跃游戏-II-力扣（LeetCode）" class="headerlink" title="45. 跳跃游戏 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II - 力扣（LeetCode）</a></h4><p>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>假设你总是可以到达数组的最后一个位置。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为<span class="number"> 0 </span>跳到下标为<span class="number"> 1 </span>的位置，跳<span class="number"> 1 </span>步，然后跳<span class="number"> 3 </span>步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: nums = [2,3,0,1,4]</span></span><br><span class="line"><span class="section">输出: 2</span></span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><p><strong>思路</strong></p><p><strong>贪心策略</strong>，每次更新当前的能走的最远的边界，并保存上一个步数能走的最远的边界。然后如果说当前的位置已经走到上一个步数的边界，那么步数加一，并且更新下一步能走的最远的边界。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        max_far, step, end = <span class="number">0</span>, <span class="number">0</span> ,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">            max_far = max(max_far, i + nums[i])  <span class="comment"># 找到当前步数能走的最远的边界</span></span><br><span class="line">            <span class="keyword">if</span> i == end:  <span class="comment"># 如果已经走到了上一步最远的边界</span></span><br><span class="line">                step += <span class="number">1</span>  <span class="comment"># 步数加一，表示后面的位置都是下一步能走到的</span></span><br><span class="line">                end = max_far  <span class="comment"># 更新下一步能走的最远的边界</span></span><br><span class="line">        <span class="keyword">return</span> step</span><br></pre></td></tr></table></figure><h4 id="46-全排列-力扣（LeetCode）"><a href="#46-全排列-力扣（LeetCode）" class="headerlink" title="46. 全排列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/permutations/" target="_blank" rel="noopener">46. 全排列 - 力扣（LeetCode）</a></h4><p>给定一个不含重复数字的数组nums，返回其所有可能的全排列，你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>回溯法。回溯函数的参数为当前处理到的数字的下标。画一个树状图就能理解了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">trackback</span><span class="params">(path, index)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> index &gt;= len(nums):</span><br><span class="line">                res.append(list(path))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, len(nums)):</span><br><span class="line">                path[i], path[index] = path[index], path[i]</span><br><span class="line">                <span class="comment"># path[index], path[i] = path[i], path[index]</span></span><br><span class="line">                trackback(path, index + <span class="number">1</span>)</span><br><span class="line">                path[i], path[index] = path[index], path[i]</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        trackback(nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="47-全排列-II-力扣（LeetCode）"><a href="#47-全排列-II-力扣（LeetCode）" class="headerlink" title="47. 全排列 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II - 力扣（LeetCode）</a></h4><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em>按任意顺序</em> 返回所有不重复的全排列。 </p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：</span><br><span class="line">[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 8</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><p><strong>思路</strong></p><p>跟无重复的是类似的，只不过这里多了一个判重的过程，用一个set把访问过的元素存下面，然后每次再来元素的时候先判断set里面有没有考虑过，如果有，就跳过这次循环，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">trackback</span><span class="params">(index)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> index &gt;= len(nums):</span><br><span class="line">                res.append(list(nums))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            flag = set()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, len(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">in</span> flag: <span class="keyword">continue</span></span><br><span class="line">                flag.add(nums[i])</span><br><span class="line">                nums[i], nums[index] = nums[index], nums[i]</span><br><span class="line">                trackback(index + <span class="number">1</span>)</span><br><span class="line">                nums[i], nums[index] = nums[index], nums[i]</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># nums.sort()</span></span><br><span class="line">        trackback(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="48-旋转图像-力扣（LeetCode）"><a href="#48-旋转图像-力扣（LeetCode）" class="headerlink" title="48. 旋转图像 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/rotate-image/" target="_blank" rel="noopener">48. 旋转图像 - 力扣（LeetCode）</a></h4><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[[<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>],[<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>],[<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong> </p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">11</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">10</span>],[<span class="number">13</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">15</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">16</span>]]</span><br><span class="line">输出：[[<span class="number">15</span>,<span class="number">13</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">14</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>],[<span class="number">12</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">16</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>]]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>用翻转来代替旋转。</p><p>可以通过先上下翻转，即沿着水平轴翻转。然后再沿着主对角线翻转。就可以得到顺时针旋转90度的矩阵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        row, col = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row // <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">                matrix[row - i - <span class="number">1</span>][j], matrix[i][j] = matrix[i][j], matrix[row - i - <span class="number">1</span>][j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        n = len(matrix)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n // <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range((n + <span class="number">1</span>) // <span class="number">2</span>):</span><br><span class="line">                matrix[i][j], matrix[n - j - <span class="number">1</span>][i], matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>], matrix[j][n - i - <span class="number">1</span>] \</span><br><span class="line">                    = matrix[n - j - <span class="number">1</span>][i], matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>], matrix[j][n - i - <span class="number">1</span>], matrix[i][j]</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode.cn/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="49-字母异位词分组-力扣（LeetCode）"><a href="#49-字母异位词分组-力扣（LeetCode）" class="headerlink" title="49. 字母异位词分组 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/group-anagrams/" target="_blank" rel="noopener">49. 字母异位词分组 - 力扣（LeetCode）</a></h4><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p><p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [<span class="string">"eat"</span>, <span class="string">"tea"</span>, <span class="string">"tan"</span>, <span class="string">"ate"</span>, <span class="string">"nat"</span>, <span class="string">"bat"</span>]</span><br><span class="line">输出: [[<span class="string">"bat"</span>],[<span class="string">"nat"</span>,<span class="string">"tan"</span>],[<span class="string">"ate"</span>,<span class="string">"eat"</span>,<span class="string">"tea"</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [<span class="string">""</span>]</span><br><span class="line">输出: <span class="string">[[""]]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [<span class="string">"a"</span>]</span><br><span class="line">输出: <span class="string">[["a"]]</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>字典，因为字母异位词的所有字母出现的次数都是一样的，所以我们对他们重新排序之后的字符串都是一样的，所有我们可以把排序之后的字符串作为key，值为一个list，每次添加当前的原词到这个list中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        m = collections.defaultdict(list)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            m[<span class="string">""</span>.join(sorted(s))].append(s)</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> m.keys():</span><br><span class="line">            res.append(m[k])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>也可以统计26个字母每个字母出现的次数作为字典的keys。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        m = collections.defaultdict(list)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            count = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">                count[ord(c) - ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            m[tuple(count)].append(s)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list(m.values())</span><br></pre></td></tr></table></figure><h4 id="50-Pow-x-n-力扣（LeetCode）"><a href="#50-Pow-x-n-力扣（LeetCode）" class="headerlink" title="50. Pow(x, n) - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n) - 力扣（LeetCode）</a></h4><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a> ，即计算 <code>x</code> 的整数 <code>n</code> 次幂函数（即，<code>x^n</code> ）。 </p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">2.00000</span>, n = <span class="number">10</span></span><br><span class="line">输出：<span class="number">1024.00000</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">2.10000</span>, n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">9.26100</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">2.00000</span>, n = <span class="number">-2</span></span><br><span class="line">输出：<span class="number">0.25000</span></span><br><span class="line">解释：<span class="number">2</span><span class="number">-2</span> = <span class="number">1</span>/<span class="number">22</span> = <span class="number">1</span>/<span class="number">4</span> = <span class="number">0.25</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p><strong>快速幂</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        res, symbol = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            n, symbol = -n, <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                res = res * x</span><br><span class="line">            x *= x  <span class="comment"># 不知道为什么 x = x ** 2会报错，数据出界</span></span><br><span class="line">            n = n // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> symbol == <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span> / res</span><br></pre></td></tr></table></figure><h4 id="51-N-皇后-力扣（LeetCode）"><a href="#51-N-皇后-力扣（LeetCode）" class="headerlink" title="51. N 皇后 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/n-queens/" target="_blank" rel="noopener">51. N 皇后 - 力扣（LeetCode）</a></h4><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p><p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：[[<span class="string">".Q.."</span>,<span class="string">"...Q"</span>,<span class="string">"Q..."</span>,<span class="string">"..Q."</span>],[<span class="string">"..Q."</span>,<span class="string">"Q..."</span>,<span class="string">"...Q"</span>,<span class="string">".Q.."</span>]]</span><br><span class="line">解释：如上图所示，<span class="number">4</span> 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p><strong>完全自己写，一遍过</strong></p><p>回溯函数的参数：当前的放置方案以及要处理的下标(即二维里面的行数)</p><p>首先判断当前的下标是否已经超过了n，如果是，直接将当前的方案放置到res中，</p><p>如果不是，则对于index下标位置的放置方案，有0到n这几个位置可以放，然后判断</p><pre><code>判断当前要放入的数(即当前行放在第几列)在index之前是否已经出现过，如果出现过说明同列了并且判断当前的下标减去之前的下标的绝对值是否等于当前要放入的数与之前的对应的下标的绝对值是否相等，如果是，说明同一斜线了。</code></pre><p>然后都不满足，则说明当前的数可以放到当前的行，放入，然后讲index加1之后进行下一个位置的判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n: int)</span> -&gt; List[List[str]]:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">trackback</span><span class="params">(path, index)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> index &gt;= n:</span><br><span class="line">                res.append(list(path))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> judge(path, index, i):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path[index] = i</span><br><span class="line">                trackback(path, index + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">judge</span><span class="params">(path, index, i)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(index):</span><br><span class="line">                <span class="keyword">if</span> path[j] == i <span class="keyword">or</span> abs(index - j) == abs(i - path[j]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        res, path = [], [<span class="number">0</span>] * n</span><br><span class="line">        trackback(path, <span class="number">0</span>)</span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> arr <span class="keyword">in</span> res:</span><br><span class="line">            temp = [[<span class="string">'.'</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">                temp[i][arr[i]] = <span class="string">'Q'</span></span><br><span class="line">            temp = [<span class="string">""</span>.join(s) <span class="keyword">for</span> s <span class="keyword">in</span> temp]</span><br><span class="line">            ans.append(temp)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="52-N皇后-II-力扣（LeetCode）"><a href="#52-N皇后-II-力扣（LeetCode）" class="headerlink" title="52. N皇后 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/n-queens-ii/" target="_blank" rel="noopener">52. N皇后 II - 力扣（LeetCode）</a></h4><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：如上图所示，<span class="number">4</span> 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>跟上面的一样，需要注意的是，</p><p><strong>当全局变量是int或者str时，如果在函数体中想要对全局变量进行修改，必须先要在函数内，声明其为global，再进行修改。如果是list或者dict则可以直接修改</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalNQueens</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        res, path = [<span class="number">0</span>], [<span class="number">0</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">trackback</span><span class="params">(path, index)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> index &gt;= n:</span><br><span class="line">                res[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> judge(path, index, i):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path[index] = i</span><br><span class="line">                trackback(path, index + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">judge</span><span class="params">(path, index, i)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(index):</span><br><span class="line">                <span class="keyword">if</span> path[j] == i <span class="keyword">or</span> abs(index - j) == abs(i - path[j]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">             </span><br><span class="line">        trackback(path, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h4 id="53-最大子数组和-力扣（LeetCode）"><a href="#53-最大子数组和-力扣（LeetCode）" class="headerlink" title="53. 最大子数组和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子数组和 - 力扣（LeetCode）</a></h4><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：连续子数组 [<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">输出：<span class="number">23</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p><strong>一维dp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        temp, ans = nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            temp = max(temp + n, n)</span><br><span class="line">            ans = max(ans, temp)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="54-螺旋矩阵-力扣（LeetCode）"><a href="#54-螺旋矩阵-力扣（LeetCode）" class="headerlink" title="54. 螺旋矩阵 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/spiral-matrix/" target="_blank" rel="noopener">54. 螺旋矩阵 - 力扣（LeetCode）</a></h4><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。 </p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>两种方法：</p><p>第一种，每次取矩阵的第一行，然后逆时针旋转矩阵90度。直到矩阵为空</p><p>第二种，维护四个下标，上下左右，然后依次循环读取每个位置元素的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> matrix:</span><br><span class="line">            ans = ans + matrix.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            matrix = [[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>]) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="55-跳跃游戏-力扣（LeetCode）"><a href="#55-跳跃游戏-力扣（LeetCode）" class="headerlink" title="55. 跳跃游戏 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏 - 力扣（LeetCode）</a></h4><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 <span class="number">1</span> 步，从下标 <span class="number">0</span> 到达下标 <span class="number">1</span>, 然后再从下标 <span class="number">1</span> 跳 <span class="number">3</span> 步到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 <span class="number">3</span> 的位置。但该下标的最大跳跃长度是 <span class="number">0</span> ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>思路</strong></p><p>贪心：维护一个变量，表示每走一步当前能走的最远的位置。如果这个当前能走的最远的位置大于数组的长度，那就是能到达。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        n, maxtemp = len(nums), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            maxtemp = max(maxtemp, i + nums[i])</span><br><span class="line">            <span class="keyword">if</span> maxtemp &gt;= n - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= maxtemp:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="56-合并区间-力扣（LeetCode）"><a href="#56-合并区间-力扣（LeetCode）" class="headerlink" title="56. 合并区间 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间 - 力扣（LeetCode）</a></h4><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">解释：区间 [<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">6</span>] 重叠, 将它们合并为 [<span class="number">1</span>,<span class="number">6</span>].</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">5</span>]]</span><br><span class="line">解释：区间 [<span class="number">1</span>,<span class="number">4</span>] 和 [<span class="number">4</span>,<span class="number">5</span>] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= intervals.length &lt;= 10^4</li><li>intervals[i].length == 2</li><li>0 &lt;= starti &lt;= endi &lt;= 10^4</li></ul><p><strong>思路</strong></p><p>先对原数组按照每个矩阵的第一个元素从小到大排序，然后再判断后面一个的头是否比前面的一个尾小，从而判断是否能够合并。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line"></span><br><span class="line">        intervals.sort(key=(<span class="keyword">lambda</span> x: x[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">        ans = [list(intervals[<span class="number">0</span>])]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> arr <span class="keyword">in</span> intervals[<span class="number">1</span>:]:</span><br><span class="line">            <span class="comment"># print(arr)</span></span><br><span class="line">            <span class="keyword">if</span> arr[<span class="number">0</span>] &lt;= ans[<span class="number">-1</span>][<span class="number">1</span>]:</span><br><span class="line">                ans[<span class="number">-1</span>][<span class="number">1</span>] = max(arr[<span class="number">1</span>], ans[<span class="number">-1</span>][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(list(arr))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="57-插入区间-力扣（LeetCode）"><a href="#57-插入区间-力扣（LeetCode）" class="headerlink" title="57. 插入区间 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/insert-interval/" target="_blank" rel="noopener">57. 插入区间 - 力扣（LeetCode）</a></h4><p>给你一个 <strong>无重叠的</strong> <em>，</em>按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">6</span>,<span class="number">9</span>]], newInterval = [<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">9</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">12</span>,<span class="number">16</span>]], newInterval = [<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">10</span>],[<span class="number">12</span>,<span class="number">16</span>]]</span><br><span class="line">解释：这是因为新的区间 [<span class="number">4</span>,<span class="number">8</span>] 与 [<span class="number">3</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>],[<span class="number">8</span>,<span class="number">10</span>] 重叠。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [], newInterval = [<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="string">[[5,7]]</span></span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = <span class="string">[[1,5]]</span>, newInterval = [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="string">[[1,5]]</span></span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = <span class="string">[[1,5]]</span>, newInterval = [<span class="number">2</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="string">[[1,7]]</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>直接模拟。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        left, right = newInterval</span><br><span class="line">        placed = <span class="literal">False</span></span><br><span class="line">        ans = list()</span><br><span class="line">        <span class="keyword">for</span> li, ri <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> li &gt; right:</span><br><span class="line">                <span class="comment"># 在插入区间的右侧且无交集</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> placed:</span><br><span class="line">                    ans.append([left, right])</span><br><span class="line">                    placed = <span class="literal">True</span></span><br><span class="line">                ans.append([li, ri])</span><br><span class="line">            <span class="keyword">elif</span> ri &lt; left:</span><br><span class="line">                <span class="comment"># 在插入区间的左侧且无交集</span></span><br><span class="line">                ans.append([li, ri])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 与插入区间有交集，计算它们的并集</span></span><br><span class="line">                left = min(left, li)</span><br><span class="line">                right = max(right, ri)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> placed:</span><br><span class="line">            ans.append([left, right])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="58-最后一个单词的长度-力扣（LeetCode）"><a href="#58-最后一个单词的长度-力扣（LeetCode）" class="headerlink" title="58. 最后一个单词的长度 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/length-of-last-word/" target="_blank" rel="noopener">58. 最后一个单词的长度 - 力扣（LeetCode）</a></h4><p>给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。</p><p>单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"Hello World"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：最后一个单词是“World”，长度为<span class="number">5</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"   fly me   to   the moon  "</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最后一个单词是“moon”，长度为<span class="number">4</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"luffy is still joyboy"</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：最后一个单词是长度为<span class="number">6</span>的“joyboy”。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> len(s.strip().split(<span class="string">' '</span>)[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h4 id="59-螺旋矩阵-II-力扣（LeetCode）"><a href="#59-螺旋矩阵-II-力扣（LeetCode）" class="headerlink" title="59. 螺旋矩阵 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/" target="_blank" rel="noopener">59. 螺旋矩阵 II - 力扣（LeetCode）</a></h4><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。 </p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt>\</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[[1]]</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>跟顺时针打印矩阵一样的，同样定义上下左右四个变量维护现在访问的是哪个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span><span class="params">(self, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        ans, temp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)], <span class="number">1</span></span><br><span class="line">        top, bottom, left, right = <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(left, right + <span class="number">1</span>):</span><br><span class="line">                ans[top][i] = temp</span><br><span class="line">                temp += <span class="number">1</span></span><br><span class="line">            top += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> top &gt; bottom: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(top, bottom + <span class="number">1</span>):</span><br><span class="line">                ans[i][right] = temp</span><br><span class="line">                temp += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(right, left - <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">                ans[bottom][i] = temp</span><br><span class="line">                temp += <span class="number">1</span></span><br><span class="line">            bottom -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> top &gt; bottom: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(bottom, top - <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">                ans[i][left] = temp</span><br><span class="line">                temp += <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="hard-60-排列序列-力扣（LeetCode）"><a href="#hard-60-排列序列-力扣（LeetCode）" class="headerlink" title="(hard)60. 排列序列 - 力扣（LeetCode）"></a>(hard)<a href="https://leetcode.cn/problems/permutation-sequence/" target="_blank" rel="noopener">60. 排列序列 - 力扣（LeetCode）</a></h4><p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p><p>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>给定 n 和 k，返回第 k 个排列。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">"213"</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, k = <span class="number">9</span></span><br><span class="line">输出：<span class="string">"2314"</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p><a href="https://leetcode.cn/problems/permutation-sequence/solution/di-kge-pai-lie-by-leetcode-solution/" target="_blank" rel="noopener">第k个排列 - 排列序列 - 力扣（LeetCode）</a> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        factorial = [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            factorial.append(factorial[<span class="number">-1</span>] * i)</span><br><span class="line">        </span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">        ans = list()</span><br><span class="line">        valid = [<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            order = k // factorial[n - i] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                order -= valid[j]</span><br><span class="line">                <span class="keyword">if</span> order == <span class="number">0</span>:</span><br><span class="line">                    ans.append(str(j))</span><br><span class="line">                    valid[j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            k %= factorial[n - i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(ans)</span><br></pre></td></tr></table></figure><h4 id="61-旋转链表-力扣（LeetCode）"><a href="#61-旋转链表-力扣（LeetCode）" class="headerlink" title="61. 旋转链表 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/rotate-list/" target="_blank" rel="noopener">61. 旋转链表 - 力扣（LeetCode）</a></h4><p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置。 </p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], k = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>其实就是找链表的倒数第k个元素，然后把倒数第k个元素作为头，原链表的尾连接原链表的头。</p><p>先统计链表的长度，然后将k与链表的长度取余。然后找到链表的倒数第k个节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head: Optional[ListNode], k: int)</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        last, count = head, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> last.next:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            last = last.next</span><br><span class="line">        </span><br><span class="line">        left, right, k = head, head, k % count</span><br><span class="line">        <span class="keyword">while</span> k:</span><br><span class="line">            right = right.next</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right.next:</span><br><span class="line">            left = left.next</span><br><span class="line">            right = right.next</span><br><span class="line">        right.next = head</span><br><span class="line">        head = left.next</span><br><span class="line">        left.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h4 id="62-不同路径-力扣（LeetCode）"><a href="#62-不同路径-力扣（LeetCode）" class="headerlink" title="62. 不同路径 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径 - 力扣（LeetCode）</a></h4><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, n = <span class="number">7</span></span><br><span class="line">输出：<span class="number">28</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>看起来想回溯，其实是二维dp，因为没有说要输出路径，所以每次就只要把当前点的上面的所有方法和左边的所有方法加起来就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="comment"># dp = [[1] * n] + [[1] + [0] * (n - 1) for _ in range(m - 1)]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="63-不同路径-II-力扣（LeetCode）"><a href="#63-不同路径-II-力扣（LeetCode）" class="headerlink" title="63. 不同路径 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II - 力扣（LeetCode）</a></h4><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">3</span>x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 <span class="number">2</span> 条不同的路径：</span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>二维dp，只是加了一个判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        m, n = len(obstacleGrid), len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">1</span>] * n] + [[<span class="number">1</span>] + [<span class="number">0</span>] * (n - <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m - <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> obstacleGrid[i][j]:</span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = (dp[i - <span class="number">1</span>][j] <span class="keyword">if</span> <span class="keyword">not</span> obstacleGrid[i - <span class="number">1</span>][j] <span class="keyword">else</span> <span class="number">0</span>) + \</span><br><span class="line">                                    (dp[i][j - <span class="number">1</span>] <span class="keyword">if</span> <span class="keyword">not</span> obstacleGrid[i][j - <span class="number">1</span>] <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="64-最小路径和-力扣（LeetCode）"><a href="#64-最小路径和-力扣（LeetCode）" class="headerlink" title="64. 最小路径和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和 - 力扣（LeetCode）</a></h4><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：因为路径 <span class="number">1</span>→<span class="number">3</span>→<span class="number">1</span>→<span class="number">1</span>→<span class="number">1</span> 的总和最小。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">输出：<span class="number">12</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>二维dp，每次判断左边和上边的最小值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">                    grid[i][j] += grid[i][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                    grid[i][j] += grid[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    grid[i][j] += min(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="hard-65-有效数字-力扣（LeetCode）"><a href="#hard-65-有效数字-力扣（LeetCode）" class="headerlink" title="(hard) 65. 有效数字 - 力扣（LeetCode）"></a>(hard) <a href="https://leetcode.cn/problems/valid-number/" target="_blank" rel="noopener">65. 有效数字 - 力扣（LeetCode）</a></h4><p>有效数字（按顺序）可以分成以下几个部分：</p><p>一个 小数 或者 整数<br>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数<br>小数（按顺序）可以分成以下几个部分：</p><p>（可选）一个符号字符（’+’ 或 ‘-‘）<br>下述格式之一：<br>至少一位数字，后面跟着一个点 ‘.’<br>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字<br>一个点 ‘.’ ，后面跟着至少一位数字<br>整数（按顺序）可以分成以下几个部分：</p><p>（可选）一个符号字符（’+’ 或 ‘-‘）<br>至少一位数字<br>部分有效数字列举如下：[“2”, “0089”, “-0.1”, “+3.14”, “4.”, “-.9”, “2e10”, “-90E3”, “3e+7”, “+6e-1”, “53.5e93”, “-123.456e789”]</p><p>部分无效数字列举如下：[“abc”, “1a”, “1e”, “e3”, “99e2.5”, “–6”, “-+3”, “95a54e53”]</p><p>给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"0"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"e"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"."</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>&#39;+&#39;</code> ，减号 <code>&#39;-&#39;</code> ，或者点 <code>&#39;.&#39;</code> 。</li></ul><p><strong>思路</strong></p><p>自动状态机：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        s = s.strip()  <span class="comment"># 去掉首尾空格</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> len(s) == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 判断是否为空</span></span><br><span class="line">        <span class="comment"># 标记是否遇到数字， 小数点，e或者E</span></span><br><span class="line">        isNum, isDot, iseorE = <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'0'</span> &lt;= c &lt;= <span class="string">'9'</span>: isNum = <span class="literal">True</span>  <span class="comment"># 遇到数字，标记遇到数字</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'.'</span>:</span><br><span class="line">                <span class="keyword">if</span> isDot <span class="keyword">or</span> iseorE: <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 判断是否已经遇到小数点，或者是小数点是在e和E之后</span></span><br><span class="line">                isDot = <span class="literal">True</span>  <span class="comment"># 标记已经遇到小数点</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'e'</span> <span class="keyword">or</span> c == <span class="string">'E'</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> isNum <span class="keyword">or</span> iseorE: <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 判断在e和E之前是否遇到了数字或者已经遇到了e和E</span></span><br><span class="line">                iseorE = <span class="literal">True</span>  <span class="comment"># 标记已经遇到了数字</span></span><br><span class="line">                isNum = <span class="literal">False</span>  <span class="comment"># 将数字置为False表示e和E后面要再次遇到数字</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'-'</span> <span class="keyword">or</span> c == <span class="string">'+'</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> (i == <span class="number">0</span> <span class="keyword">or</span> s[i<span class="number">-1</span>] == <span class="string">'e'</span> <span class="keyword">or</span> s[i<span class="number">-1</span>] == <span class="string">'E'</span>): <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 判断正负号是否出现在最前面或者e和E的后面一位</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 遇到非法字符返回False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isNum  <span class="comment"># 最后返回e和E后面是否出现数字。</span></span><br></pre></td></tr></table></figure><h4 id="66-加一-力扣（LeetCode）"><a href="#66-加一-力扣（LeetCode）" class="headerlink" title="66. 加一 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/plus-one/" target="_blank" rel="noopener">66. 加一 - 力扣（LeetCode）</a></h4><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">解释：输入数组表示数字 <span class="number">123</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">解释：输入数组表示数字 <span class="number">4321</span>。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>将数组转化字符串，将字符串转化为数字，加一之后，再转化为字符串，在转化为数组。</p><p>也可以从数组后面向前面遍历，每次判断当前是否大于9，如果是对10去余，并进位1，如果是第一个元素，就设置一个进位标志表示第一位是否有进位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">return</span> list(map(int, str(int(<span class="string">''</span>.join(list(map(str, digits)))) + <span class="number">1</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        jinwei = <span class="number">0</span></span><br><span class="line">        digits[<span class="number">-1</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(digits) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> digits[i] &gt; <span class="number">9</span>:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    jinwei = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    digits[i - <span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                digits[i] %= <span class="number">10</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> digits</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ([<span class="number">1</span>] <span class="keyword">if</span> jinwei <span class="keyword">else</span> []) + digits</span><br></pre></td></tr></table></figure><h4 id="67-二进制求和-力扣（LeetCode）"><a href="#67-二进制求和-力扣（LeetCode）" class="headerlink" title="67. 二进制求和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/add-binary/" target="_blank" rel="noopener">67. 二进制求和 - 力扣（LeetCode）</a></h4><p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p><p>输入为 <strong>非空</strong> 字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p><p> <strong>示例 1:</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="selector-tag">a</span> = <span class="string">"11"</span>, <span class="selector-tag">b</span> = <span class="string">"1"</span></span><br><span class="line">输出: <span class="string">"100"</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="selector-tag">a</span> = <span class="string">"1010"</span>, <span class="selector-tag">b</span> = <span class="string">"1011"</span></span><br><span class="line">输出: <span class="string">"10101"</span></span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。</li><li>1 &lt;= a.length, b.length &lt;= 10^4</li><li>字符串如果不是 “0” ，就都不含前导零。</li></ul><p><strong>思路</strong></p><p>模拟，从两个字符串的最后面向前面遍历，同时维护一个变量表示下面上来的进位，然后与当前的两个数相加，将结果加到ans数组中，然后判断是否有进位，最后倒序输出数组字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, a: str, b: str)</span> -&gt; str:</span></span><br><span class="line">        ans, carry = [], <span class="number">0</span></span><br><span class="line">        n, na, nb = max(len(a), len(b)), len(a), len(b)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            carry += (int(a[na - <span class="number">1</span> - i]) <span class="keyword">if</span> i &lt;= na - <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span>) + (int(b[nb - <span class="number">1</span> - i]) <span class="keyword">if</span> i &lt;= nb - <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">            ans.append(carry % <span class="number">2</span>)</span><br><span class="line">            carry //= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> carry: ans.append(carry)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(str(c) <span class="keyword">for</span> c <span class="keyword">in</span> ans[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><p>还有一个思路？</p><p>只有当二进制字符串的两个都为1时才会有进位1，所以，我们每次异或当前位的数，然后再将当前的数相与，异或得到的结果就是当前位要留下的值，然后与的结果就是表示当前位要进位的值，将与的结果左移一位，然后在于之前异或的结果再相加。直到于之后的结果都为0，表示没有进位，这个时候直接输出异或之后的结果就行。</p><h4 id="hard-68-文本左右对齐-力扣（LeetCode）"><a href="#hard-68-文本左右对齐-力扣（LeetCode）" class="headerlink" title="(hard) 68. 文本左右对齐 - 力扣（LeetCode）"></a>(hard) <a href="https://leetcode.cn/problems/text-justification/" target="_blank" rel="noopener">68. 文本左右对齐 - 力扣（LeetCode）</a></h4><p>给定一个单词数组 words 和一个长度 maxWidth ，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。</p><p>你应该使用 “贪心算法” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ‘ ‘ 填充，使得每行恰好有 maxWidth 个字符。</p><p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p><p>文本的最后一行应为左对齐，且单词之间不插入额外的空格。</p><p>注意:</p><ul><li>单词是指由非空格字符组成的字符序列。</li><li>每个单词的长度大于 0，小于等于 maxWidth。</li><li>输入单词数组 words 至少包含一个单词。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">words</span> = [<span class="string">"This"</span>, <span class="string">"is"</span>, <span class="string">"an"</span>, <span class="string">"example"</span>, <span class="string">"of"</span>, <span class="string">"text"</span>, <span class="string">"justification."</span>], <span class="attr">maxWidth</span> = <span class="number">16</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">   <span class="string">"This    is    an"</span>,</span><br><span class="line">   <span class="string">"example  of text"</span>,</span><br><span class="line">   <span class="string">"justification.  "</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:<span class="attr">words</span> = [<span class="string">"What"</span>,<span class="string">"must"</span>,<span class="string">"be"</span>,<span class="string">"acknowledgment"</span>,<span class="string">"shall"</span>,<span class="string">"be"</span>], <span class="attr">maxWidth</span> = <span class="number">16</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  <span class="string">"What   must   be"</span>,</span><br><span class="line">  <span class="string">"acknowledgment  "</span>,</span><br><span class="line">  <span class="string">"shall be        "</span></span><br><span class="line">]</span><br><span class="line">解释: 注意最后一行的格式应为 <span class="string">"shall be    "</span> 而不是 <span class="string">"shall     be"</span>,</span><br><span class="line">     因为最后一行应为左对齐，而不是左右两端对齐。       </span><br><span class="line">     第二行同样为左对齐，这是因为这行只包含一个单词。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:words = [<span class="comment">"Science"</span>,<span class="comment">"is"</span>,<span class="comment">"what"</span>,<span class="comment">"we"</span>,<span class="comment">"understand"</span>,<span class="comment">"well"</span>,<span class="comment">"enough"</span>,<span class="comment">"to"</span>,<span class="comment">"explain"</span>,<span class="comment">"to"</span>,<span class="comment">"a"</span>,<span class="comment">"computer."</span>,<span class="comment">"Art"</span>,<span class="comment">"is"</span>,<span class="comment">"everything"</span>,<span class="comment">"else"</span>,<span class="comment">"we"</span>,<span class="comment">"do"</span>]，maxWidth = <span class="number">20</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  <span class="comment">"Science  is  what we"</span>,</span><br><span class="line">  <span class="comment">"understand      well"</span>,</span><br><span class="line">  <span class="comment">"enough to explain to"</span>,</span><br><span class="line">  <span class="comment">"a  computer.  Art is"</span>,</span><br><span class="line">  <span class="comment">"everything  else  we"</span>,</span><br><span class="line">  <span class="comment">"do                  "</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="69-x-的平方根-力扣（LeetCode）"><a href="#69-x-的平方根-力扣（LeetCode）" class="headerlink" title="69. x 的平方根 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/sqrtx/" target="_blank" rel="noopener">69. x 的平方根 - 力扣（LeetCode）</a></h4><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p><p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p><p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">8</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">8</span> 的算术平方根是 <span class="number">2.82842</span>..., 由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= x &lt;= 231 - 1</code></li></ul><p><strong>思路</strong></p><p>二分查找，每次查找中间值，然后计算其平方与x的大小。方法二：牛顿迭代法（没看）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        left, right = <span class="number">0</span>, x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> mid ** <span class="number">2</span> == x: <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> mid ** <span class="number">2</span> &lt; x: left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure><h4 id="70-爬楼梯-力扣（LeetCode）"><a href="#70-爬楼梯-力扣（LeetCode）" class="headerlink" title="70. 爬楼梯 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯 - 力扣（LeetCode）</a></h4><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span> <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span> <span class="number">2</span> 阶</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span> <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span> <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3.</span> <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>斐波拉契是个人都知道用dp，</p><p>通项公式为：</p><p>然后就可以直接根据通项公式求值了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>: <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            b, a = a + b, b</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> int(( ((<span class="number">1</span> + <span class="number">5</span> ** (<span class="number">0.5</span>)) / <span class="number">2</span>) ** (n + <span class="number">1</span>) - ((<span class="number">1</span> - <span class="number">5</span> ** (<span class="number">0.5</span>)) / <span class="number">2</span>) ** (n + <span class="number">1</span>) ) / (<span class="number">5</span> ** (<span class="number">0.5</span>)))</span><br></pre></td></tr></table></figure><h4 id="71-简化路径-力扣（LeetCode）"><a href="#71-简化路径-力扣（LeetCode）" class="headerlink" title="71. 简化路径 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/simplify-path/" target="_blank" rel="noopener">71. 简化路径 - 力扣（LeetCode）</a></h4><p>给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 ‘/‘ 开头），请你将其转化为更加简洁的规范路径。</p><p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，’//‘）都被视为单个斜杠 ‘/‘ 。 对于此问题，任何其他格式的点（例如，’…’）均被视为文件/目录名称。</p><p>请注意，返回的 规范路径 必须遵循下述格式：</p><p>始终以斜杠 ‘/‘ 开头。<br>两个目录名之间必须只有一个斜杠 ‘/‘ 。<br>最后一个目录名（如果存在）不能 以 ‘/‘ 结尾。<br>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 ‘.’ 或 ‘..’）。<br>返回简化后得到的 规范路径 。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">path</span> = <span class="string">"/home/"</span></span><br><span class="line">输出：<span class="string">"/home"</span></span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">path</span> = <span class="string">"/../"</span></span><br><span class="line">输出：<span class="string">"/"</span></span><br><span class="line">解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">path</span> = <span class="string">"/home//foo/"</span></span><br><span class="line">输出：<span class="string">"/home/foo"</span></span><br><span class="line">解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">path</span> = <span class="string">"/a/./b/../../c/"</span></span><br><span class="line">输出：<span class="string">"/c"</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>先按照’/‘分割字符串，然后遍历list，每次判断是否为..，如果是，将栈顶出栈，表示向上退一个目录，然后判断是否为空并且是否不为.，不为.表示为正常目录，将其入栈</p><p>输出的先是一个’/‘，然后后面将栈中的每个元素用’/‘连接成字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span><span class="params">(self, path: str)</span> -&gt; str:</span></span><br><span class="line">        names = path.split(<span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">            <span class="keyword">if</span> name == <span class="string">'..'</span>:</span><br><span class="line">                <span class="keyword">if</span> ans:</span><br><span class="line">                    ans.pop()</span><br><span class="line">            <span class="keyword">elif</span> name <span class="keyword">and</span> name != <span class="string">'.'</span>:</span><br><span class="line">                ans.append(name)</span><br><span class="line">        print(ans)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'/'</span> + <span class="string">'/'</span>.join(ans)</span><br></pre></td></tr></table></figure><h4 id="hard-72-编辑距离-力扣（LeetCode）"><a href="#hard-72-编辑距离-力扣（LeetCode）" class="headerlink" title="(hard) 72. 编辑距离 - 力扣（LeetCode）"></a>(hard) <a href="https://leetcode.cn/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离 - 力扣（LeetCode）</a></h4><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p><p><strong>示例 1：</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">"horse"</span>, word2 = <span class="string">"ros"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line"><span class="function"><span class="title">horse</span> -&gt;</span> rorse (将 <span class="string">'h'</span> 替换为 <span class="string">'r'</span>)</span><br><span class="line"><span class="function"><span class="title">rorse</span> -&gt;</span> rose (删除 <span class="string">'r'</span>)</span><br><span class="line"><span class="function"><span class="title">rose</span> -&gt;</span> ros (删除 <span class="string">'e'</span>)</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">"intention"</span>, word2 = <span class="string">"execution"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：</span><br><span class="line"><span class="function"><span class="title">intention</span> -&gt;</span> inention (删除 <span class="string">'t'</span>)</span><br><span class="line"><span class="function"><span class="title">inention</span> -&gt;</span> enention (将 <span class="string">'i'</span> 替换为 <span class="string">'e'</span>)</span><br><span class="line"><span class="function"><span class="title">enention</span> -&gt;</span> exention (将 <span class="string">'n'</span> 替换为 <span class="string">'x'</span>)</span><br><span class="line"><span class="function"><span class="title">exention</span> -&gt;</span> exection (将 <span class="string">'n'</span> 替换为 <span class="string">'c'</span>)</span><br><span class="line"><span class="function"><span class="title">exection</span> -&gt;</span> execution (插入 <span class="string">'u'</span>)</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>二维dp。</p><p>判断word1的第i个字符与word2的第j个字符是否相等，如果相等，则<code>dp[i][j] = dp[i - 1][j - 1]</code>。</p><p>如果不相等，有三种操作：</p><ul><li>将word1的第i个字符删除，<code>dp[i][j] = dp[i - 1][j]</code></li><li>将word2的第j个字符插入，<code>dp[i][j] = dp[i][j - 1]</code></li><li>将word1或者word2的某个字符进行替换，<code>dp[i][j] = dp[i - 1][j - 1]</code></li></ul><p>所有判断上面的最小值然后加1， 1表示当前要执行一次操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        m, n = len(word1), len(word2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> m <span class="keyword">or</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> max(m, n)</span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = j</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = <span class="number">1</span> + min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><h4 id="73-矩阵置零-力扣（LeetCode）"><a href="#73-矩阵置零-力扣（LeetCode）" class="headerlink" title="73. 矩阵置零 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/set-matrix-zeroes/submissions/" target="_blank" rel="noopener">73. 矩阵置零 - 力扣（LeetCode）</a></h4><p>给定一个 <code>*m* x *n*</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong>原地</strong> 算法<strong>。</strong></p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>先遍历一遍数组把元素为0的行和列存下来，然后在遍历一遍数组，判断当前的行或者列是否在存的set中，如果是，就置为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        row, col = set(), set()</span><br><span class="line">        m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> matrix[i][j]:</span><br><span class="line">                    row.add(i)</span><br><span class="line">                    col.add(j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> row <span class="keyword">or</span> j <span class="keyword">in</span> col:</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="74-搜索二维矩阵-力扣（LeetCode）"><a href="#74-搜索二维矩阵-力扣（LeetCode）" class="headerlink" title="74. 搜索二维矩阵 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/search-a-2d-matrix/" target="_blank" rel="noopener">74. 搜索二维矩阵 - 力扣（LeetCode）</a></h4><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">16</span>,<span class="number">20</span>],[<span class="number">23</span>,<span class="number">30</span>,<span class="number">34</span>,<span class="number">60</span>]], target = <span class="number">3</span></span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p> <strong>示例2</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">16</span>,<span class="number">20</span>],[<span class="number">23</span>,<span class="number">30</span>,<span class="number">34</span>,<span class="number">60</span>]], target = <span class="number">13</span></span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>两次二分，先根据每行的第一个元素或者每行的最后一个元素，找出在哪一行，然后再在这一行进行二分，找出是否存在这个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">        m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, m - <span class="number">1</span></span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[mid][<span class="number">0</span>] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[mid][<span class="number">0</span>] &gt; target:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        row = right</span><br><span class="line">        </span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[row][mid] == target: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[row][mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="75-颜色分类-力扣（LeetCode）"><a href="#75-颜色分类-力扣（LeetCode）" class="headerlink" title="75. 颜色分类 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/sort-colors/submissions/" target="_blank" rel="noopener">75. 颜色分类 - 力扣（LeetCode）</a></h4><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>必须在不使用库的sort函数的情况下解决这个问题。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>先遍历一遍数组，然后用三个变量存下来0,1,2分别有多少个数。然后在遍历一遍数组改数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = [<span class="number">0</span>] * <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            count[n] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(count[i]):</span><br><span class="line">                nums[index] = i</span><br><span class="line">                index += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>双指针</strong></p><p>该题目就是要将0放在前面，2放在后面，维护两个变量分别表示要交换的0的下标的和要交换的2的下标，分别从左到右和从右到左。然后i从左到右遍历，遇到0就与p0的下标交换并将p0++，遇到2就与p2交换并将p2–。注意p2与i交换并且p2–之后有可能p2还是2，所以得一直交换到p2不为2的时候。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        n = len(nums)</span><br><span class="line"></span><br><span class="line">        p0, p2 = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt;= p2:</span><br><span class="line">            <span class="keyword">while</span> i &lt;= p2 <span class="keyword">and</span> nums[i] == <span class="number">2</span>:</span><br><span class="line">                nums[i], nums[p2] = nums[p2], nums[i]</span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                nums[i], nums[p0] = nums[p0], nums[i]</span><br><span class="line">                p0 += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            i += <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="hard-76-最小覆盖子串-力扣（LeetCode）"><a href="#hard-76-最小覆盖子串-力扣（LeetCode）" class="headerlink" title="(hard) 76. 最小覆盖子串 - 力扣（LeetCode）"></a>(hard) <a href="https://leetcode.cn/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串 - 力扣（LeetCode）</a></h4><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。 </p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"ADOBECODEBANC"</span>, <span class="attr">t</span> = <span class="string">"ABC"</span></span><br><span class="line">输出：<span class="string">"BANC"</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="comment">"a"</span>, t = <span class="comment">"a"</span></span><br><span class="line">输出：<span class="comment">"a"</span></span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入<span class="symbol">:</span> s = <span class="string">"a"</span>, <span class="built_in">t</span> = <span class="string">"aa"</span></span><br><span class="line">输出<span class="symbol">:</span> <span class="string">""</span></span><br><span class="line">解释<span class="symbol">:</span> <span class="built_in">t</span> 中两个字符 'a' 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><p><strong>思路</strong></p><p>滑动窗口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, s: str, t: str)</span> -&gt; str:</span></span><br><span class="line">        sl, st = len(s), len(t)</span><br><span class="line"></span><br><span class="line">        count = [<span class="number">0</span>] * <span class="number">128</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">            count[ord(c)] -= <span class="number">1</span>  <span class="comment"># 初始化：表示有多少的坑要填</span></span><br><span class="line">        </span><br><span class="line">        left = cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        ans = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> range(sl):</span><br><span class="line">            count[ord(s[right])] += <span class="number">1</span>  <span class="comment"># 填坑</span></span><br><span class="line">            <span class="keyword">if</span> count[ord(s[right])] &lt;= <span class="number">0</span>: cnt += <span class="number">1</span>  <span class="comment"># 如果当前填完坑小于等于0，表示是有效坑，当cnt==st之后，cnt就不会变了</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> cnt == st <span class="keyword">and</span> count[ord(s[left])] &gt; <span class="number">0</span>:  <span class="comment"># 移动左边界</span></span><br><span class="line">                count[ord(s[left])] -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt == st <span class="keyword">and</span> (<span class="keyword">not</span> ans <span class="keyword">or</span> len(ans) &gt; right - left + <span class="number">1</span>):</span><br><span class="line">                ans = s[left:right + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="77-组合-力扣（LeetCode）"><a href="#77-组合-力扣（LeetCode）" class="headerlink" title="77. 组合 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/combinations/" target="_blank" rel="noopener">77. 组合 - 力扣（LeetCode）</a></h4><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, k = <span class="number">2</span></span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">4</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[[1]]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><p><strong>思路</strong></p><p>标准回溯问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n: int, k: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">trachback</span><span class="params">(index, path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(path) == k:</span><br><span class="line">                ans.append(list(path))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, n + <span class="number">1</span>):</span><br><span class="line">                path.append(i)</span><br><span class="line">                trachback(i + <span class="number">1</span>, path)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">        ans, path = [], []</span><br><span class="line">        trachback(<span class="number">1</span>, path)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="78-子集-力扣（LeetCode）"><a href="#78-子集-力扣（LeetCode）" class="headerlink" title="78. 子集 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/subsets/" target="_blank" rel="noopener">78. 子集 - 力扣（LeetCode）</a></h4><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[[],[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>]</span><br><span class="line">输出：<span class="string">[[],[0]]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul><p><strong>思路</strong></p><p>回溯</p><p>每次针对当前的数，有两种方案，选用当前的数和不选用当前的数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">trackback</span><span class="params">(index)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> index &gt;= len(nums):</span><br><span class="line">                ans.append(list(path))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            path.append(nums[index])</span><br><span class="line">            trackback(index + <span class="number">1</span>)</span><br><span class="line">            path.pop()</span><br><span class="line">            trackback(index + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        ans, path = [], []</span><br><span class="line">        trackback(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="79-单词搜索-力扣（LeetCode）"><a href="#79-单词搜索-力扣（LeetCode）" class="headerlink" title="79. 单词搜索 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/word-search/" target="_blank" rel="noopener">79. 单词搜索 - 力扣（LeetCode）</a></h4><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"E"</span>],[<span class="string">"S"</span>,<span class="string">"F"</span>,<span class="string">"C"</span>,<span class="string">"S"</span>],[<span class="string">"A"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>,<span class="string">"E"</span>]], word = <span class="string">"ABCCED"</span></span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" alt></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"E"</span>],[<span class="string">"S"</span>,<span class="string">"F"</span>,<span class="string">"C"</span>,<span class="string">"S"</span>],[<span class="string">"A"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>,<span class="string">"E"</span>]], word = <span class="string">"SEE"</span></span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>回溯，dfs。</p><p>遍历数组的每个元素，表示从数组的每个元素开始搜索。</p><p>回溯条件的结束条件是，index的长度为word的长度，返回True，然后判断当前回溯的上下标是否越界和当前的元素是否等于word的index下标的元素，若不满足，直接返回false。</p><p>否则标记当前的路径走过，然后判断上下左右四个方向，记得最后要取消标记。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        m, n = len(board), len(board[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">trackback</span><span class="params">(row, col, index)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> index &gt;= len(word): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># print(''.join(map(str, [row, col, index])))</span></span><br><span class="line">            <span class="keyword">if</span> row &gt;= m <span class="keyword">or</span> row &lt; <span class="number">0</span> <span class="keyword">or</span> col &gt;= n <span class="keyword">or</span> col &lt; <span class="number">0</span> <span class="keyword">or</span> board[row][col] == <span class="string">'0'</span> <span class="keyword">or</span> board[row][col] != word[index]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            board[row][col] = <span class="string">'0'</span></span><br><span class="line">            flag = trackback(row - <span class="number">1</span>, col, index + <span class="number">1</span>) <span class="keyword">or</span> trackback(row + <span class="number">1</span>, col, index + <span class="number">1</span>) <span class="keyword">or</span> \</span><br><span class="line">                    trackback(row, col - <span class="number">1</span>, index + <span class="number">1</span>) <span class="keyword">or</span> trackback(row, col + <span class="number">1</span>, index + <span class="number">1</span>)</span><br><span class="line">            board[row][col] = word[index]</span><br><span class="line">            <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> trackback(i, j, <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="80-删除有序数组中的重复项-II-力扣（LeetCode）"><a href="#80-删除有序数组中的重复项-II-力扣（LeetCode）" class="headerlink" title="80. 删除有序数组中的重复项 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="noopener">80. 删除有序数组中的重复项 II - 力扣（LeetCode）</a></h4><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>说明：</p><p>为什么返回数值是整数，但输出的答案是数组呢？</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">len</span> = removeDuplicates(nums);</span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">5</span>, nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：函数应返回新长度 length = <span class="number">5</span>, 并且原数组的前五个元素被修改为 <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span> 。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">7</span>, nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">解释：函数应返回新长度 length = <span class="number">7</span>, 并且原数组的前五个元素被修改为 <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span> 。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>保留k位：</p><ol><li>对于前面k个数字，直接保留</li><li>对于后面的任意数字，能够保留的前提是：与当前写入的位置前面的第k个元素进行比较，不相同则保留。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sovle</span><span class="params">(k)</span>:</span></span><br><span class="line">            u = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> u &lt; k <span class="keyword">or</span> nums[u - k] != n:</span><br><span class="line">                    nums[u] = n</span><br><span class="line">                    u += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> u</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> sovle(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="81-搜索旋转排序数组-II-力扣（LeetCode）"><a href="#81-搜索旋转排序数组-II-力扣（LeetCode）" class="headerlink" title="81. 搜索旋转排序数组 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II - 力扣（LeetCode）</a></h4><p>已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</p><p>你必须尽可能减少整个操作步骤。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">0</span></span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">3</span></span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 5000</li><li>-10^4 &lt;= nums[i] &lt;= 10^4</li><li>题目数据保证 nums 在预先未知的某个下标上进行了旋转</li><li>-10^4 &lt;= target &lt;= 10^4</li></ul><p><strong>思路</strong></p><p>和搜索螺旋旋转排序数组一样的，先找出mid哪边是有序的，然后在有序的那一部分判断大小，确定left和right边界。</p><p>但是由于有相同的元素，所有可能会出现<code>nums[left] == nums[mid] == nums[right]</code>的情况，这个时候只能将左边界加一，右边界减一，缩小查找区间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>] == target</span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> nums[left] == nums[mid] == nums[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[left] &lt;= nums[mid]:</span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="82-删除排序链表中的重复元素-II-力扣（LeetCode）"><a href="#82-删除排序链表中的重复元素-II-力扣（LeetCode）" class="headerlink" title="82. 删除排序链表中的重复元素 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">82. 删除排序链表中的重复元素 II - 力扣（LeetCode）</a></h4><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除原始链表中所有重复数字的节点，只留下不同的数字</em> 。返回 <em>已排序的链表</em> 。 </p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序 <strong>排列</strong></li></ul><p><strong>思路</strong></p><p>双指针，一个指针表示前面的一个节点，一个指针是向后遍历的表示要连接到前面指针的节点，判断：当当前节点的值等于下一个节点的值的时候说明当前的节点的值是重复的，所有把当前的这个指针遍历到没有重复的时候。然后继续判断当前的指针是否与后面你的指针的值相同。</p><p>注意最后，遍历结束之后，前面的pre指针需要指向空，不然还是会有后面的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: Optional[ListNode])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">        pre, cur = ListNode(<span class="number">0</span>), head</span><br><span class="line"></span><br><span class="line">        newhead = pre</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.next <span class="keyword">or</span> cur.val != cur.next.val:</span><br><span class="line">                pre.next = cur</span><br><span class="line">                pre, cur = cur, cur.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># print(cur.val)</span></span><br><span class="line">                <span class="keyword">while</span> cur.next <span class="keyword">and</span> cur.val == cur.next.val:</span><br><span class="line">                    cur = cur.next</span><br><span class="line">                cur = cur.next</span><br><span class="line">        </span><br><span class="line">        pre.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> newhead.next</span><br></pre></td></tr></table></figure><h4 id="83-删除排序链表中的重复元素-力扣（LeetCode）"><a href="#83-删除排序链表中的重复元素-力扣（LeetCode）" class="headerlink" title="83. 删除排序链表中的重复元素 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. 删除排序链表中的重复元素 - 力扣（LeetCode）</a></h4><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。 </p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序 <strong>排列</strong></li></ul><p><strong>思路</strong></p><p>双指针，跟数组去重一样，每次判断当前指针的值是够与pre的指针的值相同，若相同，cur向后遍历，直到不同，然后将cur连到pre后面，更新pre。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: Optional[ListNode])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">        pre, cur = head, head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur <span class="keyword">and</span> cur.val == pre.val:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            </span><br><span class="line">            pre.next = cur</span><br><span class="line">            pre = cur</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h4 id="hard-84-柱状图中最大的矩形-力扣（LeetCode）"><a href="#hard-84-柱状图中最大的矩形-力扣（LeetCode）" class="headerlink" title="(hard) 84. 柱状图中最大的矩形 - 力扣（LeetCode）"></a>(hard) <a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形 - 力扣（LeetCode）</a></h4><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p> <strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>每次针对当前的下标i，找到第一个高度小于当前高度的下标，然后计算面积，与之前的去最大。</p><p>所以维护一个单调栈，单调递增的，然后每次针对当前的高度height[i]，如果当前的高度大于栈顶，就把栈顶的元素出栈，并且计算一下面积取最大。直到栈顶的元素小于当前的高度，然后就把当前高度的下标入栈。注意是下标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">        stack, res = [], <span class="number">0</span></span><br><span class="line">        heights = [<span class="number">0</span>] + heights + [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[stack[<span class="number">-1</span>]] &gt; heights[i]:</span><br><span class="line">                temp = stack.pop()</span><br><span class="line">                res = max(res, (i - stack[<span class="number">-1</span>] - <span class="number">1</span>) * heights[temp])</span><br><span class="line">            stack.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="hard-85-最大矩形-力扣（LeetCode）"><a href="#hard-85-最大矩形-力扣（LeetCode）" class="headerlink" title="(hard) 85. 最大矩形 - 力扣（LeetCode）"></a>(hard) <a href="https://leetcode.cn/problems/maximal-rectangle/" target="_blank" rel="noopener">85. 最大矩形 - 力扣（LeetCode）</a></h4><p>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。 </p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg" alt></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>],[<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>],[<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>],[<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>]]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：最大矩形如上图所示。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = <span class="string">[["0","0"]]</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>会上一个的柱状图中的最大矩形之后，这个其实就是上一个的变形，每次统计当前行的每一列中1的高度。然后在用上一题的单调栈的方法。</p><p>可以在边统计高度的时候就开始算最大的矩形面积了，不用等到这一行的高度都统计完了在算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        heights = [<span class="number">0</span>] + [<span class="number">0</span>] * n + [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            stack = []  <span class="comment"># 初始化单调栈</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="number">1</span> &lt;= j &lt;= n:  <span class="comment"># 统计第i行，第j列的1的高度</span></span><br><span class="line">                    <span class="keyword">if</span> matrix[i][j - <span class="number">1</span>] == <span class="string">'1'</span>:</span><br><span class="line">                        heights[j] += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        heights[j] = <span class="number">0</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> heights[stack[<span class="number">-1</span>]] &gt; heights[j]:</span><br><span class="line">                    tmp = stack.pop()</span><br><span class="line">                    ans = max(ans, (j - stack[<span class="number">-1</span>] - <span class="number">1</span>) * heights[tmp])</span><br><span class="line">                stack.append(j)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="86-分隔链表-力扣（LeetCode）"><a href="#86-分隔链表-力扣（LeetCode）" class="headerlink" title="86. 分隔链表 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/partition-list/" target="_blank" rel="noopener">86. 分隔链表 - 力扣（LeetCode）</a></h4><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p><p>你应当 保留 两个分区中每个节点的初始相对位置。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/partition.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>], x = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">2</span>,<span class="number">1</span>], x = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>用两个头节点，分别是小数的头节点和大数的头节点，分别对应两个节点指针，然后遍历链表，判断链表当前节点的值，如果小于x，就接到小数节点的后面，如果大于x，就接到大数节点的后面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head: Optional[ListNode], x: int)</span> -&gt; Optional[ListNode]:</span></span><br><span class="line"></span><br><span class="line">        small = ListNode(<span class="number">-1</span>)</span><br><span class="line">        smallhead = small</span><br><span class="line"></span><br><span class="line">        large = ListNode(<span class="number">-1</span>)</span><br><span class="line">        largehead = large</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val &lt; x:</span><br><span class="line">                small.next = head</span><br><span class="line">                small = small.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                large.next = head</span><br><span class="line">                large = large.next</span><br><span class="line">            </span><br><span class="line">            head = head.next</span><br><span class="line">        </span><br><span class="line">        large.next = <span class="literal">None</span></span><br><span class="line">        small.next = largehead.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> smallhead.next</span><br></pre></td></tr></table></figure><h4 id="hard、没做-87-扰乱字符串-力扣（LeetCode）"><a href="#hard、没做-87-扰乱字符串-力扣（LeetCode）" class="headerlink" title="(hard、没做) 87. 扰乱字符串 - 力扣（LeetCode）"></a>(hard、没做) <a href="https://leetcode.cn/problems/scramble-string/" target="_blank" rel="noopener">87. 扰乱字符串 - 力扣（LeetCode）</a></h4><p>使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：<br>如果字符串的长度为 1 ，算法停止<br>如果字符串的长度 &gt; 1 ，执行下述步骤：<br>在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。<br>随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。<br>在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。<br>给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。</p><p><strong>示例 1：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = <span class="string">"great"</span>, s2 = <span class="string">"rgeat"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：s1 上可能发生的一种情形是：</span><br><span class="line"><span class="string">"great"</span> --&gt; <span class="string">"gr/eat"</span> <span class="comment">// 在一个随机下标处分割得到两个子字符串</span></span><br><span class="line"><span class="string">"gr/eat"</span> --&gt; <span class="string">"gr/eat"</span> <span class="comment">// 随机决定：「保持这两个子字符串的顺序不变」</span></span><br><span class="line"><span class="string">"gr/eat"</span> --&gt; <span class="string">"g/r / e/at"</span> <span class="comment">// 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割</span></span><br><span class="line"><span class="string">"g/r / e/at"</span> --&gt; <span class="string">"r/g / e/at"</span> <span class="comment">// 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」</span></span><br><span class="line"><span class="string">"r/g / e/at"</span> --&gt; <span class="string">"r/g / e/ a/t"</span> <span class="comment">// 继续递归执行此算法，将 "at" 分割得到 "a/t"</span></span><br><span class="line"><span class="string">"r/g / e/ a/t"</span> --&gt; <span class="string">"r/g / e/ a/t"</span> <span class="comment">// 随机决定：「保持这两个子字符串的顺序不变」</span></span><br><span class="line">算法终止，结果字符串和 s2 相同，都是 <span class="string">"rgeat"</span></span><br><span class="line">这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s1</span> = <span class="string">"abcde"</span>, <span class="attr">s2</span> = <span class="string">"caebd"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s1</span> = <span class="string">"a"</span>, <span class="attr">s2</span> = <span class="string">"a"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="88-合并两个有序数组-力扣（LeetCode）"><a href="#88-合并两个有序数组-力扣（LeetCode）" class="headerlink" title="88. 合并两个有序数组 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/merge-sorted-array/" target="_blank" rel="noopener">88. 合并两个有序数组 - 力扣（LeetCode）</a></h4><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span>, nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>], n = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">解释：需要合并 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>] 。</span><br><span class="line">合并结果是 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>] ，其中斜体加粗标注的为 nums1 中的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = <span class="string">[1]</span>, m = <span class="number">1</span>, nums2 = <span class="string">[]</span>, n = <span class="number">0</span></span><br><span class="line">输出：<span class="string">[1]</span></span><br><span class="line">解释：需要合并 <span class="string">[1]</span> 和 <span class="string">[]</span> 。</span><br><span class="line">合并结果是 <span class="string">[1]</span> 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">0</span>], m = <span class="number">0</span>, nums2 = [<span class="number">1</span>], n = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">1</span>]</span><br><span class="line">解释：需要合并的数组是 [] 和 [<span class="number">1</span>] 。</span><br><span class="line">合并结果是 [<span class="number">1</span>] 。</span><br><span class="line">注意，因为 m = <span class="number">0</span> ，所以 nums1 中没有元素。nums1 中仅存的 <span class="number">0</span> 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>直接合并数组然后排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums1[m:] = list(nums2)</span><br><span class="line">        nums1.sort()</span><br></pre></td></tr></table></figure><p>从大到小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m, n = m - <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums1) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> m &lt; <span class="number">0</span>:</span><br><span class="line">                nums1[i] = nums2[n]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> n &lt; <span class="number">0</span>:</span><br><span class="line">                nums1[i] = nums1[m]</span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums1[m] &gt;= nums2[n]:</span><br><span class="line">                    nums1[i] = nums1[m]</span><br><span class="line">                    m -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nums1[i] = nums2[n]</span><br><span class="line">                    n -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="89-格雷编码-力扣（LeetCode）"><a href="#89-格雷编码-力扣（LeetCode）" class="headerlink" title="89. 格雷编码 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/gray-code/" target="_blank" rel="noopener">89. 格雷编码 - 力扣（LeetCode）</a></h4><p>n 位格雷码序列 是一个由 2n 个整数组成的序列，其中：<br>每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1）<br>第一个整数是 0<br>一个整数在序列中出现 不超过一次<br>每对 相邻 整数的二进制表示 恰好一位不同 ，且<br>第一个 和 最后一个 整数的二进制表示 恰好一位不同<br>给你一个整数 n ，返回任一有效的 n 位格雷码序列 。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">解释：</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>] 的二进制表示是 [<span class="number">00</span>,<span class="number">01</span>,<span class="number">11</span>,<span class="number">10</span>] 。</span><br><span class="line">- <span class="number">00</span> 和 <span class="number">01</span> 有一位不同</span><br><span class="line">- <span class="number">01</span> 和 <span class="number">11</span> 有一位不同</span><br><span class="line">- <span class="number">11</span> 和 <span class="number">10</span> 有一位不同</span><br><span class="line">- <span class="number">10</span> 和 <span class="number">00</span> 有一位不同</span><br><span class="line">  [<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>] 也是一个有效的格雷码序列，其二进制表示是 [<span class="number">00</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">01</span>] 。</span><br><span class="line">- <span class="number">00</span> 和 <span class="number">10</span> 有一位不同</span><br><span class="line">- <span class="number">10</span> 和 <span class="number">11</span> 有一位不同</span><br><span class="line">- <span class="number">11</span> 和 <span class="number">01</span> 有一位不同</span><br><span class="line">- <span class="number">01</span> 和 <span class="number">00</span> 有一位不同</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 16</code></li></ul><p><strong>思路</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        ans = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(ans) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                ans.append(ans[j] | (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="90-子集-II-力扣（LeetCode）"><a href="#90-子集-II-力扣（LeetCode）" class="headerlink" title="90. 子集 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II - 力扣（LeetCode）</a></h4><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：[[],[<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>]</span><br><span class="line">输出：<span class="string">[[],[0]]</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>先对数组进行排序，然后在每次加入元素的时候判断这个数前面是否加入过了，即去重。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">trachback</span><span class="params">(index)</span>:</span></span><br><span class="line">            ans.append(list(path))</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, len(nums)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; index <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                trachback(i + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">            </span><br><span class="line">        ans, path = [], []</span><br><span class="line">        nums.sort()</span><br><span class="line">        trachback(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="91-解码方法-力扣（LeetCode）"><a href="#91-解码方法-力扣（LeetCode）" class="headerlink" title="91. 解码方法 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/decode-ways/" target="_blank" rel="noopener">91. 解码方法 - 力扣（LeetCode）</a></h4><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'A'</span> -&gt; <span class="string">"1"</span></span><br><span class="line"><span class="string">'B'</span> -&gt; <span class="string">"2"</span></span><br><span class="line">...</span><br><span class="line"><span class="string">'Z'</span> -&gt; <span class="string">"26"</span></span><br></pre></td></tr></table></figure><p>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p><p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p><p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p><p>题目数据保证答案肯定是一个 32 位 的整数。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"12"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：它可以解码为 <span class="string">"AB"</span>（<span class="number">1</span> <span class="number">2</span>）或者 <span class="string">"L"</span>（<span class="number">12</span>）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"226"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：它可以解码为 <span class="string">"BZ"</span> (<span class="number">2</span> <span class="number">26</span>), <span class="string">"VF"</span> (<span class="number">22</span> <span class="number">6</span>), 或者 <span class="string">"BBF"</span> (<span class="number">2</span> <span class="number">2</span> <span class="number">6</span>) 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"0"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有字符映射到以 <span class="number">0</span> 开头的数字。</span><br><span class="line">含有 <span class="number">0</span> 的有效映射是 <span class="string">'J'</span> -&gt; <span class="string">"10"</span> 和 <span class="string">'T'</span>-&gt; <span class="string">"20"</span> 。</span><br><span class="line">由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>dp，每次判断当前字符是否为0，然后再判断当前字符前面的字符是否为0并且是否可以与当前字符组合成小于26的数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">'0'</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">1</span>] +  [<span class="number">0</span>] * len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i - <span class="number">1</span>] != <span class="string">'0'</span>:</span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">1</span> <span class="keyword">and</span> s[i - <span class="number">2</span>] != <span class="string">'0'</span> <span class="keyword">and</span> int(s[(i<span class="number">-2</span>):i]) &lt;= <span class="number">26</span>:</span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[len(s)]</span><br></pre></td></tr></table></figure><h4 id="92-反转链表-II-力扣（LeetCode）"><a href="#92-反转链表-II-力扣（LeetCode）" class="headerlink" title="92. 反转链表 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表 II - 力扣（LeetCode）</a></h4><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], left = <span class="number">2</span>, right = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">5</span>], left = <span class="number">1</span>, right = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目为 <code>n</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>-500 &lt;= Node.val &lt;= 500</code></li><li><code>1 &lt;= left &lt;= right &lt;= n</code></li></ul><p><strong>思路</strong></p><p>这是哨兵节点，用哨兵节点指向头指针，然后用一个节点向后遍历，直到到left，然后记录下当前的前面两个节点，然后在left和right中实现反转</p><p>反转之后把这里的两个指针接在前面的两个指针后面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head: Optional[ListNode], left: int, right: int)</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">        newhead = ListNode(<span class="number">-1</span>)</span><br><span class="line">        newhead.next = head</span><br><span class="line"></span><br><span class="line">        pre = newhead</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(left - <span class="number">1</span>):</span><br><span class="line">            pre = pre.next</span><br><span class="line">        </span><br><span class="line">        tail, subtail, cur = pre, pre.next, pre.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(right - left + <span class="number">1</span>):</span><br><span class="line">            temp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre, cur = cur, temp</span><br><span class="line">        </span><br><span class="line">        tail.next = pre</span><br><span class="line">        subtail.next = cur</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newhead.next</span><br></pre></td></tr></table></figure><h4 id="93-复原-IP-地址-力扣（LeetCode）"><a href="#93-复原-IP-地址-力扣（LeetCode）" class="headerlink" title="93. 复原 IP 地址 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/" target="_blank" rel="noopener">93. 复原 IP 地址 - 力扣（LeetCode）</a></h4><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:192.168@1.1" target="_blank" rel="noopener">192.168@1.1</a>“ 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"25525511135"</span></span><br><span class="line">输出：[<span class="string">"255.255.11.135"</span>,<span class="string">"255.255.111.35"</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"0000"</span></span><br><span class="line">输出：[<span class="string">"0.0.0.0"</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"101023"</span></span><br><span class="line">输出：[<span class="string">"1.0.10.23"</span>,<span class="string">"1.0.102.3"</span>,<span class="string">"10.1.0.23"</span>,<span class="string">"10.10.2.3"</span>,<span class="string">"101.0.2.3"</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>回溯。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line"></span><br><span class="line">        seg_Count = <span class="number">4</span></span><br><span class="line">        ans = []</span><br><span class="line">        segments = [<span class="number">0</span>] * seg_Count</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(segId, segStart)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> segId == seg_Count:</span><br><span class="line">                <span class="keyword">if</span> segStart == len(s):</span><br><span class="line">                    ipAddr = <span class="string">'.'</span>.join(str(seg) <span class="keyword">for</span> seg <span class="keyword">in</span> segments)</span><br><span class="line">                    ans.append(ipAddr)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 没有找到4段IP地址就已经遍历完成了字符串，那么直接结束</span></span><br><span class="line">            <span class="keyword">if</span> segStart == len(s):</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 由于不能有前导0，所以如果当前数字为0，那么这一段IP地址只能为0.</span></span><br><span class="line">            <span class="keyword">if</span> s[segStart] == <span class="string">'0'</span>:</span><br><span class="line">                segments[segId] = <span class="number">0</span></span><br><span class="line">                dfs(segId + <span class="number">1</span>, segStart + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            addr = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> segEnd <span class="keyword">in</span> range(segStart, len(s)):</span><br><span class="line">                addr = addr * <span class="number">10</span> + (ord(s[segEnd]) - ord(<span class="string">'0'</span>))</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt; addr &lt;= <span class="number">255</span>:</span><br><span class="line">                    segments[segId] = addr</span><br><span class="line">                    dfs(segId + <span class="number">1</span>, segEnd + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="94-二叉树的中序遍历-力扣（LeetCode）"><a href="#94-二叉树的中序遍历-力扣（LeetCode）" class="headerlink" title="94. 二叉树的中序遍历 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历 - 力扣（LeetCode）</a></h4><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 **中序** 遍历</em> 。 </p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,null,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = <span class="string">[1]</span></span><br><span class="line">输出：<span class="string">[1]</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>递归，注意递归结束条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)</span><br></pre></td></tr></table></figure><h4 id="95-不同的二叉搜索树-II-力扣（LeetCode）"><a href="#95-不同的二叉搜索树-II-力扣（LeetCode）" class="headerlink" title="95. 不同的二叉搜索树 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">95. 不同的二叉搜索树 II - 力扣（LeetCode）</a></h4><p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。 </p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：[[<span class="number">1</span>,null,<span class="number">2</span>,null,<span class="number">3</span>],[<span class="number">1</span>,null,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">1</span>,null,null,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,null,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[[1]]</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>二叉搜索树的关键性质就是根节点的值大于左子树所有节点的值，小于右子树所有节点的值，且左子树和右子树也同样为二叉搜索树。</p><p>所以我们可以枚举根节点的值为i，然后左子树的节点的集合就为1到i-1，右子树的所有集合就为i+1到n。而左右子树又可以递归生成。</p><p>我们得到左右子树所有的可能之后，然后遍历左右子树所有的可能，并且接在当前根节点的左右子节点上面就行。还是一个递归加回溯的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[Optional[TreeNode]]:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">genTrees</span><span class="params">(start, end)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> start &gt; end:</span><br><span class="line">                <span class="keyword">return</span> [<span class="literal">None</span>]</span><br><span class="line">            </span><br><span class="line">            allTrees = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end + <span class="number">1</span>):</span><br><span class="line">                leftTrees = genTrees(start, i - <span class="number">1</span>)</span><br><span class="line">                rightTrees = genTrees(i + <span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> leftTrees:</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> rightTrees:</span><br><span class="line">                        curRoot = TreeNode(i)</span><br><span class="line">                        curRoot.left = j</span><br><span class="line">                        curRoot.right = k</span><br><span class="line">                        allTrees.append(curRoot)</span><br><span class="line">            <span class="keyword">return</span> allTrees</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> genTrees(<span class="number">1</span>, n) <span class="keyword">if</span> n <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure><h4 id="96-不同的二叉搜索树-力扣（LeetCode）"><a href="#96-不同的二叉搜索树-力扣（LeetCode）" class="headerlink" title="96. 不同的二叉搜索树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树 - 力扣（LeetCode）</a></h4><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。 </p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>dp，遍历根节点，然后把根节点左边的数能形成的二叉搜索树总数乘上右边的数能形成的二叉搜索树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h4 id="97-交错字符串-力扣（LeetCode）"><a href="#97-交错字符串-力扣（LeetCode）" class="headerlink" title="97. 交错字符串 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/interleaving-string/" target="_blank" rel="noopener">97. 交错字符串 - 力扣（LeetCode）</a></h4><p>给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。</p><p>两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：</p><p>s = s1 + s2 + … + sn<br>t = t1 + t2 + … + tm<br>|n - m| &lt;= 1<br>交错 是 s1 + t1 + s2 + t2 + s3 + t3 + … 或者 t1 + s1 + t2 + s2 + t3 + s3 + …<br>注意：a + b 意味着字符串 a 和 b 连接。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg" alt></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s1</span> = <span class="string">"aabcc"</span>, <span class="attr">s2</span> = <span class="string">"dbbca"</span>, <span class="attr">s3</span> = <span class="string">"aadbbcbcac"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s1</span> = <span class="string">"aabcc"</span>, <span class="attr">s2</span> = <span class="string">"dbbca"</span>, <span class="attr">s3</span> = <span class="string">"aadbbbaccc"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s1</span> = <span class="string">""</span>, <span class="attr">s2</span> = <span class="string">""</span>, <span class="attr">s3</span> = <span class="string">""</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>双指针不行，因为当判断到两个指针都与s3相等时，不知道怎么判断。</p><p>这里的方法应该是dp，二维dp，s1和s2的长度分别作为二维矩阵的长宽</p><p>若s1当前的字符与s3当前的字符相同，则<code>dp[i][j] = dp[i - 1][j]</code>，若s2当前的字符与s3当前的字符相同，则<code>dp[i][j] = dp[i][j - 1]</code></p><p>两个只有有一个为True，则当前的dp就为True</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span><span class="params">(self, s1: str, s2: str, s3: str)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">        m, n, t = len(s1), len(s2), len(s3)</span><br><span class="line">        <span class="keyword">if</span> n + m != t:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">                p = i + j - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j] <span class="keyword">or</span> (dp[i - <span class="number">1</span>][j] <span class="keyword">and</span> s1[i - <span class="number">1</span>] == s3[p])</span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j] <span class="keyword">or</span> (dp[i][j - <span class="number">1</span>] <span class="keyword">and</span> s2[j - <span class="number">1</span>] == s3[p])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><h4 id="98-验证二叉搜索树-力扣（LeetCode）"><a href="#98-验证二叉搜索树-力扣（LeetCode）" class="headerlink" title="98. 验证二叉搜索树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树 - 力扣（LeetCode）</a></h4><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,null,null,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">输出：false</span><br><span class="line">解释：根节点的值是 <span class="number">5</span> ，但是右子节点的值是 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>递归，递归函数每次传递当前节点，和当前节点的上下边界，如果当前节点的值超过了上下边界则说明不是，返回False，如果没有超过，再递归判断当前节点的左右子树并更新左右子树的上下边界。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root, lower, upper)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> root.val &gt;= lower <span class="keyword">or</span> root.val &lt;= upper:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> helper(root.left, root.val, upper) <span class="keyword">and</span> helper(root.right, lower, root.val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(root, float(<span class="string">'inf'</span>), float(<span class="string">'-inf'</span>))</span><br></pre></td></tr></table></figure><p>还有一个思路，中序遍历，如果中序遍历的某个值小于他前面的任意一个数的值，则说明不是，所以其中序遍历应该是单调递增的。</p><h4 id="100-相同的树-力扣（LeetCode）"><a href="#100-相同的树-力扣（LeetCode）" class="headerlink" title="100. 相同的树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/same-tree/" target="_blank" rel="noopener">100. 相同的树 - 力扣（LeetCode）</a></h4><p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：p = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], q = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：p = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>], q = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: Optional[TreeNode], q: Optional[TreeNode])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> p.val != q.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-两数之和-力扣（LeetCode）-https-leetcode-cn-problems-two-sum&quot;&gt;&lt;a href=&quot;#1-两数之和-力扣（LeetCode）-https-leetcode-cn-problems-two-sum&quot; class=&quot;headerlink&quot; title=&quot;1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/)&quot;&gt;&lt;/a&gt;1. 两数之和 - 力扣（LeetCode）](&lt;a href=&quot;https://leetcode.cn/problems/two-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.cn/problems/two-sum/&lt;/a&gt;)&lt;/h4&gt;&lt;p&gt;给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。&lt;/p&gt;
&lt;p&gt;你可以按任意顺序返回答案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>算法刷题总结</title>
    <link href="http://yoursite.com/2022/08/10/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2022/08/10/算法刷题总结/</id>
    <published>2022-08-09T16:19:10.979Z</published>
    <updated>2022-08-09T16:27:37.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>线性结构：数组、队列、栈、链表</p><p>非线性结构：树，</p><a id="more"></a><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是存放在连续内存空间上的相同类型数据的集合。</p><p>数组的内存空间的地址是连续的，所有在删除或者增添元素的时候，要移动其他元素的地址，最大的时间复杂度为O(n)。</p><p>C++中二维数组在地址空间上是连续的。</p><p>关于数组的题大部分可以分为：</p><ul><li>若数组有序，大概率二分。</li><li>若数组无序，看数据范围，数据范围最大为10^5，大概率要排序，若最大为10^8，则说明不能排序，考虑双指针，或者用辅助变量，如set，map，辅助栈这些。</li></ul><p>对于二维的数组，若有序，仍可以二分，或者找行或者列单调性。若无序，大概率模拟了，除非是那种dfs或者dp。</p><h4 id="剑指Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指Offer 21. 调整数组顺序使奇数位于偶数前面 )"></a><a href="[剑指 Offer 21. 调整数组顺序使奇数位于偶数前面 - 力扣（LeetCode）](https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指Offer 21. 调整数组顺序使奇数位于偶数前面</a> )</h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。 </p><p><strong>示例：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>] </span><br><span class="line">注：[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>] 也是正确的答案之一。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>一、遍历一遍数组，分别找出奇数和偶数两个数组，最后返回的时候加起来。</p><p>二、定义两个指针，左右指针，左指针从头到尾找指针，右指针从尾到头找奇数，然后交换，然后继续查找直到左指针在右指针后面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> nums[left] &amp; <span class="number">1</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> <span class="keyword">not</span> nums[right] &amp; <span class="number">1</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:</span><br><span class="line">                nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-29-顺时针打印矩阵-力扣（LeetCode）"><a href="#剑指-Offer-29-顺时针打印矩阵-力扣（LeetCode）" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">剑指 Offer 29. 顺时针打印矩阵 - 力扣（LeetCode）</a></h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 </p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong>：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>定义四个指针，上下左右四个指针，分别指向当前需要输出的四个坐标，然后依次访问每个元素输出就行，当上指针在下指针下面或者左指针在右指针右边的时候跳出循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> []</span><br><span class="line">        left, right, top, bottom = <span class="number">0</span>, len(matrix[<span class="number">0</span>])<span class="number">-1</span>, <span class="number">0</span>, len(matrix)<span class="number">-1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(left, right+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[top][i])</span><br><span class="line">            top += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> top &gt; bottom: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(top, bottom+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][right])</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right &lt; left: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(right, left<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                res.append(matrix[bottom][i])</span><br><span class="line">            bottom -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> bottom &lt; top: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(bottom, top<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                res.append(matrix[i][left])</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>每次取矩阵第一行的元素输出，然后将矩阵向左旋转90度，继续取第一行得元素，直到矩阵为空。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> matrix:</span><br><span class="line">            res.extend(matrix.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">break</span></span><br><span class="line">            matrix = [[row[j] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)]  <span class="comment"># 矩阵向左旋转90度</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指Offer04-二维数组中的查找"><a href="#剑指Offer04-二维数组中的查找" class="headerlink" title="剑指Offer04 二维数组中的查找 )"></a><a href="[剑指 Offer 04. 二维数组中的查找 - 力扣（LeetCode）](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指Offer04 二维数组中的查找</a> )</h4><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>示例:</p><p>现有矩阵 matrix 如下：</p><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。</p><p>给定 target = 20，返回 false。</p><p><strong>思路</strong></p><p>从左下角向右上角查找，如果当前值比target大，则向上，筛除一行的数据，如果当前值比target小，则向右，筛除一列的数据。</p><p>为什么不从右下角开始是因为，当当前值比target大时，既可能向左又可能向上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        rows, cols = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        i, j = rows<span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; cols:</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] &lt; target:</span><br><span class="line">                    j = j + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是一种通过指针串联在一起的线性结构，每一部分由数据和下一个节点的地址组成。最后一个节点的指针指向None。链表中的节点在内存中是散乱分布在内存中的某个地址上的，分配机制取决于操作系统的内存管理。</p><p>关于链表的考点主要有几种方法：哨兵节点、快慢指针。而且对链表进行删除等操作时往往会新生成一个节点然后指向当前的头节点。</p><h4 id="剑指Offer-22-链表中倒数第k个节点"><a href="#剑指Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指Offer 22. 链表中倒数第k个节点 )"></a><a href="[剑指 Offer 22. 链表中倒数第k个节点 - 力扣（LeetCode）](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指Offer 22. 链表中倒数第k个节点</a> )</h4><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p><p><strong>示例：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 和 k = <span class="number">2.</span></span><br><span class="line"></span><br><span class="line">返回链表 <span class="number">4</span>-&gt;<span class="number">5.</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>双指针：左右指针，先把右指针从头节点向后移动k个，然后左右指针同时向右移动，当右指针到结尾的时候，左指针就为倒数的第k个节点，返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        left, right = head, head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> right.next:</span><br><span class="line">                right = right.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">while</span> right:</span><br><span class="line">            left, right = left.next, right.next</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h4 id="61-旋转链表-力扣（LeetCode）"><a href="#61-旋转链表-力扣（LeetCode）" class="headerlink" title="61. 旋转链表 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/rotate-list/" target="_blank" rel="noopener">61. 旋转链表 - 力扣（LeetCode）</a></h4><p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置。 </p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], k = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>其实就是找链表的倒数第k个元素，然后把倒数第k个元素作为头，原链表的尾连接原链表的头。</p><p>先统计链表的长度，然后将k与链表的长度取余。然后找到链表的倒数第k个节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head: Optional[ListNode], k: int)</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        last, count = head, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> last.next:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            last = last.next</span><br><span class="line">        </span><br><span class="line">        left, right, k = head, head, k % count</span><br><span class="line">        <span class="keyword">while</span> k:</span><br><span class="line">            right = right.next</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right.next:</span><br><span class="line">            left = left.next</span><br><span class="line">            right = right.next</span><br><span class="line">        right.next = head</span><br><span class="line">        head = left.next</span><br><span class="line">        left.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h4 id="剑指Offer-25-合并两个排序的链表"><a href="#剑指Offer-25-合并两个排序的链表" class="headerlink" title="剑指Offer 25. 合并两个排序的链表 )"></a><a href="[剑指 Offer 25. 合并两个排序的链表 - 力扣（LeetCode）](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指Offer 25. 合并两个排序的链表</a> )</h4><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 </p><p><strong>示例1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>用一个伪头节点，在用一个当前节点cur指向当前的节点，然后分别用两个指针指向两个链表，依次判断大小值然后插入到前面当前节点的后面，然后当前节点后移一位，最后判断两个链表是否还有多余的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        cur = dum = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                cur.next, l1 = l1, l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next, l2 = l2, l2.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        cur.next = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">        <span class="keyword">return</span> dum.next</span><br></pre></td></tr></table></figure><h4 id="剑指Offer-52-两个链表的第一个公共节点"><a href="#剑指Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指Offer 52. 两个链表的第一个公共节点 )"></a><a href="[剑指 Offer 52. 两个链表的第一个公共节点 - 力扣（LeetCode）](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指Offer 52. 两个链表的第一个公共节点</a> )</h4><p>输入两个链表，找出它们的第一个公共节点。 </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = <span class="number">8</span>, listA = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], listB = [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], skipA = <span class="number">2</span>, skipB = <span class="number">3</span></span><br><span class="line">输出：Reference of the node with value = <span class="number">8</span></span><br><span class="line">输入解释：相交节点的值为 <span class="number">8</span> （注意，如果两个列表相交则不能为 <span class="number">0</span>）。从各自的表头开始算起，链表 A 为 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]，链表 B 为 [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]。在 A 中，相交节点前有 <span class="number">2</span> 个节点；在 B 中，相交节点前有 <span class="number">3</span> 个节点。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>双指针：设A链表的长度为a，B链表的长度为b，后面公共的子节点的长度为c，</p><p>分别用两个指针从两个链表的头开始向后遍历，当遍历到链表结尾时从另外一个链表的头继续开始遍历。因为两个链表的长度是固定的a+b，后面相同的节点长度为c，所以如果有公共节点，当两个指针都运动a+b-c个长度的时候一定会相遇。</p><p>所以当两个指针相遇的时候一定就是第一个相同节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA: ListNode, headB: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        ha, hb = headA, headB</span><br><span class="line">        <span class="keyword">while</span> ha != hb:</span><br><span class="line">            ha = ha.next <span class="keyword">if</span> ha <span class="keyword">else</span> headB</span><br><span class="line">            hb = hb.next <span class="keyword">if</span> hb <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> ha</span><br></pre></td></tr></table></figure><h4 id="剑指Offer35-复杂链表的复制"><a href="#剑指Offer35-复杂链表的复制" class="headerlink" title="剑指Offer35. 复杂链表的复制 )"></a><a href="[剑指 Offer 35. 复杂链表的复制 - 力扣（LeetCode）](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指Offer35. 复杂链表的复制</a> )</h4><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><p>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p><p><strong>思路</strong></p><p>先遍历一遍链表，建立“原节点 - 新节点”的一个dict，然后在遍历一遍原链表，将新节点的next和random通过dict指向对应的新节点。</p><p>时间复杂度和空间复杂度：O(N)</p><p>方法二：拼接 + 拆分</p><p>考虑构建 原节点 1 -&gt; 新节点 1 -&gt; 原节点 2 -&gt; 新节点 2 -&gt; …… 的拼接链表，如此便可在访问原节点的 random 指向节点的同时找到新对应新节点的 random 指向节点。</p><p><a href="[剑指 Offer 35. 复杂链表的复制（哈希表 / 拼接与拆分，清晰图解） - 复杂链表的复制 - 力扣（LeetCode）](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/jian-zhi-offer-35-fu-za-lian-biao-de-fu-zhi-ha-xi-/">算法流程</a> )：</p><ul><li>复制各节点，构建拼接链表:</li><li>构建新链表各节点的 random 指向：<ul><li>当访问原节点 cur 的随机指向节点 cur.random 时，对应新节点 cur.next 的随机指向节点为 cur.random.next </li></ul></li><li>拆分原/新链表<ul><li>设置 pre / cur 分别指向原 / 新链表头节点，遍历执行 pre.next = pre.next.next 和 cur.next = cur.next.next 将两链表拆分开。</li></ul></li><li>返回新链表的头节点res。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):</span></span><br><span class="line"><span class="string">        self.val = int(x)</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.random = random</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> head</span><br><span class="line">        oldTonew = &#123;&#125;</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            oldTonew[cur] = Node(cur.val)</span><br><span class="line">            cur = cur.next</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            oldTonew[cur].next = oldTonew.get(cur.next)</span><br><span class="line">            oldTonew[cur].random = oldTonew.get(cur.random)</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> oldTonew[head]</span><br></pre></td></tr></table></figure><h4 id="23-合并K个升序链表-力扣（LeetCode）"><a href="#23-合并K个升序链表-力扣（LeetCode）" class="headerlink" title="23. 合并K个升序链表 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个升序链表 - 力扣（LeetCode）</a></h4><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = <span class="string">[]</span></span><br><span class="line">输出：<span class="string">[]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = <span class="string">[[]]</span></span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>归并排序的思想，</p><p>写一个合并两个有序链表的子函数，然后将k个有序的链表每次两两分开，然后再调用合并两个有序链表的子函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[Optional[ListNode]])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.merge(lists, <span class="number">0</span>, len(lists) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, lists, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == right: <span class="keyword">return</span> lists[left]</span><br><span class="line">        <span class="keyword">if</span> left &gt; right: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> self.mergeTwoLists(self.merge(lists, left, mid), self.merge(lists, mid + <span class="number">1</span>, right))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        prehead = ListNode(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        cur = prehead</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                cur.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        </span><br><span class="line">        cur.next = l1 <span class="keyword">if</span> <span class="keyword">not</span> l2 <span class="keyword">else</span> l2</span><br><span class="line">        <span class="keyword">return</span> prehead.next</span><br></pre></td></tr></table></figure><h4 id="24-两两交换链表中的节点-力扣（LeetCode）"><a href="#24-两两交换链表中的节点-力扣（LeetCode）" class="headerlink" title="24. 两两交换链表中的节点 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></h4><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 </p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[]</span></span><br><span class="line">输出：<span class="string">[]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1]</span></span><br><span class="line">输出：<span class="string">[1]</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>前后指针，双指针。每次指向要交换的两个节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        pre = ListNode(<span class="number">-1</span>)</span><br><span class="line">        pre.next = head</span><br><span class="line"></span><br><span class="line">        newhead = pre</span><br><span class="line"></span><br><span class="line">        left, right = head, head.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> right:</span><br><span class="line">            temp = right.next</span><br><span class="line">            pre.next = right</span><br><span class="line">            right.next = left</span><br><span class="line">            left.next = temp</span><br><span class="line"></span><br><span class="line">            right = temp</span><br><span class="line">            right = right.next <span class="keyword">if</span> right <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            left, pre = temp, left</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newhead.next</span><br></pre></td></tr></table></figure><p><strong>递归</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        newHead = head.next</span><br><span class="line">        head.next = self.swapPairs(newHead.next)</span><br><span class="line">        newHead.next = head</span><br><span class="line">        <span class="keyword">return</span> newHead</span><br></pre></td></tr></table></figure><h4 id="25-K-个一组翻转链表-力扣（LeetCode）"><a href="#25-K-个一组翻转链表-力扣（LeetCode）" class="headerlink" title="25. K 个一组翻转链表 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. K 个一组翻转链表 - 力扣（LeetCode）</a></h4><p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>递归，先翻转前面的k个节点，然后再递归翻转后面的头节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 翻转一个子链表，并且返回新的头与尾</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, head: ListNode, tail: ListNode)</span>:</span></span><br><span class="line">        prev = tail.next</span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> prev != tail:</span><br><span class="line">            nex = p.next</span><br><span class="line">            p.next = prev</span><br><span class="line">            prev = p</span><br><span class="line">            p = nex</span><br><span class="line">        <span class="keyword">return</span> tail, head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        hair = ListNode(<span class="number">0</span>)</span><br><span class="line">        hair.next = head</span><br><span class="line">        pre = hair</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            tail = pre</span><br><span class="line">            <span class="comment"># 查看剩余部分长度是否大于等于 k</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">                tail = tail.next</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">                    <span class="keyword">return</span> hair.next</span><br><span class="line">            nex = tail.next</span><br><span class="line">            head, tail = self.reverse(head, tail)</span><br><span class="line">            <span class="comment"># 把子链表重新接回原链表</span></span><br><span class="line">            pre.next = head</span><br><span class="line">            tail.next = nex</span><br><span class="line">            pre = tail</span><br><span class="line">            head = tail.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> hair.next</span><br></pre></td></tr></table></figure><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>栈和队列都是顺序存储结构，不同点在于栈先进后出，队列是先进先出。函数递归就是一种栈的数据结构，所以当数据量较大出现多次递归的时候会出现爆栈，而且递归速度慢。</p><p>使用栈的一些题型：表达式求值，括号匹配。</p><p>使用队列的一些题型：银行排队问题，</p><p>知道了栈和队列的思想之后，在做题的实现过程中一般就是用数组来实现。除非是要用双向队列这种特殊的数据结构。</p><h4 id="剑指Offer-09-用两个栈实现队列-https-leetcode-cn-com-problems-yong-liang-ge-zhan-shi-xian-dui-lie-lcof"><a href="#剑指Offer-09-用两个栈实现队列-https-leetcode-cn-com-problems-yong-liang-ge-zhan-shi-xian-dui-lie-lcof" class="headerlink" title="剑指Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/) )"></a><a href="[剑指 Offer 09. 用两个栈实现队列 - 力扣（LeetCode） (leetcode-cn.com">剑指Offer 09. 用两个栈实现队列</a>](<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/</a>) )</h4><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数<code>appendTail</code>和<code>deleteHead</code>，分别完成在队列尾部插入整数和在队列头部删除整数的功能。（若队列中没有元素，<code>deleteHead</code>操作返回-1）</p><p><strong>示例 1</strong>：</p><blockquote><p>输入：</p><p>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]</p><p>[[],[3],[],[]]</p><p>输出：[null,null,3,-1]</p></blockquote><p><strong>示例 2</strong>：</p><blockquote><p>输入：</p><p>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[],[5],[2],[],[]]<br>输出：[null,-1,null,null,5,2]</p></blockquote><p><strong>解题思路：</strong></p><ul><li>栈无法实现队列功能：</li><li>双栈可实现列表倒序：将一个栈的出栈到另外一个栈的入栈，可以实现栈的倒序。</li><li>利用辅助栈可以删除队首的元素：倒序之后，辅助栈的出栈相当于删除了原栈底的元素，即对应的队首元素。</li></ul><blockquote><p>设计栈A用于加入队列尾部的操作，辅助栈B用于将元素倒序，从而实现删除队首元素。</p></blockquote><ul><li>加入队尾<code>appendTail()</code>函数：将数字<code>val</code>加入栈A即可。</li><li>删除队首<code>deleteHead</code>函数：有以下三种情况：<ol><li>当辅助栈B不为空时：直接返回栈B的栈顶元素。</li><li>当辅助栈B为空且A为空时：队列为空，返回-1</li><li>当辅助栈B为空且A不为空时：将栈A倒序到栈B中，然后返回栈B的栈顶元素。</li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.A, self.B = [], []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.A.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.B:</span><br><span class="line">            <span class="keyword">return</span> self.B.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.A:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> self.A:</span><br><span class="line">                    self.B.append(self.A.pop())</span><br><span class="line">                <span class="keyword">return</span> self.B.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = CQueue()</span></span><br><span class="line"><span class="comment"># obj.appendTail(value)</span></span><br><span class="line"><span class="comment"># param_2 = obj.deleteHead()</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-31-栈的压入、弹出序列-力扣（LeetCode）"><a href="#剑指-Offer-31-栈的压入、弹出序列-力扣（LeetCode）" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 31. 栈的压入、弹出序列 - 力扣（LeetCode）</a></h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p><strong>示例 1：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], popped = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push<span class="function"><span class="params">(<span class="number">1</span>)</span>, <span class="title">push</span><span class="params">(<span class="number">2</span>)</span>, <span class="title">push</span><span class="params">(<span class="number">3</span>)</span>, <span class="title">push</span><span class="params">(<span class="number">4</span>)</span>, <span class="title">pop</span><span class="params">()</span> -&gt;</span> <span class="number">4</span>,</span><br><span class="line">push<span class="function"><span class="params">(<span class="number">5</span>)</span>, <span class="title">pop</span><span class="params">()</span> -&gt;</span> <span class="number">5</span>, pop<span class="function"><span class="params">()</span> -&gt;</span> <span class="number">3</span>, pop<span class="function"><span class="params">()</span> -&gt;</span> <span class="number">2</span>, pop<span class="function"><span class="params">()</span> -&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], popped = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：false</span><br><span class="line">解释：<span class="number">1</span> 不能在 <span class="number">2</span> 之前弹出。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>定义一个数组arr来模拟栈的压入和弹出。然后用一个poped的下标指针index指向当前出栈了哪些元素，最后若该index指针等于len(poped)则说明全部可以出栈。</p><p>遍历pushed数组，并将遍历到的数压入arr中，判断当前的数是否与poped数组的下标为index的数相同，若相同则说明要出栈，此时将相同的全部出栈，arr执行pop()操作，poped数组执行index+1的操作，然后继续遍历pushed数组，指导遍历结束判断index是否为len(poped)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span><span class="params">(self, pushed: List[int], popped: List[int])</span> -&gt; bool:</span></span><br><span class="line">        arr = []</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(pushed)):</span><br><span class="line">            arr.append(pushed[i])</span><br><span class="line">            <span class="keyword">if</span> pushed[i] == popped[index]:</span><br><span class="line">                <span class="keyword">while</span> <span class="number">0</span> &lt;= index &lt; len(popped) <span class="keyword">and</span> arr <span class="keyword">and</span> arr[<span class="number">-1</span>] == popped[index]:</span><br><span class="line">                    arr.pop()</span><br><span class="line">                    index += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> bool( index == len(popped) )</span><br></pre></td></tr></table></figure><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p><strong>单调队列模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="line"><span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-59-I-滑动窗口的最大值-力扣（LeetCode）"><a href="#剑指-Offer-59-I-滑动窗口的最大值-力扣（LeetCode）" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - I. 滑动窗口的最大值 - 力扣（LeetCode）</a></h4><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。 </p><p><strong>示例</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,<span class="string">-1</span>,<span class="string">-3</span>,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  <span class="string">-1</span>] <span class="string">-3</span>  5  3  6  7       3</span><br><span class="line"> 1 [3  <span class="string">-1</span>  <span class="string">-3</span>] 5  3  6  7       3</span><br><span class="line"> 1  3 [<span class="string">-1</span>  <span class="string">-3</span>  5] 3  6  7       5</span><br><span class="line"> 1  3  <span class="string">-1</span> [<span class="string">-3</span>  5  3] 6  7       5</span><br><span class="line"> 1  3  <span class="string">-1</span>  <span class="string">-3</span> [5  3  6] 7       6</span><br><span class="line"> 1  3  <span class="string">-1</span>  <span class="string">-3</span>  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p><em>方法一</em></p><p>直接遍历0到i-k，然后每次取最大值，时间复杂度较大O(nk)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - k + <span class="number">1</span>):</span><br><span class="line">            res.append(max(nums[i:(i + k)]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><em>方法二</em></p><p>维护一个双向队列，里面从0开始往后，是一个非递增的数列，即0处保存的肯定是当前窗口最大数列，后面的每个数都比这个数小或者相等。然后每次向后面滑的过程中，先判断队首0处的最大值是不是等于左边滑出去的那个值，如果是，应该去掉。然后在从队列的尾部往前遍历，如果是小于当前要插入进来的值时，就应该去掉，因为待插进来的这个值比这些值大，去掉之后再把当前的值插入到队尾，保持双向队列的非递增特性。最后再把队首0位置处的值插入到res中。注意前面i&lt;k部分的时候还没有形成窗口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> []</span><br><span class="line">        deque = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> deque[<span class="number">-1</span>] &lt; nums[i]:</span><br><span class="line">                deque.pop()</span><br><span class="line">            deque.append(nums[i])</span><br><span class="line">        res.append(deque[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> deque[<span class="number">0</span>] == nums[i - k]:</span><br><span class="line">                deque.popleft()</span><br><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> deque[<span class="number">-1</span>] &lt; nums[i]:</span><br><span class="line">                deque.pop()</span><br><span class="line">            deque.append(nums[i])</span><br><span class="line">            res.append(deque[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-59-II-队列的最大值-力扣（LeetCode）"><a href="#剑指-Offer-59-II-队列的最大值-力扣（LeetCode）" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - II. 队列的最大值 - 力扣（LeetCode）</a></h4><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[<span class="string">"MaxQueue"</span>,<span class="string">"push_back"</span>,<span class="string">"push_back"</span>,<span class="string">"max_value"</span>,<span class="string">"pop_front"</span>,<span class="string">"max_value"</span>]</span><br><span class="line">[[],[<span class="number">1</span>],[<span class="number">2</span>],[],[],[]]</span><br><span class="line">输出: [null,null,null,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[<span class="string">"MaxQueue"</span>,<span class="string">"pop_front"</span>,<span class="string">"max_value"</span>]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,<span class="number">-1</span>,<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>定义一个双向队列，队首用来保存队列的最大值，并且从队首到队尾为一个非递增数列（可以递减也可以相等），则每次pop的时候需要判断pop掉的是不是最大值，如果是，则需要将最大值的双向队列也pop掉，push的时候，则需要判断双向队列的队尾是不是比当前待插入的值小，如果小，则可以直接将这些值pop掉，即保持双向队列的非递增数列，然后最大值则只需要返回这个双向队列的队首就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.deque_max = collections.deque()</span><br><span class="line">        self.deque = collections.deque()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_value</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.deque_max: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self.deque_max[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push_back</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.deque.append(value)</span><br><span class="line">        <span class="keyword">while</span> self.deque_max <span class="keyword">and</span> self.deque_max[<span class="number">-1</span>] &lt; value:</span><br><span class="line">            self.deque_max.pop()</span><br><span class="line">        self.deque_max.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_front</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.deque: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        temp = self.deque.popleft()</span><br><span class="line">        <span class="keyword">if</span> self.deque_max[<span class="number">0</span>] == temp:</span><br><span class="line">            self.deque_max.popleft()</span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MaxQueue()</span></span><br><span class="line"><span class="comment"># param_1 = obj.max_value()</span></span><br><span class="line"><span class="comment"># obj.push_back(value)</span></span><br><span class="line"><span class="comment"># param_3 = obj.pop_front()</span></span><br></pre></td></tr></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p><strong>单调栈模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出每个数左边离它最近的比它大/小的数</span><br><span class="line"><span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; check(stk[tt], i)) tt -- ;</span><br><span class="line">    stk[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="剑指Offer-30-包含min函数的栈-https-leetcode-cn-com-problems-bao-han-minhan-shu-de-zhan-lcof"><a href="#剑指Offer-30-包含min函数的栈-https-leetcode-cn-com-problems-bao-han-minhan-shu-de-zhan-lcof" class="headerlink" title="剑指Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/) )"></a><a href="[剑指 Offer 30. 包含min函数的栈 - 力扣（LeetCode） (leetcode-cn.com">剑指Offer 30. 包含min函数的栈</a>](<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/</a>) )</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数在该栈中，调用min、push及pop的时间复杂度都是O(1)</p><p><strong>示例</strong></p><blockquote><p>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.min();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.min();   –&gt; 返回 -2.</p></blockquote><p><strong>解题思路</strong></p><ul><li>本题难点：将<code>min()</code>函数复杂度降为O(1)，可以通过建立辅助栈实现：<ul><li>数据栈A：用于存储栈内元素，实现push、pop、获取栈顶元素函数。</li><li>辅助栈B：栈B中存储A中所有非严格降序的元素。则栈A中的最小元素始终对应栈B的栈顶元素。即<code>min()</code>函数只需要返回栈B的栈顶元素即可。</li></ul></li></ul><p>push(x) 函数： 重点为保持栈 BB 的元素是 非严格降序 的。</p><p>将 x 压入栈 A （即 A.add(x) ）；<br>若 ① 栈 B 为空 或 ② x 小于等于 栈 B 的栈顶元素，则将 x 压入栈 B （即 B.add(x) ）。<br>pop() 函数： 重点为保持栈 A, BA,B 的 元素一致性 。</p><p>执行栈 A 出栈（即 A.pop() ），将出栈元素记为 y ；<br>若 y 等于栈 B 的栈顶元素，则执行栈 B 出栈（即 B.pop() ）。</p><blockquote><p>会考虑到栈A一直pop的情况，注意：由于栈A中的最小值与栈B保持一致性，所以栈A实现pop的时候如果是最小值栈B一定会也会更新，除非栈A实现pop之后对栈A的最小值没有影响。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.A, self.B = [], []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.A.append(x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.B <span class="keyword">or</span> self.B[<span class="number">-1</span>] &gt;= x:</span><br><span class="line">            self.B.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.A.pop() == self.B[<span class="number">-1</span>]:</span><br><span class="line">            self.B.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.A[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.B[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop() </span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.min()</span></span><br></pre></td></tr></table></figure><h4 id="32-最长有效括号-力扣（LeetCode）"><a href="#32-最长有效括号-力扣（LeetCode）" class="headerlink" title="32. 最长有效括号 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-valid-parentheses/" target="_blank" rel="noopener">32. 最长有效括号 - 力扣（LeetCode）</a></h4><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。 </p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"(()"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最长有效括号子串是 <span class="string">"()"</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">")()())"</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长有效括号子串是 <span class="string">"()()"</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">""</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>dp思路： dp[i]表示以下标i字符结尾的最长有效括号的长度，将dp全部初始化为0，有效的子串一定是以’)’结尾的，返回dp的最大值。</p><p>从前往后遍历字符串求解dp值，每两个字符检查一次：</p><ol><li>s[i] = ‘)’ 且 s[i - 1] = ‘(‘，也就是字符串形如”……..()”，可以得到：<code>dp[i]  = dp[i - 2] + 2</code>。</li><li>s[i] = ‘)’ 且 s[i - 1] = ‘)’，也就是字符串形如”………))”，我们可以推出：如果s[i - dp[i - 1] - 1] = ‘(‘，那么<code>dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2</code>。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        s, dp = list(s), [<span class="number">0</span>] * (len(s))</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> i - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i - <span class="number">1</span>] == <span class="string">'('</span>:</span><br><span class="line">                    dp[i] = (dp[i - <span class="number">2</span>] <span class="keyword">if</span> i - <span class="number">2</span> &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>) + <span class="number">2</span></span><br><span class="line">                <span class="keyword">elif</span> i - <span class="number">1</span> - dp[i - <span class="number">1</span>] &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i - <span class="number">1</span> - dp[i - <span class="number">1</span>]] == <span class="string">'('</span>:</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + (dp[i - <span class="number">1</span> - dp[i - <span class="number">1</span>] - <span class="number">1</span>] <span class="keyword">if</span> i - <span class="number">1</span> - dp[i - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>) + <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            res = max(res, dp[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>栈</strong></p><p>始终保持栈底元素为当前已经遍历过的元素中[最后一个没有被匹配的右括号的下标]，</p><ul><li>对于遇到的每个’(‘，将它的下标放入栈中。</li><li>对于遇到的每个’)’，我们先弹出栈顶元素表示匹配了当前右括号：<ul><li>如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的[最后一个没有被匹配的右括号的下标]</li><li>如果栈不为空，当前右括号的下标减去栈顶元素即为[以该右括号为结尾的最长有效括号的长度]</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        stack, res = [<span class="number">-1</span>], <span class="number">0</span></span><br><span class="line">        s = list(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    stack.append(i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res = max(res, i - stack[<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="84-柱状图中最大的矩形-力扣（LeetCode）"><a href="#84-柱状图中最大的矩形-力扣（LeetCode）" class="headerlink" title="84. 柱状图中最大的矩形 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形 - 力扣（LeetCode）</a></h4><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p> <strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>每次针对当前的下标i，找到第一个高度小于当前高度的下标，然后计算面积，与之前的去最大。</p><p>所以维护一个单调栈，单调递增的，然后每次针对当前的高度height[i]，如果当前的高度大于栈顶，就把栈顶的元素出栈，并且计算一下面积取最大。直到栈顶的元素小于当前的高度，然后就把当前高度的下标入栈。注意是下标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">        stack, res = [], <span class="number">0</span></span><br><span class="line">        heights = [<span class="number">0</span>] + heights + [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[stack[<span class="number">-1</span>]] &gt; heights[i]:</span><br><span class="line">                temp = stack.pop()</span><br><span class="line">                res = max(res, (i - stack[<span class="number">-1</span>] - <span class="number">1</span>) * heights[temp])</span><br><span class="line">            stack.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h4 id="二叉树的题目大纲："><a href="#二叉树的题目大纲：" class="headerlink" title="二叉树的题目大纲："></a>二叉树的题目大纲：</h4><p>二叉树的遍历方式：</p><pre><code>[144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/) [145. 二叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/) [94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/) [102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/) </code></pre><p>二叉树的属性：</p><pre><code>[101. 对称二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/symmetric-tree/) [104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/) [111. 二叉树的最小深度 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-depth-of-binary-tree/) [222. 完全二叉树的节点个数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-complete-tree-nodes/) [110. 平衡二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/balanced-binary-tree/) [257. 二叉树的所有路径 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-paths/) [404. 左叶子之和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-left-leaves/) [513. 找树左下角的值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-bottom-left-tree-value/) [112. 路径总和 - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum/) </code></pre><p>二叉树的修改与改造：</p><pre><code>[226. 翻转二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/invert-binary-tree/) [106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) [654. 最大二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-binary-tree/) [617. 合并二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-binary-trees/) </code></pre><p>二叉搜索树的属性：</p><pre><code>[700. 二叉搜索树中的搜索 - 力扣（LeetCode）](https://leetcode.cn/problems/search-in-a-binary-search-tree/) [98. 验证二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/validate-binary-search-tree/) [530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/) [501. 二叉搜索树中的众数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-mode-in-binary-search-tree/) [538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-bst-to-greater-tree/) </code></pre><p>二叉树公共祖先问题：</p><pre><code>[236. 二叉树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/) [235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/) </code></pre><p>二叉搜索树的修改与改造：</p><pre><code>[701. 二叉搜索树中的插入操作 - 力扣（LeetCode）](https://leetcode.cn/problems/insert-into-a-binary-search-tree/) [450. 删除二叉搜索树中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-node-in-a-bst/) [669. 修剪二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/trim-a-binary-search-tree/) [108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/) </code></pre><h4 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h4><p><strong>满二叉树：</strong>就是只有度为0和度为2的节点，并且度为0的节点都在同一层。若满二叉树的深度为k，则该数的节点数为：$2^{k} - 1$ 个。</p><p><strong>完全二叉树：</strong>在完全二叉树中，除了最底层的节点没有填满之外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若底层为第h层，则该层包含1 ~ $ 2^{h - 1}$ 个节点。</p><p><img src="https://img-blog.csdnimg.cn/20200920221638903.png" alt></p><p>优先队列其实就是一个堆，堆就是一颗完全二叉树，同时保证父子节点的顺序关系。</p><p><strong>二叉搜索树：</strong>二叉搜索树是一个有序树，左子树的所有节点的值都小于根节点的值，右子树的所有节点的值都大于根节点的值，并且左右子树也都为二叉搜索树。</p><p><strong>平衡二叉搜索树：</strong>是一颗空树或者它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一颗平衡二叉树。</p><h4 id="二叉树的存储方式："><a href="#二叉树的存储方式：" class="headerlink" title="二叉树的存储方式："></a>二叉树的存储方式：</h4><p>二叉树可以链式存储、也可以顺序存储。</p><p>链式存储方式就用指针，顺序存储方式就是用数组。</p><h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h4><p>二叉树主要有两种遍历方式：</p><ol><li>深度优先遍历：先往深走、遇到叶子节点再往回走。</li><li>广度优先遍历：一层一层的去遍历。</li></ol><p><strong>这两种遍历方式是图论中最基本的两种遍历方式。</strong></p><ul><li>深度优先遍历<ul><li>前序遍历（递归法、迭代法）</li><li>中序遍历（递归法、迭代法）</li><li>后序遍历（递归法、迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><h4 id="二叉树的Python定义："><a href="#二叉树的Python定义：" class="headerlink" title="二叉树的Python定义："></a>二叉树的Python定义：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><strong>二叉树问题一般都是通过递归的方式来解决的，递归问题最重要的就是找准递归结束条件和子问题。</strong></p><h4 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前序遍历-递归-LC144_二叉树的前序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 保存结果</span></span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traversal</span><span class="params">(root: TreeNode)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            result.append(root.val) <span class="comment"># 前序</span></span><br><span class="line">            traversal(root.left)    <span class="comment"># 左</span></span><br><span class="line">            traversal(root.right)   <span class="comment"># 右</span></span><br><span class="line"></span><br><span class="line">        traversal(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中序遍历-递归-LC94_二叉树的中序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traversal</span><span class="params">(root: TreeNode)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            traversal(root.left)    <span class="comment"># 左</span></span><br><span class="line">            result.append(root.val) <span class="comment"># 中序</span></span><br><span class="line">            traversal(root.right)   <span class="comment"># 右</span></span><br><span class="line"></span><br><span class="line">        traversal(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后序遍历-递归-LC145_二叉树的后序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traversal</span><span class="params">(root: TreeNode)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            traversal(root.left)    <span class="comment"># 左</span></span><br><span class="line">            traversal(root.right)   <span class="comment"># 右</span></span><br><span class="line">            result.append(root.val) <span class="comment"># 后序</span></span><br><span class="line"></span><br><span class="line">        traversal(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前序遍历-迭代-LC144_二叉树的前序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 根结点为空则返回空列表</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="comment"># 中结点先处理</span></span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="comment"># 右孩子先入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            <span class="comment"># 左孩子后入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 中序遍历-迭代-LC94_二叉树的中序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = []  <span class="comment"># 不能提前将root结点加入stack中</span></span><br><span class="line">        result = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="comment"># 先迭代访问最底层的左子树结点</span></span><br><span class="line">            <span class="keyword">if</span> cur:     </span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="comment"># 到达最左结点后处理栈顶结点    </span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                result.append(cur.val)</span><br><span class="line">                <span class="comment"># 取栈顶元素右结点</span></span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 后序遍历-迭代-LC145_二叉树的后序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="comment"># 中结点先处理</span></span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="comment"># 左孩子先入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="comment"># 右孩子后入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="comment"># 将最终的数组翻转</span></span><br><span class="line">        <span class="keyword">return</span> result[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""二叉树层序遍历迭代解法"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        results = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> results</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        que = deque([root])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            size = len(que)</span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(size):</span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                result.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    que.append(cur.right)</span><br><span class="line">            results.append(result)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root, depth)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">if</span> len(res) == depth: res.append([]) <span class="comment"># start the current depth</span></span><br><span class="line">            res[depth].append(root.val) <span class="comment"># fulfil the current depth</span></span><br><span class="line">            <span class="keyword">if</span>  root.left: helper(root.left, depth + <span class="number">1</span>) <span class="comment"># process child nodes for the next depth</span></span><br><span class="line">            <span class="keyword">if</span>  root.right: helper(root.right, depth + <span class="number">1</span>)</span><br><span class="line">        helper(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指Offer32-从上到下打印二叉树-2"><a href="#剑指Offer32-从上到下打印二叉树-2" class="headerlink" title="剑指Offer32 从上到下打印二叉树-2 )"></a><a href="[剑指 Offer 32 - II. 从上到下打印二叉树 II - 力扣（LeetCode）](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指Offer32 从上到下打印二叉树-2</a> )</h4><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 </p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>上面的思路中，在每一层遍历树节点的时候用一个临时列表先存下来当前层的值，当这层全部遍历完之后插入到ans中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        node = [root]</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            ans_le = []</span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> index &lt; len(node):</span><br><span class="line">                temp = node.pop(index)</span><br><span class="line">                ans_le.append(temp.val)</span><br><span class="line">                <span class="keyword">if</span> temp.left:</span><br><span class="line">                    node.insert(index, temp.left)</span><br><span class="line">                    index = index+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> temp.right:</span><br><span class="line">                    node.insert(index, temp.right)</span><br><span class="line">                    index = index+<span class="number">1</span></span><br><span class="line">            ans.append(ans_le)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res, queue = [], collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solution/mian-shi-ti<span class="number">-32</span>-ii-cong-shang-dao-xia-da-yin-er-c<span class="number">-5</span>/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="剑指Offer26-树的子结构"><a href="#剑指Offer26-树的子结构" class="headerlink" title="剑指Offer26 树的子结构 )"></a><a href="[剑指 Offer 26. 树的子结构 - 力扣（LeetCode）](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">剑指Offer26 树的子结构</a> )</h4><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><pre><code> 3/ \</code></pre><p>   4   5<br>  / \<br> 1   2<br>给定的树 B：</p><p>   4<br>  /<br> 1<br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], B = [<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>], B = [<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>两步：</p><ul><li>先序遍历树A的每个节点：</li><li>判断树A中以当前节点作为根节点的子树是否包含树B。对应函数<code>recur(a, b)</code></li></ul><p><a href="[面试题26. 树的子结构（先序遍历 + 包含判断，清晰图解） - 树的子结构 - 力扣（LeetCode）](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/">算法流程</a> )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span><span class="params">(self, A: TreeNode, B: TreeNode)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(a, b)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> b: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> a <span class="keyword">or</span> a.val != b.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> recur(a.left, b.left) <span class="keyword">and</span> recur(a.right, b.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bool(A <span class="keyword">and</span> B) <span class="keyword">and</span> (recur(A, B) <span class="keyword">or</span> self.isSubStructure(A.left, B) <span class="keyword">or</span> self.isSubStructure(A.right, B))</span><br></pre></td></tr></table></figure><h4 id="剑指Offer-27-二叉树的镜像"><a href="#剑指Offer-27-二叉树的镜像" class="headerlink" title="剑指Offer 27 二叉树的镜像 )"></a><a href="[剑指 Offer 27. 二叉树的镜像 - 力扣（LeetCode）](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/">剑指Offer 27 二叉树的镜像</a> )</h4><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><pre><code>4</code></pre><p>   /   \<br>  2     7<br> / \   / \<br>1   3 6   9<br>镜像输出：</p><pre><code>4</code></pre><p>   /   \<br>  7     2<br> / \   / \<br>9   6 3   1</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>交换当前父节点的左右子树并继续递归调用当前的左右子树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment"># root.left, root.right = root.right, root.left</span></span><br><span class="line">        <span class="comment"># self.mirrorTree(root.left)</span></span><br><span class="line">        <span class="comment"># self.mirrorTree(root.right)</span></span><br><span class="line">        root.left, root.right = self.mirrorTree(root.right), self.mirrorTree(root.left)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h4 id="剑指Offer28-对称的二叉树"><a href="#剑指Offer28-对称的二叉树" class="headerlink" title="剑指Offer28 对称的二叉树 )"></a><a href="[剑指 Offer 28. 对称的二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/">剑指Offer28 对称的二叉树</a> )</h4><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><pre><code>1</code></pre><p>   / \<br>  2   2<br> / \ / \<br>3  4 4  3<br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><pre><code>1</code></pre><p>   / \<br>  2   2<br>   \   \<br>   3    3</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,null,<span class="number">3</span>,null,<span class="number">3</span>]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>递归根节点的左右子树：</p><ul><li>结束条件：<ul><li>当A和B都为空时，True</li><li>当A和B中有一个为空，或者A的值不等于B的值，False</li></ul></li><li>递归公式：继续调用左子树中的左子节点与右子树的右子节点。</li></ul><p>判断根节点是否为空然后调用调用递归函数传入根节点的左子树和右子树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(a, b)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> a == b: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> a <span class="keyword">or</span> <span class="keyword">not</span> b <span class="keyword">or</span> a.val != b.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> recur(a.left, b.right) <span class="keyword">and</span> recur(a.right, b.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bool(<span class="keyword">not</span> root) <span class="keyword">or</span> recur(root.left, root.right)</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-34-二叉树中和为某一值的路径-力扣（LeetCode）"><a href="#剑指-Offer-34-二叉树中和为某一值的路径-力扣（LeetCode）" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指 Offer 34. 二叉树中和为某一值的路径 - 力扣（LeetCode）</a></h4><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p>输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22<br>输出：[[5,4,11,2],[5,8,4,5]]</p><p><strong>思路</strong></p><p>先序遍历二叉树，记录每个节点的值，判断到叶子节点时每个节点的和是否为target。</p><p>需要一个先序遍历的子函数，递归函数。</p><p>递归参数：当前节点以及前面已经记录的路径。</p><p>递归结束条件：当前节点为空时直接返回。</p><p>递归公式：若不为空，将当前节点的值加进路径矩阵，然后判断路径矩阵是否等于target以及当前节点是否为叶子节点，如果满足，将当前路径加进res中，再遍历其左右子树，最后遍历完之后记得将当前节点的值退出去。</p><p><strong>注意：res.append(p)，是将p对象加入到res中，后续p变化时，res中的p对象也会随之变化。正确的做法是：<code>res.append(list(p))</code>，相当于复制一个p加入到res中。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">path</span><span class="params">(r, p)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> r: <span class="keyword">return</span> </span><br><span class="line">            p.append(r.val)</span><br><span class="line">            <span class="keyword">if</span> sum(p) == target <span class="keyword">and</span> <span class="keyword">not</span> r.left <span class="keyword">and</span> <span class="keyword">not</span> r.right: </span><br><span class="line">                res.append(list(p))</span><br><span class="line">            path(r.left, p)</span><br><span class="line">            path(r.right, p)</span><br><span class="line">            p.pop()</span><br><span class="line"></span><br><span class="line">        path(root, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-54-二叉搜索树的第k大节点-力扣（LeetCode）"><a href="#剑指-Offer-54-二叉搜索树的第k大节点-力扣（LeetCode）" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 54. 二叉搜索树的第k大节点 - 力扣（LeetCode）</a></h4><p>给定一棵二叉搜索树，请找出其中第 <code>k</code> 大的节点的值。 </p><p><strong>示例 1:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">2</span>], k = <span class="number">1</span></span><br><span class="line">   <span class="number">3</span></span><br><span class="line">  / <span class="string">\</span></span><br><span class="line"> <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">  <span class="string">\</span></span><br><span class="line">   <span class="number">2</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>示例 2</strong>:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>], k = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">       <span class="number">5</span></span><br><span class="line"></span><br><span class="line">      / <span class="string">\</span></span><br><span class="line"></span><br><span class="line">     <span class="number">3</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line">    / <span class="string">\</span></span><br><span class="line"></span><br><span class="line">   <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"></span><br><span class="line">  /</span><br><span class="line"></span><br><span class="line"> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>二叉搜索树的中序遍历为递增序列，第k大的节点可转化为：求此树的中序遍历倒序的第k个节点。</p><p>递归：</p><ul><li>终止条件：当前节点为空时直接返回。</li><li>递归右子树</li><li>统计序号，当前k减1，判断k是够为0，为0则表示已经统计完成，<code>self.res = cur.val</code>。</li><li>递归左子树</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur <span class="keyword">or</span> <span class="keyword">not</span> self.k: <span class="keyword">return</span></span><br><span class="line">            dfs(cur.right)</span><br><span class="line">            <span class="comment"># if self.k == 0: return</span></span><br><span class="line">            self.k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>: self.res = cur.val</span><br><span class="line">            dfs(cur.left)</span><br><span class="line"></span><br><span class="line">        self.k = k</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先-力扣（LeetCode）"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先-力扣（LeetCode）" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）</a></h4><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt="img"> </p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">root</span> = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">5</span>], <span class="attr">p</span> = <span class="number">2</span>, <span class="attr">q</span> = <span class="number">8</span></span><br><span class="line">输出: <span class="number">6</span> </span><br><span class="line">解释: 节点 <span class="number">2</span> 和节点 <span class="number">8</span> 的最近公共祖先是 <span class="number">6</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">root</span> = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">5</span>], <span class="attr">p</span> = <span class="number">2</span>, <span class="attr">q</span> = <span class="number">4</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 节点 <span class="number">2</span> 和节点 <span class="number">4</span> 的最近公共祖先是 <span class="number">2</span>, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>最近公共祖先：即找到p和q的一个最近的节点使得p和q分别在该节点的左右子树。或者说，p为该节点，然后q为其左右子树中的一个，或者是，q为该节点，然后p为其左右子树中的一个。</p><p>二叉搜索树：每个节点的值都不一样并且对于任意节点左子树所有节点的数都比根节点小，右子树所有节点的值都比根节点大。</p><p>所以可以通过节点的值与根节点的值判断是不是在同一子树。如果是，继续查该子树，直到找到第一个节点使得p和q为该节点的左右子树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">elif</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>递归方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti<span class="number">-68</span>-i-er-cha-sou-suo-shu-de-zui-jin-g<span class="number">-7</span>/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-68-II-二叉树的最近公共祖先-力扣（LeetCode）"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先-力扣（LeetCode）" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">剑指 Offer 68 - II. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">root</span> = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="number">4</span>], <span class="attr">p</span> = <span class="number">5</span>, <span class="attr">q</span> = <span class="number">1</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 节点 <span class="number">5</span> 和节点 <span class="number">1</span> 的最近公共祖先是节点 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">root</span> = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="number">4</span>], <span class="attr">p</span> = <span class="number">5</span>, <span class="attr">q</span> = <span class="number">4</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 节点 <span class="number">5</span> 和节点 <span class="number">4</span> 的最近公共祖先是节点 <span class="number">5</span>。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>[思路](</strong><a href="https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/" target="_blank" rel="noopener">剑指 Offer 68 - II. 二叉树的最近公共祖先（DFS ，清晰图解） - 二叉树的最近公共祖先 - 力扣（LeetCode）</a> <strong>)</strong></p><p>二叉树没有特性了，没有通过节点的值判断是左右子树了。</p><p>dfs递推：</p><p>找出一个节点的左右子树的返回值，如果左右子树都为空，则返回空，如果左子树的返回值不为空返回左子树返回值，如果右子树的返回值不为空返回右子树的返回值，如果左右子树的返回值都不为空，则返回当前根节点。</p><p>结束条件： 若当前节点为空返回空，若当前节点为p则返回p，若当前节点为q则返回q。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(cur)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur <span class="keyword">or</span> cur == p <span class="keyword">or</span> cur == q: <span class="keyword">return</span> cur</span><br><span class="line">            left = recur(cur.left)</span><br><span class="line">            right = recur(cur.right)</span><br><span class="line">            <span class="keyword">if</span> left <span class="keyword">and</span> right: <span class="keyword">return</span> cur</span><br><span class="line">            <span class="keyword">if</span> left: <span class="keyword">return</span> left</span><br><span class="line">            <span class="keyword">if</span> right: <span class="keyword">return</span> right</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur(root)</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-37-序列化二叉树-力扣（LeetCode）"><a href="#剑指-Offer-37-序列化二叉树-力扣（LeetCode）" class="headerlink" title="剑指 Offer 37. 序列化二叉树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 37. 序列化二叉树 - 力扣（LeetCode）</a></h4><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p>提示：输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>示例：</strong> </p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg" alt="img"> </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,null,null,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,null,null,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>序列化：用一个双向队列保存每一层的所有节点，如果节点不为null，则将当前节点的值加入到res中，并且把他的左右子节点插入到双向队列的末尾，如果节点为null，则说明当前层的这个节点已经为null，所以直接把null加入到res中就行。</p><p>反序列化：同样用一个双向队列保存每一层的所有节点，并把当前的根节点插入到双向队列中，并且定义一个指针指向当前要处理data中的哪一个值，然后进入循环，只有双向队列不为空，就每次popleft出来一个，此时第一个data[i]表示的当前节点的左节点，然后i加1，表示当前节点的右节点，如果data[i]有值，说明当前节点有左右子节点，插入到双向队列中并且，构建左右子节点的关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""Encodes a tree to a single string.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        deque = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line">        deque.append(root)</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            node = deque.popleft()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                res.append(str(node.val))</span><br><span class="line">                deque.append(node.left)</span><br><span class="line">                deque.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="string">"null"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'['</span> + <span class="string">","</span>.join(res) + <span class="string">']'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        deque = collections.deque()</span><br><span class="line">        data, i = data[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">','</span>), <span class="number">1</span></span><br><span class="line">        root = TreeNode(int(data[<span class="number">0</span>]))</span><br><span class="line">        deque.append(root)</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            node = deque.popleft()</span><br><span class="line">            <span class="keyword">if</span> data[i] != <span class="string">"null"</span>:</span><br><span class="line">                node.left = TreeNode(int(data[i]))</span><br><span class="line">                deque.append(node.left)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> data[i] != <span class="string">"null"</span>:</span><br><span class="line">                node.right = TreeNode(int(data[i]))</span><br><span class="line">                deque.append(node.right)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># codec = Codec()</span></span><br><span class="line"><span class="comment"># codec.deserialize(codec.serialize(root))</span></span><br></pre></td></tr></table></figure><h4 id="95-不同的二叉搜索树-II-力扣（LeetCode）"><a href="#95-不同的二叉搜索树-II-力扣（LeetCode）" class="headerlink" title="95. 不同的二叉搜索树 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">95. 不同的二叉搜索树 II - 力扣（LeetCode）</a></h4><p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。 </p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：[[<span class="number">1</span>,null,<span class="number">2</span>,null,<span class="number">3</span>],[<span class="number">1</span>,null,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">1</span>,null,null,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,null,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[[1]]</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>二叉搜索树的关键性质就是根节点的值大于左子树所有节点的值，小于右子树所有节点的值，且左子树和右子树也同样为二叉搜索树。</p><p>所以我们可以枚举根节点的值为i，然后左子树的节点的集合就为1到i-1，右子树的所有集合就为i+1到n。而左右子树又可以递归生成。</p><p>我们得到左右子树所有的可能之后，然后遍历左右子树所有的可能，并且接在当前根节点的左右子节点上面就行。还是一个递归加回溯的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[Optional[TreeNode]]:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">genTrees</span><span class="params">(start, end)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> start &gt; end:</span><br><span class="line">                <span class="keyword">return</span> [<span class="literal">None</span>]</span><br><span class="line">            </span><br><span class="line">            allTrees = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end + <span class="number">1</span>):</span><br><span class="line">                leftTrees = genTrees(start, i - <span class="number">1</span>)</span><br><span class="line">                rightTrees = genTrees(i + <span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> leftTrees:</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> rightTrees:</span><br><span class="line">                        curRoot = TreeNode(i)</span><br><span class="line">                        curRoot.left = j</span><br><span class="line">                        curRoot.right = k</span><br><span class="line">                        allTrees.append(curRoot)</span><br><span class="line">            <span class="keyword">return</span> allTrees</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> genTrees(<span class="number">1</span>, n) <span class="keyword">if</span> n <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><h4 id="KMP介绍"><a href="#KMP介绍" class="headerlink" title="KMP介绍"></a>KMP介绍</h4><p>首先KMP算法名是由发明这算法的三个人的名字(Knuth, Morris, Pratt)首字母得到的。</p><p><strong>KMP主要运用在字符串的匹配上面</strong></p><p>例如，现在有一个文本串txt，和一个模式串pat。KMP就是从txt中找出一个子串与pat相同并返回其在txt中的起始下标。</p><p><strong>主要思想就是当字符串中出现不匹配的时候，可以从已经知道的之前已经匹配的文本内容，后面接着匹配，不用从头再进行匹配</strong>。</p><p>如何记录已经匹配的本文内容，是KMP的重点，这也就是next数组的作用，也称为前缀表。</p><h4 id="前缀表-next数组的含义"><a href="#前缀表-next数组的含义" class="headerlink" title="前缀表(next数组的含义)"></a>前缀表(next数组的含义)</h4><p>前缀表，又称为next数组。前缀表的作用就是：<strong>用来回退的，当文本串与模式串出现不匹配的时候，模式串会根据前缀表来判断从哪个字符开始继续判断，而不是从模式串的第一个字符开始判断</strong>。</p><p>通俗地说就是当某个字符匹配失败的时候，前缀表会告诉你下一步匹配，模式串应该跳到哪个位置开始继续匹配。</p><p>前缀表应该是一个与模式串pat长度相等的整数数组，前缀表中下标i的一个数字表示的是模式串前i个字符组成的字符串的<strong>最长相等前后缀。</strong></p><p>这里就要理解前后缀是什么含义？</p><h4 id="最长相等前后缀"><a href="#最长相等前后缀" class="headerlink" title="最长相等前后缀"></a>最长相等前后缀</h4><p><strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。</strong></p><p><strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。</strong></p><p>前缀表求的就是最长的相同前后缀的长度。</p><p>例如：</p><blockquote><p>‘a’ 的 最长相等前后缀就是 0</p><p>‘aa’ -&gt; 1</p><p>‘aab’ -&gt; 0</p><p>‘aaba’ -&gt; 1</p><p>‘aabaa’ -&gt; 2</p><p>‘aabaaf’ -&gt;0</p></blockquote><p>所以模式串’aabaaf’对应的next数组应该就是<code>[0, 1, 0, 1, 2, 0]</code>。</p><p><strong>用前缀表就可以告诉我们当前位置如果匹配失败，就可以跳到之前已经匹配过的地方继续开始匹配。</strong></p><p>例如：</p><blockquote><p>模式串’aabaaf’，当我们匹配到’f’这个字符的时候，出现了与文本串不匹配的现象，说明前面的’aabaa’都是与本文串前面的匹配的，那么，我们就看模式串的next数组中，f的前一个位置的数值为多少，就跳到哪个下标，继续开始匹配。简单的说就是：</p><p>‘f’前面的aa是匹配过的，并且相同，然后’aa’与前面的’’aa’又是相同的前后缀，所以：模式串可以直接从前面那个’aa’的后面那个b开始继续与本文串进行匹配。</p></blockquote><h4 id="如何得到这个next前缀表数组"><a href="#如何得到这个next前缀表数组" class="headerlink" title="如何得到这个next前缀表数组"></a>如何得到这个next前缀表数组</h4><p>构建next数组就是计算模式串pat中，最长相等前后缀的长度的过程，这里我们定义两个指针 i 和 j，j指向最长相等前后缀的前缀里面的最后一个元素的位置，因为最开始只有一个字符，所以初始化<code>j = 0</code>，然后表示指针<code>i</code>从第2个元素即下标1开始向后遍历，这个过程主要分为三个部分：</p><ol><li>next数组初始化，j的初始化为0，i从下标1开始向后遍历</li><li>当前的 i 和 j 指向的字符不相同，即前后缀不相同。 这个时候得把j指针回退，即j向前动</li><li>当前的 i 和 j 指向的字符相同，即前后缀相同。j 向后挪动一位</li></ol><p><strong>初始化</strong></p><p>定义两个指针，i 和 j， j 指向前缀末尾的位置，i 指向后缀末尾的位置。</p><p>然后对next数组进行初始化配置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j = <span class="number">0</span></span><br><span class="line">next = [<span class="number">0</span>] * len(pat)</span><br></pre></td></tr></table></figure><p><code>next[i]</code>表示i（包括i）之前最长相等的前后缀长度(其实就是j)</p><p>所以第一个元素的next初始化为0，表示没有最长相等的前后缀长度。</p><p><strong>当前的i和j指向的字符不同，说明当前的前后缀不同</strong></p><p>因为j初始化为0，所以i得从下标1开始向后遍历，然后每次比较<code>pat[i]</code>和<code>pat[j]</code>。如果不相同，说明遇到了前后缀末尾不相同的情况，此时j就要向前回退。</p><p>怎么回退呢？next[j]里面记录的是j（包括j）之前的子串的相同前后缀的长度。</p><p>那么<code>pat[i]</code>与<code>pat[j]</code>不相同，就是要找j前面的一个元素在next数组里的值，(也就是<code>next[j - 1]</code>)。</p><p>所以，处理前后缀不同的情况代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> pat[i] != pat[j]:  <span class="comment"># 前后缀不同</span></span><br><span class="line">    j = next[j - <span class="number">1</span>]  <span class="comment"># 向前回退</span></span><br></pre></td></tr></table></figure><p><strong>当前的i和j指向的字符相同，说明前后缀相同。</strong></p><p>如果<code>pat[i]</code>与<code>pat[j]</code>相同，那么就同时向后移动 i 和 j 说明找到了相同的前后缀，同时还要将j(前缀的长度)赋值给<code>next[i]</code>。因为<code>next[i]</code>要记录相同前后缀的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pat[i] == pat[j]:</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">next[i] = j</span><br></pre></td></tr></table></figure><p><strong>最后构建next数组的函数代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNext</span><span class="params">(needle)</span>:</span></span><br><span class="line">            n, j = len(needle), <span class="number">0</span>  <span class="comment"># 初始化后缀的末尾端j的下标从0开始</span></span><br><span class="line">            next = [<span class="number">0</span>] * n  <span class="comment"># 初始化next数组的第1个元素的最长相等前后缀的长度为0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> needle[i] != needle[j]:  <span class="comment"># 前后缀的字符不相同的情况下</span></span><br><span class="line">                    j = next[j - <span class="number">1</span>]  <span class="comment"># 回退到前面一个字符</span></span><br><span class="line">                <span class="keyword">if</span> needle[i] == needle[j]:  <span class="comment"># 前后缀的字符相同的情况下</span></span><br><span class="line">                    j += <span class="number">1</span>  <span class="comment"># j和i同时往后挪动一位</span></span><br><span class="line">                next[i] = j  <span class="comment"># 将当前最长相等前后缀的长度给next数组的下标为i的元素</span></span><br><span class="line">            <span class="keyword">return</span> next</span><br></pre></td></tr></table></figure><h4 id="使用next数组来做匹配"><a href="#使用next数组来做匹配" class="headerlink" title="使用next数组来做匹配"></a>使用next数组来做匹配</h4><p>在文本串txt中找是否出现了模式串pat。</p><p>定义两个下标 j 指向模式串起始位置，i 指向文本串的起始位置。</p><p>i 和 j 都是从下标0开始，i从0开始向后遍历，然后如果当前的文本串的i与模式串的j的字符相同，那么i和j都同时向后移动，如果不同，则将模式串的j回退到前面一个匹配的字符的下标。</p><p>判断如果当前的j等于模式串的长度了，说for 明已经匹配完成了，可以直接返回当前文本串中的起始位置的下标了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(txt)):</span><br><span class="line">    <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> txt[i] != pat[j]:</span><br><span class="line">        j = next[j - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> txt[i] == pat[j]:</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">   <span class="keyword">if</span> j == len(pat):</span><br><span class="line">        <span class="keyword">return</span> i - j + <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="KMP复杂度"><a href="#KMP复杂度" class="headerlink" title="KMP复杂度"></a>KMP复杂度</h4><p>其中n为文本串的长度，m为模式串的长度。因为在匹配的过程中，根据前缀表不断调整匹配的位置，所以匹配的过程是O(n)，然后之前单独根据模式串生成一个next数组，时间复杂度为O(m)，所以整个KMP算法的时间复杂度为O(n + m)。</p><p>空间复杂度为O(m)，其中m是模式串pat的长度，得到next数组的空间大小。</p><h4 id="28-实现-strStr-力扣（LeetCode）"><a href="#28-实现-strStr-力扣（LeetCode）" class="headerlink" title="28. 实现 strStr() - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/implement-strstr/" target="_blank" rel="noopener">28. 实现 strStr() - 力扣（LeetCode）</a></h4><p>实现 strStr() 函数。</p><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p><p>说明：</p><p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">haystack</span> = <span class="string">"hello"</span>, <span class="attr">needle</span> = <span class="string">"ll"</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">haystack</span> = <span class="string">"aaaaa"</span>, <span class="attr">needle</span> = <span class="string">"bba"</span></span><br><span class="line">输出：-<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>标准KMP算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle <span class="keyword">or</span> haystack == needle: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getNext</span><span class="params">(needle)</span>:</span></span><br><span class="line">            n, j = len(needle), <span class="number">0</span>  <span class="comment"># 初始化后缀的末尾端j的下标从0开始</span></span><br><span class="line">            next = [<span class="number">0</span>] * n  <span class="comment"># 初始化next数组的第1个元素的最长相等前后缀的长度为0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> needle[i] != needle[j]:  <span class="comment"># 前后缀的字符不相同的情况下</span></span><br><span class="line">                    j = next[j - <span class="number">1</span>]  <span class="comment"># 回退到前面一个字符</span></span><br><span class="line">                <span class="keyword">if</span> needle[i] == needle[j]:  <span class="comment"># 前后缀的字符相同的情况下</span></span><br><span class="line">                    j += <span class="number">1</span>  <span class="comment"># j和i同时往后挪动一位</span></span><br><span class="line">                next[i] = j  <span class="comment"># 将当前最长相等前后缀的长度给next数组的下标为i的元素</span></span><br><span class="line">            <span class="keyword">return</span> next</span><br><span class="line">            </span><br><span class="line">        next = getNext(needle)  <span class="comment"># 获得next数组</span></span><br><span class="line">        j = <span class="number">0</span>  <span class="comment"># 模式串从0开始</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(haystack)):  <span class="comment"># 本文串从0开始</span></span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> haystack[i] != needle[j]:  <span class="comment"># 如果当前的文本串和模式串的字符不同，将模式串的j回退到前面相同的位置</span></span><br><span class="line">                j = next[j - <span class="number">1</span>]  <span class="comment"># 回退</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[j]:  <span class="comment"># 如果当前的文本串和模式串相同，则j向后挪动一位</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> j == len(needle):  <span class="comment"># j的长度等于模式串的长度说明已经全部匹配完成</span></span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span>  <span class="comment"># 返回结果</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集是一种树型的数据结构、用于处理一些不相交集合的合并和查询问题。主要操作有两种：合并和查询</p><ol><li>根据两个元素的关系合并两个集合；</li><li>查询两个元素是否存在关系(是否在同一个集合中)和查询节点的根节点。</li></ol><p><strong>一般求有连通字样、图论连接所有点这种题一般都是并查集</strong></p><h5 id="1、合并"><a href="#1、合并" class="headerlink" title="1、合并"></a>1、合并</h5><pre><code>给定元素关系，将一个集合的树变为另一个集合的子（将一个集合的根节点的父节点改为另一个集合的根节点），如B的根节点等于A的根节点，就可以将A和B两棵树合并为一棵树。</code></pre><h5 id="2、查询"><a href="#2、查询" class="headerlink" title="2、查询"></a>2、查询</h5><p>判断两个元素是否在同一个集合中：</p><pre><code>从该元素开始访问父节点(一般用递归查找)，直到一步步访问根节点，在对两个元素的根节点进行对比判断(若两个元素的根节点相同则属于同一集合，否则不属于同一集合)</code></pre><p><a href="https://leetcode.cn/problems/number-of-provinces/solution/python-duo-tu-xiang-jie-bing-cha-ji-by-m-vjdr/" target="_blank" rel="noopener">[Python/C++/Java] 多图详解并查集 - 省份数量 - 力扣（LeetCode）</a> </p><h5 id="总结概念："><a href="#总结概念：" class="headerlink" title="总结概念："></a>总结概念：</h5><ol><li>并查集是一种数据结构</li><li>并查集就是代表：合并(Union)、查(find)、集(Set)，代表这是一个以字典为基础的数据结构，它的基本功能是合并集合中的元素，查找集合中的元素。</li><li>并查集的典型应用是有关连通分量的问题。</li><li>并查集解决单个问题(添加、合并、查找)的时间复杂度都为O(1)</li></ol><h5 id="并查集的实现"><a href="#并查集的实现" class="headerlink" title="并查集的实现"></a>并查集的实现</h5><p>数据结构</p><p>并查集跟树类似，只不过跟树是相反的，在树这个数据结构里面，每个节点会记录它的子节点。在并查集里，每个节点会记录它的父节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        记录每个节点的父节点</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.father = &#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic.leetcode-cn.com/1609980000-ofFjdW-%E5%B9%BB%E7%81%AF%E7%89%871.JPG" alt></p><p>如果节点之间是相互连通的(从一个节点可以到达另外一个节点)，那么他们在同一棵树里。或者说在同一个集合里，或者说他们的祖先是相同的。</p><p><strong>初始化：把一个新的节点添加到并查集中，它的父节点应该为空</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    添加新节点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> self.father:</span><br><span class="line">        self.father[x] = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><strong>合并两个节点，如果两个节点是连通的，那么就要把他们合并，也就是他们的祖先是相同的，这里无论把谁当成父节点一般都是没有区别的</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, x, y, val)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    合并两个节点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    root_x, root_y = self.find(x), self.find(y)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> root_x != root_y:</span><br><span class="line">        self.father[root_x] = root_y</span><br></pre></td></tr></table></figure><p><strong>判断两个节点是否连通，就是需要判断他们的祖先是否相同</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_connected</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    判断两节点是否相连</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> self.find(x) == self.find(y)</span><br></pre></td></tr></table></figure><p><strong>查找祖先：如果节点的父节点不为空，那就一直迭代</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    查找根节点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    root = x</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> self.father[root] != <span class="literal">None</span>:</span><br><span class="line">        root = self.father[root]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>这里有一点可以优化：如果这个并查集的树很深，这就会退化成一个链表，每次查询的效率都会非常低，所以我们只要做一下路径压缩，也就是把树的深度固定为2。</p><p>这样可行的原因是：并查集只是记录了节点之间的连通关系，而节点相互连通只需要一个相同的祖先就可以了。</p><p>路径压缩可以用递归，也可以用迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    查找根节点</span></span><br><span class="line"><span class="string">    路径压缩</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    root = x</span><br><span class="line">    <span class="keyword">while</span> self.father[root] != <span class="literal">None</span>:</span><br><span class="line">        root = self.father[root]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 路径压缩</span></span><br><span class="line">    <span class="keyword">while</span> x != root:</span><br><span class="line">        original_father = self.father[x]</span><br><span class="line">        self.father[x] = root</span><br><span class="line">        x = original_father</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>完整模板</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        记录每个节点的父节点</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.father = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        查找根节点</span></span><br><span class="line"><span class="string">        路径压缩</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        root = x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.father[root] != <span class="literal">None</span>:</span><br><span class="line">            root = self.father[root]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 路径压缩</span></span><br><span class="line">        <span class="keyword">while</span> x != root:</span><br><span class="line">            original_father = self.father[x]</span><br><span class="line">            self.father[x] = root</span><br><span class="line">            x = original_father</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self,x,y,val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        合并两个节点</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        root_x,root_y = self.find(x),self.find(y)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root_x != root_y:</span><br><span class="line">            self.father[root_x] = root_y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_connected</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        判断两节点是否相连</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.find(x) == self.find(y)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        添加新节点</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> self.father:</span><br><span class="line">            self.father[x] = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h4 id="547-剑指Offer116-省份数量-力扣（LeetCode）"><a href="#547-剑指Offer116-省份数量-力扣（LeetCode）" class="headerlink" title="547(剑指Offer116). 省份数量 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/number-of-provinces/" target="_blank" rel="noopener">547(剑指Offer116). 省份数量 - 力扣（LeetCode）</a></h4><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：isConnected = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：isConnected = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><ol><li>这个题目就是在考察连通分量的数目，所以需要在模板中额外添加一个变量去跟踪集合的数量(树的数量)</li><li>初始化的时候把集合数量加1</li><li>合并的时候让集合数量减1</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.father = &#123;&#125;</span><br><span class="line">        <span class="comment"># 额外记录集合的数量</span></span><br><span class="line">        self.num_of_sets = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        root = x</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> self.father[root] != <span class="literal">None</span>:</span><br><span class="line">            root = self.father[root]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> x != root:</span><br><span class="line">            original_father = self.father[x]</span><br><span class="line">            self.father[x] = root</span><br><span class="line">            x = original_father</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line">        root_x,root_y = self.find(x),self.find(y)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root_x != root_y:</span><br><span class="line">            self.father[root_x] = root_y</span><br><span class="line">            <span class="comment"># 集合的数量-1</span></span><br><span class="line">            self.num_of_sets -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> self.father:</span><br><span class="line">            self.father[x] = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 集合的数量+1</span></span><br><span class="line">            self.num_of_sets += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        uf = UnionFind()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(M)):</span><br><span class="line">            uf.add(i)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> M[i][j]:</span><br><span class="line">                    uf.merge(i,j)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> uf.num_of_sets</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录父节点</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,Integer&gt; father;</span><br><span class="line">    <span class="comment">// 记录集合的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfSets = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        father = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        numOfSets = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!father.containsKey(x)) &#123;</span><br><span class="line">            father.put(x, <span class="keyword">null</span>);</span><br><span class="line">            numOfSets++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = find(y);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rootX != rootY)&#123;</span><br><span class="line">            father.put(rootX,rootY);</span><br><span class="line">            numOfSets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(father.get(root) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = father.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(x != root)&#123;</span><br><span class="line">            <span class="keyword">int</span> original_father = father.get(x);</span><br><span class="line">            father.put(x,root);</span><br><span class="line">            x = original_father;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfSets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfSets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; isConnected.length;i++)&#123;</span><br><span class="line">            uf.add(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isConnected[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    uf.merge(i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> uf.getNumOfSets();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：musiala</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/number-of-provinces/solution/python-duo-tu-xiang-jie-bing-cha-ji-by-m-vjdr/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="1319-连通网络的操作次数-力扣（LeetCode）"><a href="#1319-连通网络的操作次数-力扣（LeetCode）" class="headerlink" title="1319. 连通网络的操作次数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/number-of-operations-to-make-network-connected/" target="_blank" rel="noopener">1319. 连通网络的操作次数 - 力扣（LeetCode）</a></h4><p>用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b。</p><p>网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。</p><p>给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_1_1677.png" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, connections = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：拔下计算机 <span class="number">1</span> 和 <span class="number">2</span> 之间的线缆，并将它插到计算机 <span class="number">1</span> 和 <span class="number">3</span> 上。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_2_1677.png" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, connections = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, connections = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：线缆数量不足。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, connections = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>并查集模板题</p><p>当计算机的数量为n时，我们至少需要n-1根线才能将他们进行连接。如果线的数量少于n-1，就无论如何都无法将这n台计算机进行连接。</p><p>可以使用并查集来得到图中连通分量数。</p><p>并查集本身就是用来维护连通性的数据结构。如果其中包含n个节点，那么初始时连通分量数为n，每成功进行一次合并操作，连通分量数就会减少1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 并查集模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n: int)</span>:</span></span><br><span class="line">        self.parent = list(range(n))</span><br><span class="line">        self.size = [<span class="number">1</span>] * n</span><br><span class="line">        self.n = n</span><br><span class="line">        <span class="comment"># 当前连通分量数目</span></span><br><span class="line">        self.setCount = n</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findset</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.parent[x] == x:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        self.parent[x] = self.findset(self.parent[x])</span><br><span class="line">        <span class="keyword">return</span> self.parent[x]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unite</span><span class="params">(self, x: int, y: int)</span> -&gt; bool:</span></span><br><span class="line">        x, y = self.findset(x), self.findset(y)</span><br><span class="line">        <span class="keyword">if</span> x == y:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> self.size[x] &lt; self.size[y]:</span><br><span class="line">            x, y = y, x</span><br><span class="line">        self.parent[y] = x</span><br><span class="line">        self.size[x] += self.size[y]</span><br><span class="line">        self.setCount -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connected</span><span class="params">(self, x: int, y: int)</span> -&gt; bool:</span></span><br><span class="line">        x, y = self.findset(x), self.findset(y)</span><br><span class="line">        <span class="keyword">return</span> x == y</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">makeConnected</span><span class="params">(self, n: int, connections: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(connections) &lt; n - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        uf = UnionFind(n)</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> connections:</span><br><span class="line">            uf.unite(x, y)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> uf.setCount - <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h2><p><code>set()</code>集合的底层实现是一张哈希表，哈希表内只存储单一的元素，当要在该set中插入一个数据时，首先会通过hash函数，计算该元素对应的哈希值，然后在根据hash值插入到哈希表中的位置。</p><p>如果哈希表中这个位置是空的，就直接插入，若这个位置被其他元素占用，就会判断两个元素的哈希值是否相等：</p><ul><li>若相等，则表明该元素已存在，比较他们的值，相等就去重，不想等就更新。</li><li>如果不想等，这种情况为哈希冲突（两个元素的键不同，哈希值相同）。这种情况，python会使用开放定址法、再哈希法等继续寻找哈希表中的空余位置，直到找到位置。</li></ul><p>set的去重是通过两个函数<code>__hash__</code>和<code>__eq__</code>结合实现的：</p><ul><li>当两个元素的哈希值不同时，就认为两个变量是不同的。</li><li>当两个元素的哈希值相同时，调用<code>__eq__</code>方法，返回True时认为两个变量是同一个，返回false不去重。</li></ul><p><strong>set和dict的原理是一样的，唯一区别在于没有存储对应的value，都不能放入可变对象，比如list。dict的key必须是不可变对象，如字符串</strong>、</p><p><strong>list和tuple的区别在于，list是可变的，tuple是不可变的，一旦初始化之后就不能更改，但是tuple里面的元素可以为list，这个里面的list是可变的</strong></p><h4 id="12-整数转罗马数字-力扣（LeetCode）"><a href="#12-整数转罗马数字-力扣（LeetCode）" class="headerlink" title="12. 整数转罗马数字 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/integer-to-roman/" target="_blank" rel="noopener">12. 整数转罗马数字 - 力扣（LeetCode）</a></h4><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给你一个整数，将其转为罗马数字。</p><p><strong>示例 1:</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="built_in">num</span> = <span class="number">3</span></span><br><span class="line">输出: <span class="string">"III"</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">num</span> = <span class="number">58</span></span><br><span class="line">输出: <span class="string">"LVIII"</span></span><br><span class="line">解释: <span class="attr">L</span> = <span class="number">50</span>, <span class="attr">V</span> = <span class="number">5</span>, <span class="attr">III</span> = <span class="number">3</span>.</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">num</span> = <span class="number">1994</span></span><br><span class="line">输出: <span class="string">"MCMXCIV"</span></span><br><span class="line">解释: <span class="attr">M</span> = <span class="number">1000</span>, <span class="attr">CM</span> = <span class="number">900</span>, <span class="attr">XC</span> = <span class="number">90</span>, <span class="attr">IV</span> = <span class="number">4</span>.</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    symbol = [(<span class="number">1000</span>, <span class="string">'M'</span>),</span><br><span class="line">            (<span class="number">900</span>, <span class="string">'CM'</span>),</span><br><span class="line">            (<span class="number">500</span>, <span class="string">'D'</span>),</span><br><span class="line">            (<span class="number">400</span>, <span class="string">'CD'</span>),</span><br><span class="line">            (<span class="number">100</span>, <span class="string">'C'</span>),</span><br><span class="line">            (<span class="number">90</span>, <span class="string">'XC'</span>),</span><br><span class="line">            (<span class="number">50</span>, <span class="string">'L'</span>),</span><br><span class="line">            (<span class="number">40</span>, <span class="string">'XL'</span>),</span><br><span class="line">            (<span class="number">10</span>, <span class="string">'X'</span>),</span><br><span class="line">            (<span class="number">9</span>, <span class="string">'IX'</span>),</span><br><span class="line">            (<span class="number">5</span>, <span class="string">'V'</span>),</span><br><span class="line">            (<span class="number">4</span>, <span class="string">'IV'</span>),</span><br><span class="line">            (<span class="number">1</span>, <span class="string">'I'</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line"></span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> value, s <span class="keyword">in</span> Solution.symbol:</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= value):</span><br><span class="line">                num -= value</span><br><span class="line">                res += s</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="13-罗马数字转整数-力扣（LeetCode）"><a href="#13-罗马数字转整数-力扣（LeetCode）" class="headerlink" title="13. 罗马数字转整数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/roman-to-integer/" target="_blank" rel="noopener">13. 罗马数字转整数 - 力扣（LeetCode）</a></h4><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。 </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             <span class="number">1</span></span><br><span class="line">V             <span class="number">5</span></span><br><span class="line">X             <span class="number">10</span></span><br><span class="line">L             <span class="number">50</span></span><br><span class="line">C             <span class="number">100</span></span><br><span class="line">D             <span class="number">500</span></span><br><span class="line">M             <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。</p><p> <strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = "III"</span></span><br><span class="line"><span class="section">输出: 3</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">"LVIII"</span></span><br><span class="line">输出: <span class="number">58</span></span><br><span class="line">解释: <span class="attr">L</span> = <span class="number">50</span>, <span class="attr">V=</span> <span class="number">5</span>, <span class="attr">III</span> = <span class="number">3</span>.</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">"MCMXCIV"</span></span><br><span class="line">输出: <span class="number">1994</span></span><br><span class="line">解释: <span class="attr">M</span> = <span class="number">1000</span>, <span class="attr">CM</span> = <span class="number">900</span>, <span class="attr">XC</span> = <span class="number">90</span>, <span class="attr">IV</span> = <span class="number">4</span>.</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><p>直接模拟</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    symbol = &#123;<span class="string">'M'</span>: <span class="number">1000</span>,</span><br><span class="line">            <span class="string">'CM'</span>: <span class="number">900</span>,</span><br><span class="line">            <span class="string">'D'</span>: <span class="number">500</span>,</span><br><span class="line">            <span class="string">'CD'</span>: <span class="number">400</span>,</span><br><span class="line">            <span class="string">'C'</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="string">'XC'</span>: <span class="number">90</span>,</span><br><span class="line">            <span class="string">'L'</span>: <span class="number">50</span>,</span><br><span class="line">            <span class="string">'XL'</span>: <span class="number">40</span>,</span><br><span class="line">            <span class="string">'X'</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="string">'IX'</span>: <span class="number">9</span>,</span><br><span class="line">            <span class="string">'V'</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">'IV'</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="string">'I'</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        ans, s, i = <span class="number">0</span>, list(s), <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'C'</span>:</span><br><span class="line">                <span class="keyword">if</span> i + <span class="number">1</span> &lt; len(s) <span class="keyword">and</span> (s[i + <span class="number">1</span>] == <span class="string">'D'</span> <span class="keyword">or</span> s[i + <span class="number">1</span>] == <span class="string">'M'</span>):</span><br><span class="line">                    ans += Solution.symbol[<span class="string">''</span>.join(s[i:(i + <span class="number">2</span>)])]</span><br><span class="line">                    i += <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans += Solution.symbol[s[i]]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'X'</span>:</span><br><span class="line">                <span class="keyword">if</span> i + <span class="number">1</span> &lt; len(s) <span class="keyword">and</span> (s[i + <span class="number">1</span>] == <span class="string">'C'</span> <span class="keyword">or</span> s[i + <span class="number">1</span>] == <span class="string">'L'</span>):</span><br><span class="line">                    ans += Solution.symbol[<span class="string">''</span>.join(s[i:(i + <span class="number">2</span>)])]</span><br><span class="line">                    i += <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans += Solution.symbol[s[i]]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'I'</span>:</span><br><span class="line">                <span class="keyword">if</span> i + <span class="number">1</span> &lt; len(s) <span class="keyword">and</span> (s[i + <span class="number">1</span>] == <span class="string">'X'</span> <span class="keyword">or</span> s[i + <span class="number">1</span>] == <span class="string">'V'</span>):</span><br><span class="line">                    ans += Solution.symbol[<span class="string">''</span>.join(s[i:(i + <span class="number">2</span>)])]</span><br><span class="line">                    i += <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans += Solution.symbol[s[i]]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'M'</span>:</span><br><span class="line">                ans, i = ans + <span class="number">1000</span>, i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'D'</span>:</span><br><span class="line">                ans, i = ans + <span class="number">500</span>, i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'L'</span>:</span><br><span class="line">                ans, i = ans + <span class="number">50</span>, i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'V'</span>:</span><br><span class="line">                ans, i = ans + <span class="number">5</span>, i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>可以判断后面一个字符的值是否比当前的大，如果大，可以通过减法减去当前字符的值。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    SYMBOL_VALUES = &#123;</span><br><span class="line">        <span class="string">'I'</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">'V'</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">'X'</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="string">'L'</span>: <span class="number">50</span>,</span><br><span class="line">        <span class="string">'C'</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="string">'D'</span>: <span class="number">500</span>,</span><br><span class="line">        <span class="string">'M'</span>: <span class="number">1000</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            value = Solution.SYMBOL_VALUES[ch]</span><br><span class="line">            <span class="keyword">if</span> i &lt; n - <span class="number">1</span> <span class="keyword">and</span> value &lt; Solution.SYMBOL_VALUES[s[i + <span class="number">1</span>]]:</span><br><span class="line">                ans -= value</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += value</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode.cn/problems/roman-to-integer/solution/luo-ma-shu-zi-zhuan-zheng-shu-by-leetcod-w55p/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ol><li>set和dict的key都必须是不可变变量，两个的底层数据结构都是字典。</li><li>需要去重的时候都应该想到set，set里面的元素不是有序的。</li></ol><h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>参考文献： <a href="https://www.cnblogs.com/wuxinyan/p/8615127.html" target="_blank" rel="noopener">python 十大经典排序算法 - wuxinyan - 博客园 (cnblogs.com)</a> </p><table><thead><tr><th style="text-align:center">排序算法</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最坏情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">排序方式</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">$O(n^{2})$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^{2})$</td><td style="text-align:center">O(1)</td><td style="text-align:center">In-place</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center">$O(n^{2})$</td><td style="text-align:center">$O(n^{2})$</td><td style="text-align:center">$O(n^{2})$</td><td style="text-align:center">O(1)</td><td style="text-align:center">In-place</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center">$O(n^{2})$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^{2})$</td><td style="text-align:center">O(1)</td><td style="text-align:center">In-place</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">$O(n log n)$</td><td style="text-align:center">$O(n log^{2} n)$</td><td style="text-align:center">$O(n log^{2} n)$</td><td style="text-align:center">O(1)</td><td style="text-align:center">In-place</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">$O(n log n)$</td><td style="text-align:center">$O(n log n)$</td><td style="text-align:center">$O(n log n)$</td><td style="text-align:center">O(n)</td><td style="text-align:center">Out-place</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">$O(n log n)$</td><td style="text-align:center">$O(n log n)$</td><td style="text-align:center">$O(n^{2})$</td><td style="text-align:center">O(1)</td><td style="text-align:center">In-place</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">$O(n log n)$</td><td style="text-align:center">$O(n log n)$</td><td style="text-align:center">$O(n log n)$</td><td style="text-align:center">O(1)</td><td style="text-align:center">In-place</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">计数排序</td><td style="text-align:center">$O(n + k)$</td><td style="text-align:center">$O(n + k)$</td><td style="text-align:center">$O(n + k)$</td><td style="text-align:center">$O(k)$</td><td style="text-align:center">Out-place</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">桶排序</td><td style="text-align:center">$O(n + k)$</td><td style="text-align:center">$O(n + k)$</td><td style="text-align:center">$O(n^{2})$</td><td style="text-align:center">$O(n + k)$</td><td style="text-align:center">Out-place</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">基数排序</td><td style="text-align:center">$O(n \times k)$</td><td style="text-align:center">$O(n \times k)$</td><td style="text-align:center">$O(n \times k)$</td><td style="text-align:center">$O(n + k)$</td><td style="text-align:center">Out-place</td><td style="text-align:center">稳定</td></tr></tbody></table><p><strong>n: 数据大小，k：桶的个数， In-place：占用常数内存或不占用额外内存。Out-place：占用额外内存，稳定性：排序后2个相等键值的顺序和排序之前他们的顺序相同</strong></p><h4 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h4><p><strong>算法步骤：</strong></p><ol><li>比较相邻元素，如果前面大于后面的，交换，俗称：重的向下沉。</li><li>对每一对相邻元素作相同的操作，第一遍之后，最大的数就在最后面了。</li><li>针对所有元素重复上面的步骤，除了最后一个。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(arr)-i):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>选择排序无论什么数据范围都是$O(n^{2})$的时间复杂度。所以用他的时候数据范围越小越好。唯一的好处就是不占用额外的内存空间。</p><p><strong>算法步骤</strong></p><p>每次在剩下的序列中找到最小(最大)的元素，存放到序列的最前面(最后面)。一直重复这样的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr) - <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 记录最小数的索引</span></span><br><span class="line">        minIndex = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(arr)):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[minIndex]:</span><br><span class="line">                minIndex = j</span><br><span class="line">        <span class="comment"># i 不是最小数时，将 i 和最小数进行交换</span></span><br><span class="line">        <span class="keyword">if</span> i != minIndex:</span><br><span class="line">            arr[i], arr[minIndex] = arr[minIndex], arr[i]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>工作原理：通过构建有序序列，对于未排序的数据，在已排序序列中从后向前面扫描，找到相应位置并插入。</p><p><strong>算法步骤：</strong></p><ol><li>将待排序序列的第一个元素作为一个有序序列，把第二个元素看到最后一个元素看成是未排序序列。</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入到有序序列的适当位置，(如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面)。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        preIndex = i<span class="number">-1</span></span><br><span class="line">        current = arr[i]</span><br><span class="line">        <span class="keyword">while</span> preIndex &gt;= <span class="number">0</span> <span class="keyword">and</span> arr[preIndex] &gt; current:</span><br><span class="line">            arr[preIndex+<span class="number">1</span>] = arr[preIndex]</span><br><span class="line">            preIndex-=<span class="number">1</span></span><br><span class="line">        arr[preIndex+<span class="number">1</span>] = current</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>也称为递减增量排序算法，是插入排序的一种更高效的改进版本。但是希尔排序是不稳定的排序算法。</p><p>主要思想：根据一定的增量(分组的跨度)分割序列，各子序列使用插入排序，然后再逐渐减少增量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line">grap=len(arr)//<span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> grap&gt;<span class="number">0</span>:</span><br><span class="line"><span class="comment">#相当于跨度为grap的插入排序</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(grap,len(arr)):</span><br><span class="line">current=arr[i]</span><br><span class="line">pre_index=i-grap</span><br><span class="line"><span class="comment">#两两比较，大的后移，找到插入点，插入当前元素</span></span><br><span class="line"><span class="keyword">while</span> pre_index&gt;=<span class="number">0</span> <span class="keyword">and</span> arr[pre_index]&gt;current:</span><br><span class="line">arr[pre_index+grap]=arr[pre_index]</span><br><span class="line">pre_index-=grap</span><br><span class="line">arr[pre_index+grap]=current</span><br><span class="line"><span class="comment">#逐渐减小跨度（跨度为1时为插入排序）</span></span><br><span class="line">grap//=<span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并是分治法的一个非常典型的应用。作为一种典型的分而治之的算法思想，归并排序的实现由两种方法：</p><ul><li>自上而下的递归</li><li>自下而上的迭代</li></ul><p>归并排序始终是$O(n log n)$的时间复杂度，代价是需要额外的内存空间。</p><p><strong>算法步骤：</strong></p><p>每次都将当前的待排序数列一分为二，直到每个序列只剩下一个元素，然后再将当前的两个序列进行合并。</p><p>每一趟的归并的时间复杂度为O(n)，总共需要归并$O(log n)$趟，归并排序终需要一个与表等长的存储单元数组空间，空间复杂度O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    mid = len(arr) // <span class="number">2</span></span><br><span class="line">    <span class="comment"># left, right = arr[0:mid], arr[mid:]</span></span><br><span class="line">    left, right = self.merge_sort(arr[<span class="number">0</span>:mid]), self.merge_sort(arr[mid:])</span><br><span class="line"></span><br><span class="line">    ilist = []</span><br><span class="line">    <span class="keyword">while</span> right <span class="keyword">and</span> left:</span><br><span class="line">        <span class="keyword">if</span> left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]:</span><br><span class="line">            ilist.append(left.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ilist.append(right.pop(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    ilist.extend(right <span class="keyword">if</span> right <span class="keyword">else</span> left)</span><br><span class="line">    <span class="keyword">return</span> ilist</span><br></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序是最常用的排序，该方法使用分治法策略把一个串行(list)分为两个子串行(sub-lists)。</p><ol><li>从数列中挑出一个元素，称为“基准” (pivot)，该基准数往往取第一个或者是最后一个。</li><li>重新排列数列，所有元素比基准小的摆放在基准前面，所有元素比基准大的摆在基准的后面(相同的数可以到任意一边)。在这个分区退出之后，该基准就处于数列的中间位置，这个称为分区(partition)操作；</li><li>递归地(recursive)把小于基准值元素的子数列和大于基准元素的子数列排序。</li></ol><p>快速排序的平均时间复杂度为O(n log n)，当序列有序或者基本有序时，快排的时间复杂度会退化为$O(n ^ {2})$，（每次找到的都是边界上的元素的位置）</p><p>空间复杂度为$O(log n)$，递归栈的深度。</p><p><strong>快速的写法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        left = []</span><br><span class="line">        right = []</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> arr[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> n &lt;= arr[<span class="number">0</span>]:</span><br><span class="line">                left.append(n)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right.append(n)</span><br><span class="line">        <span class="keyword">return</span> self.quick_sort(left) + [arr[<span class="number">0</span>]] + self.quick_sort(right)</span><br></pre></td></tr></table></figure><p><strong>常规的写法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(arr, first, last)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> first &gt; last:  <span class="comment"># 递归结束条件</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    flagnum = arr[first]  <span class="comment"># 选取基准值</span></span><br><span class="line"></span><br><span class="line">    left = first+<span class="number">1</span>  <span class="comment"># 左右标初始化</span></span><br><span class="line">    right = last</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> arr[left] &lt;= flagnum:  <span class="comment"># 左标向右移动，直到找到比基准值大的数</span></span><br><span class="line">            left = left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> arr[right] &gt;= flagnum:  <span class="comment"># 右标向左移动，直到找到比基准值小的数</span></span><br><span class="line">            right = right<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:  <span class="comment"># 如果没有找到就退出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arr[left], arr[right] = arr[right], arr[left]  <span class="comment"># 将两个数交换然后左右标继续移动</span></span><br><span class="line">    arr[right], arr[first] = flagnum, arr[right]  <span class="comment"># 全部移动完成之后表示左标左边都比基准数小，右标右边都比基准数大，此时把中值就位</span></span><br><span class="line">    quickSort(arr, first, right<span class="number">-1</span>)  <span class="comment"># 对左右边的数列继续快排</span></span><br><span class="line">    quickSort(arr, right+<span class="number">1</span>, last)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort2</span><span class="params">(arr)</span>:</span>  <span class="comment"># 申请了额外的空间，但是看起来更简洁</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    left = []</span><br><span class="line">    right = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> arr[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">if</span> n &lt;= arr[<span class="number">0</span>]:</span><br><span class="line">            left.append(n)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right.append(n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quickSort2(left) + [arr[<span class="number">0</span>]] + quickSort2(right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(quickSort2([<span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序就是利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于(或者大于)它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ol><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li></ol><p>堆排序的平均时间复杂度$O(n log n)$</p><p><strong>算法步骤：</strong></p><ol><li>创建一个堆H[0….n-1];</li><li>把堆首(最大值)和堆尾互换；</li><li>把堆的尺寸缩小1，并调用shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li><li>重复步骤2，直到堆的尺寸为1。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapmax</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)//<span class="number">2</span><span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>): </span><br><span class="line">        self.modifyheap(nums,i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modifyheap</span><span class="params">(self,nums,i)</span>:</span>  </span><br><span class="line">    l = <span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">    r = <span class="number">2</span>*i+<span class="number">2</span></span><br><span class="line">    largest = i</span><br><span class="line">    <span class="keyword">if</span> l&lt;len(nums) <span class="keyword">and</span> nums[largest]&lt;nums[l]:</span><br><span class="line">        largest = l</span><br><span class="line">    <span class="keyword">if</span> r&lt;len(nums) <span class="keyword">and</span> nums[largest] &lt; nums[r]:</span><br><span class="line">        largest = r</span><br><span class="line">    <span class="keyword">if</span> largest!=i:</span><br><span class="line">        nums[i],nums[largest] = nums[largest],nums[i]</span><br><span class="line">        self.modifyheap(nums,largest)</span><br></pre></td></tr></table></figure><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countingSort</span><span class="params">(arr, maxValue)</span>:</span></span><br><span class="line">    bucketLen = maxValue+<span class="number">1</span></span><br><span class="line">    bucket = [<span class="number">0</span>]*bucketLen</span><br><span class="line">    sortedIndex =<span class="number">0</span></span><br><span class="line">    arrLen = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(arrLen):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> bucket[arr[i]]:</span><br><span class="line">            bucket[arr[i]]=<span class="number">0</span></span><br><span class="line">        bucket[arr[i]]+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(bucketLen):</span><br><span class="line">        <span class="keyword">while</span> bucket[j]&gt;<span class="number">0</span>:</span><br><span class="line">            arr[sortedIndex] = j</span><br><span class="line">            sortedIndex+=<span class="number">1</span></span><br><span class="line">            bucket[j]-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>桶排序利用函数的映射关系，高效与否的关键在于这个映射函数的确定。为了使桶排序更加高效，需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的N个数据均匀的分配到K个桶中。</li></ol><p><strong>什么时候最快</strong></p><p>当输入的数据可以均匀的分配到每一个桶中。</p><p><strong>什么时候最慢</strong></p><p>当输入的数据被分配到同一个桶中。</p><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p>基数排序有两种方法：</p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；</li></ul><h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randomList</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        arr = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            arr.append(random.randrange(<span class="number">100</span>))</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        冒泡排序：</span></span><br><span class="line"><span class="string">        时间复杂度：n^2</span></span><br><span class="line"><span class="string">        最差时间：n^2</span></span><br><span class="line"><span class="string">        空间复杂度：1</span></span><br><span class="line"><span class="string">        稳定</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        arr_len = len(arr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, arr_len):  <span class="comment"># important part</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, arr_len - i):  <span class="comment"># important part</span></span><br><span class="line">                <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                    arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        选择排序：</span></span><br><span class="line"><span class="string">        时间复杂度：n^2</span></span><br><span class="line"><span class="string">        最差时间：n^2</span></span><br><span class="line"><span class="string">        空间复杂度：1</span></span><br><span class="line"><span class="string">        不稳定</span></span><br><span class="line"><span class="string">        原理：先找到起始数组中最小的元素，将它交换到i=0；然后寻找剩下元素中最小的元素，</span></span><br><span class="line"><span class="string">        将它交换到i=1的位置……直到找到第二小的元素，将它交换到n-2的位置。这时，整个数组排序完成。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">selectSort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        arr_len = len(arr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(arr_len):</span><br><span class="line">            min_index = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, arr_len):</span><br><span class="line">                min_index = j <span class="keyword">if</span> arr[j] &lt; arr[min_index] <span class="keyword">else</span> min_index</span><br><span class="line">            arr[min_index], arr[i] = arr[i], arr[min_index]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        插入排序：</span></span><br><span class="line"><span class="string">        时间复杂度：n^2</span></span><br><span class="line"><span class="string">        最差时间：n^2</span></span><br><span class="line"><span class="string">        空间复杂度：1</span></span><br><span class="line"><span class="string">        稳定</span></span><br><span class="line"><span class="string">        原理：把左边第一个元素当成是已经排好序的序列，每次从后面的序列中选出一个数然后插入到左边已经排好序的序列中。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertSort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        arr_len = len(arr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, arr_len):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> arr[i] &lt; arr[j]:</span><br><span class="line">                    arr[j+<span class="number">1</span>:i+<span class="number">1</span>] = arr[j:i]</span><br><span class="line">                    arr[j] = arr[i]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        归并排序：</span></span><br><span class="line"><span class="string">        时间复杂度：nlog2(n)</span></span><br><span class="line"><span class="string">        最差时间：nlog2(n)</span></span><br><span class="line"><span class="string">        空间复杂度：额外的一半需要用来做归并，N</span></span><br><span class="line"><span class="string">        稳定</span></span><br><span class="line"><span class="string">        原理：对数组进行拆分再拆分，直到都只剩一个元素不能拆分为止，然后分别对拆分之后的左右序列进行合并，</span></span><br><span class="line"><span class="string">        然后再合并大一点的数组（合并之后的），直到最终合成一个最大的数组。分两个函数完成，一个负责拆分，一个排序合并。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(arr) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        mid = len(arr) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># left, right = arr[0:mid], arr[mid:]</span></span><br><span class="line">        left, right = self.merge_sort(arr[<span class="number">0</span>:mid]), self.merge_sort(arr[mid:])</span><br><span class="line"></span><br><span class="line">        ilist = []</span><br><span class="line">        <span class="keyword">while</span> right <span class="keyword">and</span> left:</span><br><span class="line">            <span class="keyword">if</span> left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]:</span><br><span class="line">                ilist.append(left.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ilist.append(right.pop(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">        ilist.extend(right <span class="keyword">if</span> right <span class="keyword">else</span> left)</span><br><span class="line">        <span class="keyword">return</span> ilist</span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        快速排序：</span></span><br><span class="line"><span class="string">        时间复杂度：nlog2(n)</span></span><br><span class="line"><span class="string">        最差时间：n^2</span></span><br><span class="line"><span class="string">        空间复杂度：nlog2(n)</span></span><br><span class="line"><span class="string">        不稳定 ，因为中值的选取如果导致一边始终没有数据的话，时间复杂度加上递归可能会比n^2还要差</span></span><br><span class="line"><span class="string">        原理：任意找一个数为基准数，一般是数列的第一个数，将序列以该基准元素为基准，分割成比它小的左边和比它大的右边，此时，该基准元素所在的位置就是</span></span><br><span class="line"><span class="string">        排序终了之后的准确位置，在对左右两边的序列继续执行同样的操作，直到整个序列有序。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        left = []</span><br><span class="line">        right = []</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> arr[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> n &lt;= arr[<span class="number">0</span>]:</span><br><span class="line">                left.append(n)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right.append(n)</span><br><span class="line">        <span class="keyword">return</span> self.quick_sort(left) + [arr[<span class="number">0</span>]] + self.quick_sort(right)</span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     first = arr[0]</span></span><br><span class="line">        <span class="comment">#     left = self.quick_sort([l for l in arr[1:] if l &lt; first])</span></span><br><span class="line">        <span class="comment">#     right = self.quick_sort([r for r in arr[1:] if r &gt; first])</span></span><br><span class="line">        <span class="comment">#     return left + [first] + right</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        希尔排序：</span></span><br><span class="line"><span class="string">        时间复杂度：nlog2(n)</span></span><br><span class="line"><span class="string">        最差时间：n^s   1&lt;s&lt;2 s是所选分组</span></span><br><span class="line"><span class="string">        空间复杂度：1</span></span><br><span class="line"><span class="string">        不稳定</span></span><br><span class="line"><span class="string">        原理：把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，</span></span><br><span class="line"><span class="string">        每组包含的关键词越来越多，当增量减少至1时，整个文件恰好被分成一组，算法终止。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        gap = len(arr)</span><br><span class="line">        <span class="keyword">while</span> gap &gt; <span class="number">1</span>:</span><br><span class="line">            gap = gap // <span class="number">2</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, len(arr)):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(i % gap, i, gap):</span><br><span class="line">                    <span class="keyword">if</span> arr[i] &lt; arr[j]:</span><br><span class="line">                        arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        堆排序：</span></span><br><span class="line"><span class="string">        时间复杂度：</span></span><br><span class="line"><span class="string">        最差时间：</span></span><br><span class="line"><span class="string">        空间复杂度：</span></span><br><span class="line"><span class="string">        不稳定</span></span><br><span class="line"><span class="string">        原理：</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        基数排序：</span></span><br><span class="line"><span class="string">        时间复杂度：</span></span><br><span class="line"><span class="string">        最差时间：</span></span><br><span class="line"><span class="string">        空间复杂度：</span></span><br><span class="line"><span class="string">        不稳定</span></span><br><span class="line"><span class="string">        原理：</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># write code here</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># num = list(map(lambda x: int(x), input().split(' ')))</span></span><br><span class="line">    arr_len = int(input())</span><br><span class="line">    num = Solution().randomList(arr_len)</span><br><span class="line">    print(str(num).replace(<span class="string">', '</span>, <span class="string">' '</span>).replace(<span class="string">'\''</span>, <span class="string">''</span>)[<span class="number">1</span>:<span class="number">-1</span>] + <span class="string">' '</span>)</span><br><span class="line">    bubble_num = Solution().bubble_sort(num)</span><br><span class="line">    print(<span class="string">"bubble: "</span> + str(bubble_num).replace(<span class="string">', '</span>, <span class="string">' '</span>).replace(<span class="string">'\''</span>, <span class="string">''</span>)[<span class="number">1</span>:<span class="number">-1</span>] + <span class="string">' '</span>)</span><br><span class="line">    select_num = Solution().selectSort(num)</span><br><span class="line">    print(<span class="string">"select: "</span> + str(select_num).replace(<span class="string">', '</span>, <span class="string">' '</span>).replace(<span class="string">'\''</span>, <span class="string">''</span>)[<span class="number">1</span>:<span class="number">-1</span>] + <span class="string">' '</span>)</span><br><span class="line">    insert_num = Solution().insertSort(num)</span><br><span class="line">    print(<span class="string">"insert: "</span> + str(insert_num).replace(<span class="string">', '</span>, <span class="string">' '</span>).replace(<span class="string">'\''</span>, <span class="string">''</span>)[<span class="number">1</span>:<span class="number">-1</span>] + <span class="string">' '</span>)</span><br><span class="line">    merge_num = Solution().merge_sort(num)</span><br><span class="line">    print(<span class="string">"merge: "</span> + str(merge_num).replace(<span class="string">', '</span>, <span class="string">' '</span>).replace(<span class="string">'\''</span>, <span class="string">''</span>)[<span class="number">1</span>:<span class="number">-1</span>] + <span class="string">' '</span>)</span><br><span class="line">    quick_num = Solution().quick_sort(num)</span><br><span class="line">    print(<span class="string">"quick: "</span> + str(quick_num).replace(<span class="string">', '</span>, <span class="string">' '</span>).replace(<span class="string">'\''</span>, <span class="string">''</span>)[<span class="number">1</span>:<span class="number">-1</span>] + <span class="string">' '</span>)</span><br><span class="line">    shell_num = Solution().shell_sort(num)</span><br><span class="line">    print(<span class="string">"shell: "</span> + str(shell_num).replace(<span class="string">', '</span>, <span class="string">' '</span>).replace(<span class="string">'\''</span>, <span class="string">''</span>)[<span class="number">1</span>:<span class="number">-1</span>] + <span class="string">' '</span>)</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-51-数组中的逆序对-力扣（LeetCode）"><a href="#剑指-Offer-51-数组中的逆序对-力扣（LeetCode）" class="headerlink" title="剑指 Offer 51. 数组中的逆序对 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">剑指 Offer 51. 数组中的逆序对 - 力扣（LeetCode）</a></h4><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [7,5,6,4]</span></span><br><span class="line"><span class="section">输出: 5</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>逆序对都与归并排序有关，归并排序与逆序对统计：</p><ol><li>终止条件： 当l &gt;= r时，代表子数组长度为1，终止划分；</li><li>递归划分：计算数组中点m，递归划分左子数组merge_sort(l, m)和右子数组merge_sort(m+1，r)；</li><li>合并与逆序对统计：<ol><li>暂存数组nums闭区间[i, r]内的元素至辅助数组temp；</li><li>循环合并：设置双指针i，j分别指向左/右子数组的首元素；<ul><li>当i = m + 1时，说明左子数组已经全部合并完成。</li><li>否则，当j = r + 1时，说明右子数组已经全部合并完成。</li><li>否则，当temp[i] &lt;= temp[j]时，说明左子数组的i元素比右子数组的j元素小，把左子数组的i元素加到nums中。</li><li>否则，当temp[i] &gt; temp[j]时，说明左子数组的i元素比右子数组的j元素大，此时除了把右子数组的j元素加到nums中之外，还要统计逆序对，因为左子数组是有序的，所以左子数组的i后面的元素都比右子数组的j元素大，所以逆序对为m - i + 1个。</li></ul></li></ol></li><li>返回值：返回直到目前的逆序对总数res。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">marge_sort</span><span class="params">(l, r)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> l &gt;= r: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            m = (l + r) // <span class="number">2</span></span><br><span class="line">            res = marge_sort(l, m) + marge_sort(m + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line">            i, j = l, m + <span class="number">1</span></span><br><span class="line">            temp[l:(r + <span class="number">1</span>)] = nums[l:(r + <span class="number">1</span>)]</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(l, r + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == m + <span class="number">1</span>:</span><br><span class="line">                    nums[k] = temp[j]</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> j == r + <span class="number">1</span> <span class="keyword">or</span> temp[i] &lt;= temp[j]:</span><br><span class="line">                    nums[k] = temp[i]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nums[k] = temp[j]</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    res += m - i + <span class="number">1</span>  <span class="comment"># i后面的都比当前的这个j大，因为l到m是有序的。</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        temp = [<span class="number">0</span>] * len(nums)</span><br><span class="line">        <span class="keyword">return</span> marge_sort(<span class="number">0</span>, len(nums)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><p>二分：其实也是一种分治法，每次通过一个上界和一个下界确定搜索范围，然后计算mid，通过判断mid与target的大小来继续确定左右范围，所以每次去掉一半的区间。</p><p><strong>分析二分最重要的一个点是：情况要全部考虑到，当等于时、当大于时、当小于时。这三种情况分别怎么处理</strong></p><p><strong>只要是数组序列是有序的，一半都是采用二分的解法</strong></p><p><strong>为了防止计算mid时数组越界，往往这样写：<code>mid = left + (right - left) // 2</code>。</strong></p><h4 id="34-在排序数组中查找元素的第一个和最后一个位置-力扣（LeetCode）"><a href="#34-在排序数组中查找元素的第一个和最后一个位置-力扣（LeetCode）" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></h4><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">8</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [], target = <span class="number">0</span></span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>二分的思想，有O(logN)时间复杂度的一般都是二分的思想，</p><p>思路很简单，通过两次二分分别找出左右边界，注意细节处理就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target: right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: left = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        res_l = right</span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target: right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> res_l + <span class="number">1</span> &gt;= left: <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> [res_l + <span class="number">1</span>, left - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="33-搜索旋转排序数组-力扣（LeetCode）"><a href="#33-搜索旋转排序数组-力扣（LeetCode）" class="headerlink" title="33. 搜索旋转排序数组 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组 - 力扣（LeetCode）</a></h4><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">0</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>], target = <span class="number">0</span></span><br><span class="line">输出：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>每次二分计算mid时，mid会将当前的数组分成一个有序的数组和一个无序的数组，所以我们可以在有序数组里面判断，然后重新确定二分的上下界。</p><ul><li>如果<code>[l, mid - 1]</code>是有序数组，且<code>target</code>的大小满足<code>[nums[l], nums[mid])</code>，这可以将范围缩小到<code>[l, mid - 1]</code>，否则<code>[mid + 1, r]</code>中寻找。</li><li>如果<code>[mid, r]</code>是有序数组，且<code>target</code>的大小满足<code>(nums[mid + 1], nums[r]]</code>，则可以将范围缩小到<code>[mid + 1, r]</code>，否则<code>[l, mid - 1]</code>中寻找。</li></ul><p>如果判断哪一边是有序的就根据当前的mid与数组的第一个数的大小关系，如果mid指向的数比第一个数大，则说明左边的是有序的，否则就是右边的有序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= nums[mid]:</span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="81-搜索旋转排序数组-II-力扣（LeetCode）"><a href="#81-搜索旋转排序数组-II-力扣（LeetCode）" class="headerlink" title="81. 搜索旋转排序数组 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II - 力扣（LeetCode）</a></h4><p>已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</p><p>你必须尽可能减少整个操作步骤。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">0</span></span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">3</span></span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 5000</li><li>-10^4 &lt;= nums[i] &lt;= 10^4</li><li>题目数据保证 nums 在预先未知的某个下标上进行了旋转</li><li>-10^4 &lt;= target &lt;= 10^4</li></ul><p><strong>思路</strong></p><p>和搜索螺旋旋转排序数组一样的，先找出mid哪边是有序的，然后在有序的那一部分判断大小，确定left和right边界。</p><p>但是由于有相同的元素，所有可能会出现<code>nums[left] == nums[mid] == nums[right]</code>的情况，这个时候只能将左边界加一，右边界减一，缩小查找区间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>] == target</span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> nums[left] == nums[mid] == nums[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[left] &lt;= nums[mid]:</span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><h4 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h4><p>前缀和就是指序列的前n项的和，可以理解为数学上的数列的前n项和，而差分就可以看成前缀和的逆运算。</p><p><strong>求某一区间和的问题就是前缀和的方法</strong></p><p>差分问题就是将根据前缀和数组恢复出原始的一维数组。</p><p>具体可见：<a href="https://blog.csdn.net/weixin_45629285/article/details/111146240" target="_blank" rel="noopener">前缀和与差分 图文并茂 超详细整理</a> </p><p>一维前缀和模板题：<a href="https://ac.nowcoder.com/acm/problem/208910" target="_blank" rel="noopener">区间求和 (nowcoder.com)</a> </p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>双指针就是通过两个指针变量指向我们要判断的两个元素，基于双指针的方法有很多：比如分别指向序列头和尾的双指针，即<strong>二分的上下界</strong>，<strong>滑动窗口的边界</strong>，也可以是指向前后两个元素的指针，如<strong>反转链表的前后指针</strong>，也可以是一个移动快一个移动慢的快慢指针，如<strong>判断链表环的入口（快指针每次动两个节点，慢指针每次动一个节点）</strong>，<strong>数组去重的双指针</strong>，也可以是指向两个不同序列的指针，如<strong>链表相交</strong>、<strong>链表合并</strong>。</p><h4 id="15-三数之和-力扣（LeetCode）"><a href="#15-三数之和-力扣（LeetCode）" class="headerlink" title="15. 三数之和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/3sum/" target="_blank" rel="noopener">15. 三数之和 - 力扣（LeetCode）</a></h4><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-4</span>]</span><br><span class="line">输出：[[<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">2</span>],[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="string">[]</span></span><br><span class="line">输出：<span class="string">[]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="string">[0]</span></span><br><span class="line">输出：<span class="string">[]</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>三个数之和为0，其实还是双指针。</p><p>排序，先枚举第一个数nums[a]，然后在剩下的数组中用双指针找和为-nums[a]的两个数，需要判断重复的时候跳出当前循环继续循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        n, ans = len(nums), []</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">3</span>: <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> a &gt; <span class="number">0</span> <span class="keyword">and</span> nums[a] == nums[a - <span class="number">1</span>]: <span class="keyword">continue</span> <span class="comment"># 如果当前的值与前面的一个值相同，跳出，因为这个值已经计算过了</span></span><br><span class="line"></span><br><span class="line">            c = n - <span class="number">1</span>  <span class="comment"># c从末尾往前找</span></span><br><span class="line">            target = <span class="number">-1</span> * nums[a]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> range(a + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> b &gt; a + <span class="number">1</span> <span class="keyword">and</span> nums[b] == nums[b - <span class="number">1</span>]: <span class="keyword">continue</span>  <span class="comment"># 如果当前的值与前面的一个b相同，跳出</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> b &lt; c <span class="keyword">and</span> nums[b] + nums[c] &gt; target:  <span class="comment"># 如果最小的b与当前的c相加都大于target，则将c的值减小</span></span><br><span class="line">                    c -= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> b == c: <span class="keyword">break</span>  <span class="comment"># b和c指向同一个值</span></span><br><span class="line">                <span class="keyword">if</span> nums[b] + nums[c] == target:</span><br><span class="line">                    ans.append([nums[a], nums[b], nums[c]])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="42-接雨水-力扣（LeetCode）"><a href="#42-接雨水-力扣（LeetCode）" class="headerlink" title="42. 接雨水 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水 - 力扣（LeetCode）</a></h4><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 </p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：上面是由数组 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 表示的高度图，在这种情况下，可以接 <span class="number">6</span> 个单位的雨水（蓝色部分表示雨水）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><p><strong>思路</strong></p><p>双指针，维护两个指针，max_left和max_right，里面分别存的是从左到右和从右到左的最大的左边界和右边界。</p><p>然后双指针left和right分别向中间移动，当那边的高度较小时进行操作，如果当前的高度比保存的max大，那么更新max，否则用max减去当前的高度就为当前位置能够接的雨水数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        left, right = <span class="number">0</span>, len(height) - <span class="number">1</span></span><br><span class="line">        max_left, max_right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> height[left] &lt;= height[right]:</span><br><span class="line">                <span class="keyword">if</span> height[left] &gt;= max_left:</span><br><span class="line">                    max_left = height[left]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += max_left - height[left]</span><br><span class="line">                </span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> height[right] &gt;= max_right:</span><br><span class="line">                    max_right = height[right]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += max_right - height[right]</span><br><span class="line"></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>dp</strong></p><p>dp也能做，分别用两个dp数组保存从左到右和从右到左的当前位置的最高的高度。然后在从左到右循环，每次通过dp数组找到当前位置的左最高和右最高取最小减去当前位置的高度就为当前位置能够接的雨水。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        n = len(height)</span><br><span class="line">        dp_left, dp_right = [<span class="number">0</span>] * n, [<span class="number">0</span>] * n</span><br><span class="line">        dp_left[<span class="number">0</span>] = height[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp_left[i] = max(dp_left[i - <span class="number">1</span>], height[i])</span><br><span class="line">        dp_right[n - <span class="number">1</span>] = height[n - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp_right[i] = max(dp_right[i + <span class="number">1</span>], height[i])</span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">            res += min(dp_left[i], dp_right[i]) - height[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>python的字符串是不可变变量。ASCII编码是一个字节，而Unicode编码通常是两个字节。为了节省空间，就把Unicode编码转化为“可变长编码”的<code>UTF-8</code>编码。UTF-8编码会把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母为1个字节，汉字通常为3个字节，</p><p>字符串类型的题目往往想法比较简单，但是实现起来比较复杂。因为python里面的字符串是不可变变量，所以不能直接更改里面的字符，需要将其转换为字符list。<strong>双指针法是字符串处理的常用方法</strong>。<strong>KMP算法是字符串中查找最重要的算法</strong>。</p><h4 id="3-无重复字符的最长子串-力扣（LeetCode）"><a href="#3-无重复字符的最长子串-力扣（LeetCode）" class="headerlink" title="3. 无重复字符的最长子串 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></h4><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。 </p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = "abcabcbb"</span></span><br><span class="line"><span class="section">输出: 3 </span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = "bbbbb"</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。</span></span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = "pwwkew"</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。</span></span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">"pwke"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><p>滑动窗口，保持窗口内没有重复的元素，用一个字典存下面每个字符出现的下标，然后每次更新窗口的左边界，使得窗口内没有重复的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        res, left, d = <span class="number">0</span>, <span class="number">0</span>, &#123;&#125;</span><br><span class="line">        s = list(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            left = max(left, d.get(s[i], <span class="number">-1</span>))</span><br><span class="line">            d[s[i]] = i + <span class="number">1</span></span><br><span class="line">            res = max(res, i - left + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="76-最小覆盖子串-力扣（LeetCode）"><a href="#76-最小覆盖子串-力扣（LeetCode）" class="headerlink" title="76. 最小覆盖子串 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串 - 力扣（LeetCode）</a></h4><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。 </p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"ADOBECODEBANC"</span>, <span class="attr">t</span> = <span class="string">"ABC"</span></span><br><span class="line">输出：<span class="string">"BANC"</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="comment">"a"</span>, t = <span class="comment">"a"</span></span><br><span class="line">输出：<span class="comment">"a"</span></span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入<span class="symbol">:</span> s = <span class="string">"a"</span>, <span class="built_in">t</span> = <span class="string">"aa"</span></span><br><span class="line">输出<span class="symbol">:</span> <span class="string">""</span></span><br><span class="line">解释<span class="symbol">:</span> <span class="built_in">t</span> 中两个字符 'a' 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><p><strong>思路</strong></p><p>滑动窗口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, s: str, t: str)</span> -&gt; str:</span></span><br><span class="line">        sl, st = len(s), len(t)</span><br><span class="line"></span><br><span class="line">        count = [<span class="number">0</span>] * <span class="number">128</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">            count[ord(c)] -= <span class="number">1</span>  <span class="comment"># 初始化：表示有多少的坑要填</span></span><br><span class="line">        </span><br><span class="line">        left = cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        ans = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> range(sl):</span><br><span class="line">            count[ord(s[right])] += <span class="number">1</span>  <span class="comment"># 填坑</span></span><br><span class="line">            <span class="keyword">if</span> count[ord(s[right])] &lt;= <span class="number">0</span>: cnt += <span class="number">1</span>  <span class="comment"># 如果当前填完坑小于等于0，表示是有效坑，当cnt==st之后，cnt就不会变了</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> cnt == st <span class="keyword">and</span> count[ord(s[left])] &gt; <span class="number">0</span>:  <span class="comment"># 移动左边界</span></span><br><span class="line">                count[ord(s[left])] -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt == st <span class="keyword">and</span> (<span class="keyword">not</span> ans <span class="keyword">or</span> len(ans) &gt; right - left + <span class="number">1</span>):</span><br><span class="line">                ans = s[left:right + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="28-实现-strStr-力扣（LeetCode）-1"><a href="#28-实现-strStr-力扣（LeetCode）-1" class="headerlink" title="28. 实现 strStr() - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/implement-strstr/" target="_blank" rel="noopener">28. 实现 strStr() - 力扣（LeetCode）</a></h4><p>实现 strStr() 函数。</p><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p><p>说明：</p><p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">haystack</span> = <span class="string">"hello"</span>, <span class="attr">needle</span> = <span class="string">"ll"</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">haystack</span> = <span class="string">"aaaaa"</span>, <span class="attr">needle</span> = <span class="string">"bba"</span></span><br><span class="line">输出：-<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><p>直接暴力搜索，或是KMP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle <span class="keyword">or</span> haystack == needle: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        haystack, n = list(haystack), len(needle)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(haystack) - n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">""</span>.join(haystack[i:(i + n)]) == needle:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="搜索与回溯"><a href="#搜索与回溯" class="headerlink" title="搜索与回溯"></a>搜索与回溯</h2><p><strong>组合：</strong></p><ol><li><a href="https://leetcode.cn/problems/combinations/" target="_blank" rel="noopener">77. 组合 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/combination-sum-iii/" target="_blank" rel="noopener">216. 组合总和 III - 力扣（LeetCode）</a> </li></ol><p><strong>分割：</strong></p><ol><li><a href="https://leetcode.cn/problems/palindrome-partitioning/" target="_blank" rel="noopener">131. 分割回文串 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/restore-ip-addresses/" target="_blank" rel="noopener">93. 复原 IP 地址 - 力扣（LeetCode）</a> </li></ol><p><strong>子集：</strong></p><ol><li><a href="https://leetcode.cn/problems/subsets/" target="_blank" rel="noopener">78. 子集 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II - 力扣（LeetCode）</a> </li></ol><p><strong>排列：</strong></p><ol><li><a href="https://leetcode.cn/problems/permutations/" target="_blank" rel="noopener">46. 全排列 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II - 力扣（LeetCode）</a> </li></ol><p><strong>棋盘问题：</strong></p><ol><li><a href="https://leetcode.cn/problems/n-queens/" target="_blank" rel="noopener">51. N 皇后 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/sudoku-solver/" target="_blank" rel="noopener">37. 解数独 - 力扣（LeetCode）</a> </li></ol><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><p>回溯法也就是叫回溯搜索法，是一种搜索的方式。</p><p><strong>做搜索回溯最主要画树，按照自己的逻辑画一颗树就有思路了</strong></p><p>回溯法不是高效的算法，因为回溯的本质是穷举，穷举所有的可能，然后选出想要的答案，而且递归操作会浪费时间和递归栈会占用内存。</p><p>如果优化回溯的话可以适当剪枝或者判断重复直接跳过。</p><p>回溯法解决的问题都可以抽象为树的结构。因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成树的宽度，递归的深度，都构成的树的深度。注意递归函数的结束条件以及结束时候的判断就行。</strong></p><h4 id="回溯搜索的遍历过程"><a href="#回溯搜索的遍历过程" class="headerlink" title="回溯搜索的遍历过程"></a>回溯搜索的遍历过程</h4><p>回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p><p><img src="https://img-blog.csdnimg.cn/20210130173631174.png" alt></p><p><strong>回溯函数的终止条件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">    存放结果；</span><br><span class="line">    <span class="keyword">return</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的图中可以看出**for循环可以理解是横向遍历，递归trackback就是纵向遍历，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中的一个结果。</p><p>所以<strong>回溯的总的模板如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果说要去重的话，我一般会在for循环前面定义一个set，然后for里面每次判断是否在set中，如果在，直接跳过这次循环。</p><p>回溯算法用于<strong>搜索一个问题的所有的解</strong>，通过深度优先遍历的思想实现。</p><p><strong>与动态规划的区别</strong></p><p><strong>共同点</strong></p><p>用于求解多阶段决策问题。多阶段决策问题：</p><ul><li>求解一个问题分为很多步骤(阶段)</li><li>每一个步骤(阶段)可以有多种选择。</li></ul><p><strong>不同点</strong></p><ul><li>动态规划只需要求我们评估的最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；</li><li>回溯算法可以搜索得到所有的方案(包括最优解)，但是本质上它是一种遍历算法，时间复杂度很高。</li></ul><p>深度优先遍历和广度优先遍历的主要思想区别在于：深度优先遍历是一个路走到底，然后回溯到上一个分叉路。广度优先遍历是一层一层往下递进的，先访问当前节点能到的所有节点，然后在往下访问，有点类似于树的层序遍历。所以广度优先遍历一般采用队列的方式实现。</p><h4 id="40-组合总和-II-力扣（LeetCode）"><a href="#40-组合总和-II-力扣（LeetCode）" class="headerlink" title="40. 组合总和 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II - 力扣（LeetCode）</a></h4><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用 一次 。</p><p>注意：解集不能包含重复的组合。 </p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = <span class="comment">[10,1,2,7,6,1,5]</span>, target = 8,</span><br><span class="line">输出:</span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment"><span class="comment">[1,1,6]</span>,</span></span><br><span class="line"><span class="comment"><span class="comment">[1,2,5]</span>,</span></span><br><span class="line"><span class="comment"><span class="comment">[1,7]</span>,</span></span><br><span class="line"><span class="comment"><span class="comment">[2,6]</span></span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = <span class="comment">[2,5,2,1,2]</span>, target = 5,</span><br><span class="line">输出:</span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment"><span class="comment">[1,2,2]</span>,</span></span><br><span class="line"><span class="comment"><span class="comment">[5]</span></span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><p>跟上一题的思路是一样的，只不过这里的每个元素不能重复，循环的时候每次将这个数减掉之后要下标要加1，并且有一个set存下面当前加入了哪些数，然后后面再进来这些数的时候直接跳过。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(path, target, index)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                res.append(list(path))</span><br><span class="line"></span><br><span class="line">            flag = set()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, len(candidates)):</span><br><span class="line">                <span class="keyword">if</span> candidates[i] <span class="keyword">in</span> flag: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> target &lt; candidates[i]: <span class="keyword">break</span></span><br><span class="line">                flag.add(candidates[i])</span><br><span class="line">                path.append(candidates[i])</span><br><span class="line">                dfs(path, target - candidates[i], i + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">        </span><br><span class="line">        res, path = [], []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        dfs(path, target, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="93-复原-IP-地址-力扣（LeetCode）"><a href="#93-复原-IP-地址-力扣（LeetCode）" class="headerlink" title="93. 复原 IP 地址 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/" target="_blank" rel="noopener">93. 复原 IP 地址 - 力扣（LeetCode）</a></h4><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:192.168@1.1" target="_blank" rel="noopener">192.168@1.1</a>“ 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"25525511135"</span></span><br><span class="line">输出：[<span class="string">"255.255.11.135"</span>,<span class="string">"255.255.111.35"</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"0000"</span></span><br><span class="line">输出：[<span class="string">"0.0.0.0"</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"101023"</span></span><br><span class="line">输出：[<span class="string">"1.0.10.23"</span>,<span class="string">"1.0.102.3"</span>,<span class="string">"10.1.0.23"</span>,<span class="string">"10.10.2.3"</span>,<span class="string">"101.0.2.3"</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>回溯。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line"></span><br><span class="line">        seg_Count = <span class="number">4</span></span><br><span class="line">        ans = []</span><br><span class="line">        segments = [<span class="number">0</span>] * seg_Count</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(segId, segStart)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> segId == seg_Count:</span><br><span class="line">                <span class="keyword">if</span> segStart == len(s):</span><br><span class="line">                    ipAddr = <span class="string">'.'</span>.join(str(seg) <span class="keyword">for</span> seg <span class="keyword">in</span> segments)</span><br><span class="line">                    ans.append(ipAddr)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 没有找到4段IP地址就已经遍历完成了字符串，那么直接结束</span></span><br><span class="line">            <span class="keyword">if</span> segStart == len(s):</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 由于不能有前导0，所以如果当前数字为0，那么这一段IP地址只能为0.</span></span><br><span class="line">            <span class="keyword">if</span> s[segStart] == <span class="string">'0'</span>:</span><br><span class="line">                segments[segId] = <span class="number">0</span></span><br><span class="line">                dfs(segId + <span class="number">1</span>, segStart + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            addr = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> segEnd <span class="keyword">in</span> range(segStart, len(s)):</span><br><span class="line">                addr = addr * <span class="number">10</span> + (ord(s[segEnd]) - ord(<span class="string">'0'</span>))</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt; addr &lt;= <span class="number">255</span>:</span><br><span class="line">                    segments[segId] = addr</span><br><span class="line">                    dfs(segId + <span class="number">1</span>, segEnd + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="90-子集-II-力扣（LeetCode）"><a href="#90-子集-II-力扣（LeetCode）" class="headerlink" title="90. 子集 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II - 力扣（LeetCode）</a></h4><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：[[],[<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>]</span><br><span class="line">输出：<span class="string">[[],[0]]</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>先对数组进行排序，然后在每次加入元素的时候判断这个数前面是否加入过了，即去重。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">trachback</span><span class="params">(index)</span>:</span></span><br><span class="line">            ans.append(list(path))</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, len(nums)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; index <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                trachback(i + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">            </span><br><span class="line">        ans, path = [], []</span><br><span class="line">        nums.sort()</span><br><span class="line">        trachback(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="47-全排列-II-力扣（LeetCode）"><a href="#47-全排列-II-力扣（LeetCode）" class="headerlink" title="47. 全排列 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II - 力扣（LeetCode）</a></h4><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em>按任意顺序</em> 返回所有不重复的全排列。 </p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：</span><br><span class="line">[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 8</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><p><strong>思路</strong></p><p>跟无重复的是类似的，只不过这里多了一个判重的过程，用一个set把访问过的元素存下面，然后每次再来元素的时候先判断set里面有没有考虑过，如果有，就跳过这次循环，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">trackback</span><span class="params">(index)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> index &gt;= len(nums):</span><br><span class="line">                res.append(list(nums))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            flag = set()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, len(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">in</span> flag: <span class="keyword">continue</span></span><br><span class="line">                flag.add(nums[i])</span><br><span class="line">                nums[i], nums[index] = nums[index], nums[i]</span><br><span class="line">                trackback(index + <span class="number">1</span>)</span><br><span class="line">                nums[i], nums[index] = nums[index], nums[i]</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># nums.sort()</span></span><br><span class="line">        trackback(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="51-N-皇后-力扣（LeetCode）"><a href="#51-N-皇后-力扣（LeetCode）" class="headerlink" title="51. N 皇后 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/n-queens/" target="_blank" rel="noopener">51. N 皇后 - 力扣（LeetCode）</a></h4><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p><p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：[[<span class="string">".Q.."</span>,<span class="string">"...Q"</span>,<span class="string">"Q..."</span>,<span class="string">"..Q."</span>],[<span class="string">"..Q."</span>,<span class="string">"Q..."</span>,<span class="string">"...Q"</span>,<span class="string">".Q.."</span>]]</span><br><span class="line">解释：如上图所示，<span class="number">4</span> 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p><strong>完全自己写，一遍过</strong></p><p>回溯函数的参数：当前的放置方案以及要处理的下标(即二维里面的行数)</p><p>首先判断当前的下标是否已经超过了n，如果是，直接将当前的方案放置到res中，</p><p>如果不是，则对于index下标位置的放置方案，有0到n这几个位置可以放，然后判断</p><pre><code>判断当前要放入的数(即当前行放在第几列)在index之前是否已经出现过，如果出现过说明同列了并且判断当前的下标减去之前的下标的绝对值是否等于当前要放入的数与之前的对应的下标的绝对值是否相等，如果是，说明同一斜线了。</code></pre><p>然后都不满足，则说明当前的数可以放到当前的行，放入，然后讲index加1之后进行下一个位置的判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n: int)</span> -&gt; List[List[str]]:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">trackback</span><span class="params">(path, index)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> index &gt;= n:</span><br><span class="line">                res.append(list(path))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> judge(path, index, i):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path[index] = i</span><br><span class="line">                trackback(path, index + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">judge</span><span class="params">(path, index, i)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(index):</span><br><span class="line">                <span class="keyword">if</span> path[j] == i <span class="keyword">or</span> abs(index - j) == abs(i - path[j]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        res, path = [], [<span class="number">0</span>] * n</span><br><span class="line">        trackback(path, <span class="number">0</span>)</span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> arr <span class="keyword">in</span> res:</span><br><span class="line">            temp = [[<span class="string">'.'</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">                temp[i][arr[i]] = <span class="string">'Q'</span></span><br><span class="line">            temp = [<span class="string">""</span>.join(s) <span class="keyword">for</span> s <span class="keyword">in</span> temp]</span><br><span class="line">            ans.append(temp)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h4 id="题目大纲"><a href="#题目大纲" class="headerlink" title="题目大纲"></a>题目大纲</h4><p><strong>序列问题</strong></p><ol><li><a href="https://leetcode.cn/problems/monotone-increasing-digits/" target="_blank" rel="noopener">738. 单调递增的数字 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子数组和 - 力扣（LeetCode）</a> </li></ol><p><strong>股票问题</strong></p><ol><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/candy/" target="_blank" rel="noopener">135. 分发糖果 - 力扣（LeetCode）</a> </li></ol><p><strong>区间问题</strong></p><ol><li><a href="https://leetcode.cn/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间 - 力扣（LeetCode）</a> </li></ol><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p><p>举个例子：</p><ol><li>有一堆钞票，你可以拿走十张，如果想要拿到的钱最多，要怎么拿？</li><li>有一堆盒子，你有一个体积为n的背包，如果把背包尽可能的装满？</li></ol><p><strong>贪心算法没有固定的套路，也没有固定的策略</strong></p><p><strong>我自己的方法就是：先手动模拟，模拟一遍，如果可以推出来每次去局部最优能达到全局最优，那贪心就可行，否则就是动态规划</strong></p><p>做贪心的题自己模拟一遍之后要大胆的猜一下，并试一下能不能过，贪心一般会有严格的数学证明，但是在面试和笔试的时候不会要求证明贪心的合理性。代码写出来能过测试样例就行。</p><p><strong>贪心没有套路，只能常识推导或者加上举反例</strong></p><h4 id="55-跳跃游戏-力扣（LeetCode）"><a href="#55-跳跃游戏-力扣（LeetCode）" class="headerlink" title="55. 跳跃游戏 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏 - 力扣（LeetCode）</a></h4><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 <span class="number">1</span> 步，从下标 <span class="number">0</span> 到达下标 <span class="number">1</span>, 然后再从下标 <span class="number">1</span> 跳 <span class="number">3</span> 步到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 <span class="number">3</span> 的位置。但该下标的最大跳跃长度是 <span class="number">0</span> ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>思路</strong></p><p>贪心：维护一个变量，表示每走一步当前能走的最远的位置。如果这个当前能走的最远的位置大于数组的长度，那就是能到达。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        n, maxtemp = len(nums), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            maxtemp = max(maxtemp, i + nums[i])</span><br><span class="line">            <span class="keyword">if</span> maxtemp &gt;= n - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= maxtemp:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="45-跳跃游戏-II-力扣（LeetCode）"><a href="#45-跳跃游戏-II-力扣（LeetCode）" class="headerlink" title="45. 跳跃游戏 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II - 力扣（LeetCode）</a></h4><p>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>假设你总是可以到达数组的最后一个位置。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为<span class="number"> 0 </span>跳到下标为<span class="number"> 1 </span>的位置，跳<span class="number"> 1 </span>步，然后跳<span class="number"> 3 </span>步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: nums = [2,3,0,1,4]</span></span><br><span class="line"><span class="section">输出: 2</span></span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><p><strong>思路</strong></p><p><strong>贪心策略</strong>，每次更新当前的能走的最远的边界，并保存上一个步数能走的最远的边界。然后如果说当前的位置已经走到上一个步数的边界，那么步数加一，并且更新下一步能走的最远的边界。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        max_far, step, end = <span class="number">0</span>, <span class="number">0</span> ,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">            max_far = max(max_far, i + nums[i])  <span class="comment"># 找到当前步数能走的最远的边界</span></span><br><span class="line">            <span class="keyword">if</span> i == end:  <span class="comment"># 如果已经走到了上一步最远的边界</span></span><br><span class="line">                step += <span class="number">1</span>  <span class="comment"># 步数加一，表示后面的位置都是下一步能走到的</span></span><br><span class="line">                end = max_far  <span class="comment"># 更新下一步能走的最远的边界</span></span><br><span class="line">        <span class="keyword">return</span> step</span><br></pre></td></tr></table></figure><h4 id="56-合并区间-力扣（LeetCode）"><a href="#56-合并区间-力扣（LeetCode）" class="headerlink" title="56. 合并区间 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间 - 力扣（LeetCode）</a></h4><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">解释：区间 [<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">6</span>] 重叠, 将它们合并为 [<span class="number">1</span>,<span class="number">6</span>].</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">5</span>]]</span><br><span class="line">解释：区间 [<span class="number">1</span>,<span class="number">4</span>] 和 [<span class="number">4</span>,<span class="number">5</span>] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= intervals.length &lt;= 10^4</li><li>intervals[i].length == 2</li><li>0 &lt;= starti &lt;= endi &lt;= 10^4</li></ul><p><strong>思路</strong></p><p>先对原数组按照每个矩阵的第一个元素从小到大排序，然后再判断后面一个的头是否比前面的一个尾小，从而判断是否能够合并。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line"></span><br><span class="line">        intervals.sort(key=(<span class="keyword">lambda</span> x: x[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">        ans = [list(intervals[<span class="number">0</span>])]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> arr <span class="keyword">in</span> intervals[<span class="number">1</span>:]:</span><br><span class="line">            <span class="comment"># print(arr)</span></span><br><span class="line">            <span class="keyword">if</span> arr[<span class="number">0</span>] &lt;= ans[<span class="number">-1</span>][<span class="number">1</span>]:</span><br><span class="line">                ans[<span class="number">-1</span>][<span class="number">1</span>] = max(arr[<span class="number">1</span>], ans[<span class="number">-1</span>][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(list(arr))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="135-分发糖果-力扣（LeetCode）"><a href="#135-分发糖果-力扣（LeetCode）" class="headerlink" title="135. 分发糖果 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/candy/" target="_blank" rel="noopener">135. 分发糖果 - 力扣（LeetCode）</a></h4><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><p>每个孩子至少分配到 1 个糖果。<br>相邻两个孩子评分更高的孩子会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：ratings = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：你可以分别给第一个、第二个、第三个孩子分发 <span class="number">2</span>、<span class="number">1</span>、<span class="number">2</span> 颗糖果。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：ratings = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：你可以分别给第一个、第二个、第三个孩子分发 <span class="number">1</span>、<span class="number">2</span>、<span class="number">1</span> 颗糖果。</span><br><span class="line">     第三个孩子只得到 <span class="number">1</span> 颗糖果，这满足题面中的两个条件。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>两次循环，分别从左到右判断和从右到左判断。最后针对i位置的元素取两个当中的最大值，就能都满足这两个数组的条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">candy</span><span class="params">(self, ratings: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(ratings)</span><br><span class="line">        left = [<span class="number">1</span>] * n</span><br><span class="line">        right = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> ratings[i] &gt; ratings[i - <span class="number">1</span>]:</span><br><span class="line">                left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        ans = left[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> ratings[i] &gt; ratings[i + <span class="number">1</span>]:</span><br><span class="line">                right[i] = right[i + <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            ans += max(left[i], right[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="1403-非递增顺序的最小子序列-力扣（LeetCode）"><a href="#1403-非递增顺序的最小子序列-力扣（LeetCode）" class="headerlink" title="1403. 非递增顺序的最小子序列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-subsequence-in-non-increasing-order/" target="_blank" rel="noopener">1403. 非递增顺序的最小子序列 - 力扣（LeetCode）</a></h4><p>给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。</p><p>如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。</p><p>与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。</p><p>注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>]</span><br><span class="line">输出：[<span class="number">10</span>,<span class="number">9</span>] </span><br><span class="line">解释：子序列 [<span class="number">10</span>,<span class="number">9</span>] 和 [<span class="number">10</span>,<span class="number">8</span>] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [<span class="number">10</span>,<span class="number">9</span>] 的元素之和最大。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">7</span>,<span class="number">7</span>,<span class="number">6</span>] </span><br><span class="line">解释：子序列 [<span class="number">7</span>,<span class="number">7</span>] 的和为 <span class="number">14</span> ，不严格大于剩下的其他元素之和（<span class="number">14</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">6</span>）。因此，[<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>] 是满足题意的最小子序列。注意，元素按非递增顺序返回。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>排序加贪心。因为没有要求连续的子序列的和，所有肯定是先从最大的里面取，以为这样才能符合长度最小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubsequence</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        nums.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        sn, sp = sum(nums), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            sp += nums[i]</span><br><span class="line">            <span class="keyword">if</span> sp &gt; sn - sp:</span><br><span class="line">                <span class="keyword">return</span> nums[:(i + <span class="number">1</span>)]</span><br></pre></td></tr></table></figure><h2 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h2><h3 id="质数-素数"><a href="#质数-素数" class="headerlink" title="质数(素数)"></a>质数(素数)</h3><p>素数：只能被1或者是自身整除的数称为素数(质数)。所以有一种方法，是直接暴力搜索从1到n有没有能整除自己的。</p><p><strong>第一种优化</strong></p><p>判断n是不是素数，其实只用搜索到sqrt(n)就行了，因为如果[2, sqrt(n)]这个区间之内没有可整除因子，那么[sqrt(n)，n]之间也一定不会有整除因子。</p><p><strong>第二种优化</strong></p><p><strong>素数打表</strong>，也成为了埃拉托斯特尼筛法，其思想是：如果一个数i是素数，那么从<code>j = i * i</code>开始，（因为<code>i * i</code>之间的都已经被之前的标记过了），j + i，j + 2 * i 这些都不可能是素数了。例如：</p><p>如果2是素数，所以，4， 6， 8，10，12都不是素数</p><p>如果3是素数，所以，9，12，15都不是素数</p><p>时间复杂度：<strong>O(n * log log n)</strong>  记住</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span><span class="params">(n)</span>:</span></span><br><span class="line">    isPrime = [<span class="literal">True</span>] * n</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n ** <span class="number">0.5</span>):  <span class="comment"># 从 2 到 sqrt(n)搜索</span></span><br><span class="line">        <span class="keyword">if</span> isPrime[i]:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i * i, n, i):  <span class="comment"># 从i * i开始将后面的i的倍数都置为False</span></span><br><span class="line">                isPrime[j] = <span class="literal">False</span></span><br><span class="line">   <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>还有一种线性筛，时间复杂度为O(n)，因为上面的方法中如45这个数，还是有重复判断，3和5的时候都判断了，但是面试不会涉及到线性筛。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span><span class="params">(n)</span>:</span></span><br><span class="line">    primes = []</span><br><span class="line">    isPrime = [<span class="literal">True</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> isPrime[i]:  <span class="comment"># 如果是素数</span></span><br><span class="line">            primes.append(i)  <span class="comment"># 记录在表中</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; len(primes) <span class="keyword">and</span> i * primes[i] &lt; n:</span><br><span class="line">            isPrime[i * primes[j]] = <span class="literal">False</span>   <span class="comment"># 素数乘以一个素数一定是一个合数</span></span><br><span class="line">            <span class="keyword">if</span> i % primes[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">   <span class="keyword">return</span> len(primes)</span><br></pre></td></tr></table></figure><h4 id="4492-减法操作-AcWing题库"><a href="#4492-减法操作-AcWing题库" class="headerlink" title="4492. 减法操作 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/4495/" target="_blank" rel="noopener">4492. 减法操作 - AcWing题库</a></h4><p>给定一个整数n，执行如下算法：</p><ol><li>如果 n = 0，则结束算法。</li><li>找到n的最小质因子d。</li><li>令n减去d并跳转步骤1。</li></ol><p>请你计算，在算法执行的过程中，一共进行了多少次减法操作。</p><p><em>输入格式</em></p><p>一个整数n</p><p><em>输出格式</em></p><p>一个整数，表示减法操作的次数。</p><p><strong>数据范围</strong></p><p>$ 2 \leq n \leq 10^{10} $</p><p><strong>示例1</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">5</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">输入：<span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>质因子：如果b能被a整除，则称a为b的质因子。</p><p>可以发现，如果当前这个数为偶数，那么它的最小质因子一定是2，减去2之后还是为偶数，所以可以发现偶数的减法操作就为n / 2</p><p>奇数的最小质因子一定为奇数，那么当这个奇数减去一个最小的质因子，剩下的数一定是偶数，假设这个最小质因子为x，那么剩下的减法操作为(n - x) / 2，加上减去那个奇数的最小质因子，所以总共的减法操作为： 1 + (n - x) / 2</p><p>找最小质因子，用试除法，遍历到sqrt(n)就行。</p><p><strong>其实奇数只要不是素数，那么它的最小质因子一定是3或5或7，如果是素数，就直接前去他自己就行</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isprime</span><span class="params">(m)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(sqrt(m)) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> m % i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    n = int(input())</span><br><span class="line">    flag = isprime(n)</span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        print(<span class="number">1</span> + (n - flag) // <span class="number">2</span>, end=<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="number">1</span>, end=<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="最大公约数-欧几里得"><a href="#最大公约数-欧几里得" class="headerlink" title="最大公约数(欧几里得)"></a>最大公约数(欧几里得)</h3><p>欧几里得算法（gcd）：又称为辗转相除法，用于计算两个非负整数的最大公约数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(m, n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> gcd(n, m % n) <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> m</span><br></pre></td></tr></table></figure><p><strong>最小公倍数：</strong>就是两个数的成绩除以他们的最大公约数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(m, n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> gcd(n, m % n) <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> m</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcm</span><span class="params">(m, n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> m * n // gcd(m, n)</span><br></pre></td></tr></table></figure><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>快速幂求余主要用于求：$ x ^ {a}$中当a很大的时候。其主要思想就是不断的分解a，然后将x进行平方。如：</p><p>求$ x ^ {a} $：</p><ol><li>当a为偶数的时候，$ x ^ {a} $就等于$ (x ^ 2) ^ {a / 2} $。</li><li>当a为奇数的时候，$ x ^ {a} $ 就等于$ x * (x ^ {2}) ^ {a // 2}$。</li></ol><p>时间复杂度为O(log a)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求 (x^a) % p —— 快速幂求余</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remainder</span><span class="params">(x, a, p)</span>:</span></span><br><span class="line">    rem = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> a % <span class="number">2</span>: rem = (rem * x) % p</span><br><span class="line">        x = x ** <span class="number">2</span> % p</span><br><span class="line">        a //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> rem</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remainder</span><span class="params">(x, a, p)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    x %= p</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> a &amp; <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># a 为奇数</span></span><br><span class="line">        <span class="keyword">return</span> (x * remainder(x, a - <span class="number">1</span>)) % p</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sub = remainder(x, a // <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> (sub * sub) % p</span><br></pre></td></tr></table></figure><h4 id="50-Pow-x-n-力扣（LeetCode）"><a href="#50-Pow-x-n-力扣（LeetCode）" class="headerlink" title="50. Pow(x, n) - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n) - 力扣（LeetCode）</a></h4><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a> ，即计算 <code>x</code> 的整数 <code>n</code> 次幂函数（即，<code>x^n</code> ）。 </p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">2.00000</span>, n = <span class="number">10</span></span><br><span class="line">输出：<span class="number">1024.00000</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">2.10000</span>, n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">9.26100</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">2.00000</span>, n = <span class="number">-2</span></span><br><span class="line">输出：<span class="number">0.25000</span></span><br><span class="line">解释：<span class="number">2</span><span class="number">-2</span> = <span class="number">1</span>/<span class="number">22</span> = <span class="number">1</span>/<span class="number">4</span> = <span class="number">0.25</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p><strong>快速幂</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        res, symbol = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            n, symbol = -n, <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                res = res * x</span><br><span class="line">            x *= x  <span class="comment"># 不知道为什么 x = x ** 2会报错，数据出界</span></span><br><span class="line">            n = n // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> symbol == <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span> / res</span><br></pre></td></tr></table></figure><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>位运算主要有四种：与、非、或、异或。</p><p><strong>不用临时变量交换两个数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">a ^= b</span><br><span class="line">b ^= a</span><br><span class="line">a ^= b</span><br></pre></td></tr></table></figure><p><strong>消除数字n的二进制表示中的最后一个1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n &amp; (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>判断一个数是不是2的指数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> bool((n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>异或运算的性质</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a ^ a = <span class="number">0</span></span><br><span class="line">a ^ <span class="number">0</span> = a</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-15-二进制中1的个数-力扣（LeetCode）"><a href="#剑指-Offer-15-二进制中1的个数-力扣（LeetCode）" class="headerlink" title="剑指 Offer 15. 二进制中1的个数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 15. 二进制中1的个数 - 力扣（LeetCode）</a></h4><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <a href="http://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="noopener">汉明重量</a>).）。 </p><p>提示：</p><p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">11</span> (控制台输入 <span class="number">00000000000000000000000000001011</span>)</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：输入的二进制串 <span class="number">00000000000000000000000000001011</span> 中，共有三位为 '<span class="number">1</span>'。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4294967293</span> (控制台输入 <span class="number">11111111111111111111111111111101</span>，部分语言中 n = <span class="number">-3</span>）</span><br><span class="line">输出：<span class="number">31</span></span><br><span class="line">解释：输入的二进制串 <span class="number">11111111111111111111111111111101</span> 中，共有 <span class="number">31</span> 位为 '<span class="number">1</span>'。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>位运算，每次去掉n二进制最左边的1，然后ans加1，直到n为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            n &amp;= (n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-65-不用加减乘除做加法-力扣（LeetCode）"><a href="#剑指-Offer-65-不用加减乘除做加法-力扣（LeetCode）" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">剑指 Offer 65. 不用加减乘除做加法 - 力扣（LeetCode）</a></h4><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。 </p><p><strong>示例:</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="selector-tag">a</span> = <span class="number">1</span>, <span class="selector-tag">b</span> = <span class="number">1</span></span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>位运算：</p><p>二进制每位相加，需要考虑加之后的本位和，以及进位数。本位和的结果为相加的两位的异或，进位数只有当都为1时才会进位1，所以为与的运算。</p><p>求a+b， 本和为则为 n = a ^ b，a异或b，进位和则为 c = a &amp; b &lt;&lt; 1，a与b的结果左移一位。</p><p>所以a+b可以等价于n+c，然后继续进行上面的操作，直到进位和都为0，即c = 0。</p><p><strong>注意</strong></p><p>python中负数的存储规则</p><p>python中的负数也是以补码的形式存储，因此负数的高位无限补1，正数的高位无限补0。不能直接用原始的负数进行位运算，因为负数的高位是无数个1，与高位是无穷个0的正数做运算可能会出错。</p><p>所以需要手动获取负数的补码，并把高位置为0，将负数变为一个正数，即把原数字与0xffffffff做位与运算，</p><p>最后的结果怎么判断是负数呢？</p><p>因为对于32位的整数，最前面的一位是符号位，因此最大的正整数只可能是0x7fffffff。大于0x7fffffff的都为负数，因为负数的第一位符号位为1。</p><p>所以需要将负数的补码还原成原码，将以补码形式表示的负数转换成十进制输出，只需要将负数的补码的高位全部还原为1，因为前面我们将高位全置为0了。所以只需要将负数高于32位的数位取反就行，但是直接取反会将后面的32也取反，所以我们先将后面32位取反，然后再全部取反，即可以实现只对前面的32位取反。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, a: int, b: int)</span> -&gt; int:</span></span><br><span class="line">        x = <span class="number">0xffffffff</span></span><br><span class="line">        a, b = a &amp; x, b &amp; x</span><br><span class="line">        <span class="keyword">while</span> b:</span><br><span class="line">            a, b = a ^ b, (a &amp; b) &lt;&lt; <span class="number">1</span> &amp; x</span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt;= <span class="number">0x7fffffff</span> <span class="keyword">else</span> ~(a ^ x)</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-56-I-数组中数字出现的次数-力扣（LeetCode）"><a href="#剑指-Offer-56-I-数组中数字出现的次数-力扣（LeetCode）" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 56 - I. 数组中数字出现的次数 - 力扣（LeetCode）</a></h4><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 </p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">6</span>] 或 [<span class="number">6</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">10</span>] 或 [<span class="number">10</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>异或运算：任何数与0异或运算都等于他本身，两个相同的数异或运算为0，而且异或运算满足交换律，所以如果只有一个出现一次的数，可以依次将数组中的元素与0进行异或运算，最后的结果一定是那个出现一次的数。</p><p>但是这个题有两个只出现一次的数。</p><p>所以需要通过一个数将这两个只出现一次的数分隔开，然后形成两个子数组，每个数组里面包含一个只出现一次的数。</p><p>假设那两个只出现一次的数分别为x，y，将数组的所有元素异或运算一次之后，最后的结果肯定是x与y异或的结果，如果其中某一位为1，则说明x和y在这位上的值肯定不同，一个为0一个为1，所以找出这一位出来，而其他相同的两个数在这位肯定都是相同的，所以就依据这一位x和y的值不同就可以把x和y分隔开来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumbers</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        x, y, n, m = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            n = n ^ i</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span>(n &amp; m):  <span class="comment"># 从右向左找出第一个为1的那一位。</span></span><br><span class="line">            m &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i &amp; m:</span><br><span class="line">                x ^= i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y ^= i</span><br><span class="line">        <span class="keyword">return</span> x, y</span><br></pre></td></tr></table></figure><h3 id="简单博弈"><a href="#简单博弈" class="headerlink" title="简单博弈"></a>简单博弈</h3><h4 id="巴什博弈-（Bash-Game）"><a href="#巴什博弈-（Bash-Game）" class="headerlink" title="巴什博弈 （Bash Game）"></a>巴什博弈 （Bash Game）</h4><p> 只有一堆n个物品，两个人从轮流中取出（1~m）个；最后取光者胜。</p><p>  考虑到 若n=m+1 那么 第一个人不论如何取都不能取胜。</p><p>  进一步我们发现 若 n=k*(m+1)+r; 先取者拿走 r 个，那么后者再拿（1~m）个</p><p>  n=（k-1）*（m+1）+s； 先取者再拿走s 个 最后总能造成 剩下n=m+1 的局面。</p><p>  因此，此时先手有必赢策略。</p><p>  相对应的，若n=k*(m+1) 那么先取者必输。</p><p>  因此我们可以写出对应的程序（默认 n m都大于0）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bash_game</span><span class="params">(n, m)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n % (m + <span class="number">1</span>) != <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="877-石子游戏-力扣（LeetCode）"><a href="#877-石子游戏-力扣（LeetCode）" class="headerlink" title="877. 石子游戏 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/stone-game/" target="_blank" rel="noopener">877. 石子游戏 - 力扣（LeetCode）</a></h4><p>Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，排成一行；每堆都有 正 整数颗石子，数目为 piles[i] 。</p><p>游戏以谁手中的石子最多来决出胜负。石子的 总数 是 奇数 ，所以没有平局。</p><p>Alice 和 Bob 轮流进行，Alice 先开始 。 每回合，玩家从行的 开始 或 结束 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 石子最多 的玩家 获胜 。</p><p>假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">Alice 先开始，只能拿前 <span class="number">5</span> 颗或后 <span class="number">5</span> 颗石子 。</span><br><span class="line">假设他取了前 <span class="number">5</span> 颗，这一行就变成了 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] 。</span><br><span class="line">如果 Bob 拿走前 <span class="number">3</span> 颗，那么剩下的是 [<span class="number">4</span>,<span class="number">5</span>]，Alice 拿走后 <span class="number">5</span> 颗赢得 <span class="number">10</span> 分。</span><br><span class="line">如果 Bob 拿走后 <span class="number">5</span> 颗，那么剩下的是 [<span class="number">3</span>,<span class="number">4</span>]，Alice 拿走后 <span class="number">4</span> 颗赢得 <span class="number">9</span> 分。</span><br><span class="line">这表明，取前 <span class="number">5</span> 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>dp或者直接博弈</p><p>其实先拿的人只要在开始计算好是奇数组的石头多还是偶数组的石头多，那么<strong>先拿的人是必赢的</strong></p><h4 id="319-灯泡开关-力扣（LeetCode）"><a href="#319-灯泡开关-力扣（LeetCode）" class="headerlink" title="319. 灯泡开关 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/bulb-switcher/" target="_blank" rel="noopener">319. 灯泡开关 - 力扣（LeetCode）</a></h4><p>初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭第二个。</p><p>第三轮，你每三个灯泡就切换第三个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换第 i 个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。</p><p>找出并返回 n 轮后有多少个亮着的灯泡。</p><p><strong>示例1</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">1</span> </span><br><span class="line">解释：</span><br><span class="line">初始时, 灯泡状态 [关闭, 关闭, 关闭].</span><br><span class="line">第一轮后, 灯泡状态 [开启, 开启, 开启].</span><br><span class="line">第二轮后, 灯泡状态 [开启, 关闭, 开启].</span><br><span class="line">第三轮后, 灯泡状态 [开启, 关闭, 关闭]. </span><br><span class="line"></span><br><span class="line">你应该返回 <span class="number">1</span>，因为只有一个灯泡还亮着。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bulbSwitch</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> int(sqrt(n + <span class="number">0.5</span>))</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="题目大纲分类："><a href="#题目大纲分类：" class="headerlink" title="题目大纲分类："></a>题目大纲分类：</h3><p><strong>基础题目</strong></p><ol><li><a href="https://leetcode.cn/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">746. 使用最小花费爬楼梯 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/integer-break/" target="_blank" rel="noopener">343. 整数拆分 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树 - 力扣（LeetCode）</a> </li></ol><p><strong>背包问题</strong></p><ul><li>01背包问题：<ol><li><a href="https://leetcode.cn/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. 分割等和子集 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/last-stone-weight-ii/" target="_blank" rel="noopener">1049. 最后一块石头的重量 II - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/target-sum/" target="_blank" rel="noopener">494. 目标和 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/ones-and-zeroes/" target="_blank" rel="noopener">474. 一和零 - 力扣（LeetCode）</a> </li></ol></li><li>完全背包：<ul><li><a href="https://leetcode.cn/problems/coin-change-2/" target="_blank" rel="noopener">518. 零钱兑换 II - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/combination-sum-iv/" target="_blank" rel="noopener">377. 组合总和 Ⅳ - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/perfect-squares/" target="_blank" rel="noopener">279. 完全平方数 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/word-break/" target="_blank" rel="noopener">139. 单词拆分 - 力扣（LeetCode）</a> </li></ul></li></ul><p><strong>打家劫舍问题</strong></p><ol><li><a href="https://leetcode.cn/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/house-robber-iii/" target="_blank" rel="noopener">337. 打家劫舍 III - 力扣（LeetCode）</a> </li></ol><p><strong>股票问题</strong></p><ol><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机 - 力扣（LeetCode）</a> （只能买卖一次）</li><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II - 力扣（LeetCode）</a> （可以买卖多次）</li><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III - 力扣（LeetCode）</a> （最多买卖两次）</li><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. 买卖股票的最佳时机 IV - 力扣（LeetCode）</a> （最多买卖k次）</li><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期 - 力扣（LeetCode）</a> （买卖多次，卖出有一天冷冻期）</li><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. 买卖股票的最佳时机含手续费 - 力扣（LeetCode）</a> （买卖多次，每次有手续费）</li></ol><p><strong>子序列问题</strong></p><ul><li>子序列（不连续）<ul><li><a href="https://leetcode.cn/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长递增子序列 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/uncrossed-lines/" target="_blank" rel="noopener">1035. 不相交的线 - 力扣（LeetCode）</a> </li></ul></li><li>子序列（连续）<ul><li><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">674. 最长连续递增序列 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">718. 最长重复子数组 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子数组和 - 力扣（LeetCode）</a> </li></ul></li><li>编辑距离<ul><li><a href="https://leetcode.cn/problems/is-subsequence/" target="_blank" rel="noopener">392. 判断子序列 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/distinct-subsequences/" target="_blank" rel="noopener">115. 不同的子序列 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener">583. 两个字符串的删除操作 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离 - 力扣（LeetCode）</a> </li></ul></li><li>回文<ul><li><a href="https://leetcode.cn/problems/palindromic-substrings/" target="_blank" rel="noopener">647. 回文子串 - 力扣（LeetCode）</a> </li><li><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. 最长回文子序列 - 力扣（LeetCode）</a> </li></ul></li></ul><h3 id="动态规划的理论基础"><a href="#动态规划的理论基础" class="headerlink" title="动态规划的理论基础"></a>动态规划的理论基础</h3><p>动态规划：Dynamic Programming，DP。求有很多个重叠子问题的最优解的方法。因为是求每个子问题的最优解，所有动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心是没有状态推导，贪心就是只求当前最好，是从局部直接选最优得到的。所有用贪心求dp问题很容易出现的问题就是：当前是局部最优了，但是不能保证在当前状态下后面的状态也是最优。</p><p>举个例子：</p><blockquote><p>背包问题：有N件物品和一个最大能被重量为W的背包，第 i 件物品的重量是weight[i]，得到的价值是value[i]。每件物品只能用一次，求解将哪些物品装入背包物品的总价值最大。</p><p>动态规划中dp[j] = dp[j - weight[i]] 推导出来的，然后取max(dp[j]m dp[j - weight[i]] + value[i])</p><p>如果是贪心，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。</p><p>所以贪心解决不了动态规划的问题。</p></blockquote><p>始终记得一点：<strong>dp是由前一个状态推导出来的，而贪心是局部直接选最优的</strong></p><p><strong>动态规划有四要素：</strong></p><ol><li>dp数组的定义，状态数组表示含义，往往为一维和二维。  <strong>这个最重要</strong></li><li>根据dp数组的定义，推出状态转移方程。</li><li>状态方程的初始化。</li><li>返回值，是返回dp数组的最后一个元素还是dp数组中的最大值。</li></ol><p><strong>有些情况是递推公式决定了dp数组要如何初始化。</strong></p><p>动规问题一定要自己手推一个样例，自己模拟一遍状态转移方程写出推出来的所有dp数组。</p><p>所以记住一句话：<strong>做动规问题就打表，做回溯问题就画树</strong>， <strong>很重要！！！</strong>。</p><h3 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h3><h4 id="300-最长递增子序列-力扣（LeetCode）"><a href="#300-最长递增子序列-力扣（LeetCode）" class="headerlink" title="300. 最长递增子序列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长递增子序列 - 力扣（LeetCode）</a></h4><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>,<span class="number">18</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长递增子序列是 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>]，因此长度为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>dp[i]的定义：</p><pre><code>dp[i]表示i之前包括i的以nums[i]结尾最长上升子序列的长度</code></pre><p>状态转移方程：</p><pre><code>位置i的最长上升子序列等于j从0到i - 1各个位置的最长上升子序列 + 1的最大值。</code></pre><p>dp[i]的初始化：</p><pre><code>每一个i，对应的dp[i]（即最长上升子序列）起始大小至少都是1。</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        ans, n = <span class="number">1</span>, len(nums)</span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">                    ans = max(ans, dp[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="674-最长连续递增序列-力扣（LeetCode）"><a href="#674-最长连续递增序列-力扣（LeetCode）" class="headerlink" title="674. 最长连续递增序列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">674. 最长连续递增序列 - 力扣（LeetCode）</a></h4><p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p><p>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最长连续递增序列是 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>], 长度为<span class="number">3</span>。</span><br><span class="line">尽管 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>] 也是升序的子序列, 但它不是连续的，因为 <span class="number">5</span> 和 <span class="number">7</span> 在原数组里被 <span class="number">4</span> 隔开。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：最长连续递增序列是 [<span class="number">2</span>], 长度为<span class="number">1</span>。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p><strong>注意此时的转移方程为：<code>dp[i] = dp[i - 1] + 1</code>。</strong>与上面的递增子序列的区别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLengthOfLCIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n, ans = len(nums), <span class="number">1</span></span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i - <span class="number">1</span>]:</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                ans = max(ans, dp[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="53-最大子数组和-力扣（LeetCode）"><a href="#53-最大子数组和-力扣（LeetCode）" class="headerlink" title="53. 最大子数组和 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子数组和 - 力扣（LeetCode）</a></h4><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：连续子数组 [<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">输出：<span class="number">23</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p><strong>一维dp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        temp, ans = nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            temp = max(temp + n, n)</span><br><span class="line">            ans = max(ans, temp)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="hard-72-编辑距离-力扣（LeetCode）"><a href="#hard-72-编辑距离-力扣（LeetCode）" class="headerlink" title="(hard) 72. 编辑距离 - 力扣（LeetCode）"></a>(hard) <a href="https://leetcode.cn/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离 - 力扣（LeetCode）</a></h4><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p><p><strong>示例 1：</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">"horse"</span>, word2 = <span class="string">"ros"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line"><span class="function"><span class="title">horse</span> -&gt;</span> rorse (将 <span class="string">'h'</span> 替换为 <span class="string">'r'</span>)</span><br><span class="line"><span class="function"><span class="title">rorse</span> -&gt;</span> rose (删除 <span class="string">'r'</span>)</span><br><span class="line"><span class="function"><span class="title">rose</span> -&gt;</span> ros (删除 <span class="string">'e'</span>)</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">"intention"</span>, word2 = <span class="string">"execution"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：</span><br><span class="line"><span class="function"><span class="title">intention</span> -&gt;</span> inention (删除 <span class="string">'t'</span>)</span><br><span class="line"><span class="function"><span class="title">inention</span> -&gt;</span> enention (将 <span class="string">'i'</span> 替换为 <span class="string">'e'</span>)</span><br><span class="line"><span class="function"><span class="title">enention</span> -&gt;</span> exention (将 <span class="string">'n'</span> 替换为 <span class="string">'x'</span>)</span><br><span class="line"><span class="function"><span class="title">exention</span> -&gt;</span> exection (将 <span class="string">'n'</span> 替换为 <span class="string">'c'</span>)</span><br><span class="line"><span class="function"><span class="title">exection</span> -&gt;</span> execution (插入 <span class="string">'u'</span>)</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>具体参考：<a href="https://www.programmercarl.com/0072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html#%E6%80%9D%E8%B7%AF" target="_blank" rel="noopener">编辑距离</a> </p><p>二维dp。</p><p>判断word1的第i个字符与word2的第j个字符是否相等，如果相等，则<code>dp[i][j] = dp[i - 1][j - 1]</code>。</p><p>如果不相等，有三种操作：</p><ul><li>将word1的第i个字符删除，<code>dp[i][j] = dp[i - 1][j]</code></li><li>将word2的第j个字符插入，<code>dp[i][j] = dp[i][j - 1]</code></li><li>将word1或者word2的某个字符进行替换，<code>dp[i][j] = dp[i - 1][j - 1]</code></li></ul><p>所有判断上面的最小值然后加1， 1表示当前要执行一次操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        m, n = len(word1), len(word2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> m <span class="keyword">or</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> max(m, n)</span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = j</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = <span class="number">1</span> + min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>背包问题会根据物品的数量可以分为其他子类：</p><p><img src="https://img-blog.csdnimg.cn/20210117171307407.png" alt></p><h4 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h4><p><strong>先遍历物品，再遍历重量</strong></p><p>dp三个关键：</p><ul><li><p>状态矩阵的定义：把dp(i, w)表示为：前i个物品中，组合不超过w重量，得到的最大价值。</p></li><li><p>状态矩阵的初始化：</p></li><li><p>递推公式：<br>$$<br>dp(i, W)= \begin{cases}0 &amp; \text { if } i=0 \ 0 &amp; \text { if } W=0 \ dp(i-1, W) &amp; \text { if } w_{i}&gt;W \ \max \left{dp(i-1, W), v_{i}+dp\left(i-1, W-w_{i}\right)\right} &amp; \text { otherwise }\end{cases}<br>$$</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义二维空数组</span></span><br><span class="line"><span class="comment"># matrix = [[0 for i in range(3)] for i in range(3)]</span></span><br><span class="line"><span class="comment"># matrix = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxpackage</span><span class="params">(thing, wmax)</span>:</span></span><br><span class="line">    <span class="comment"># 01背包问题的不优化写法</span></span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(wmax+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(thing))]  <span class="comment"># 初始化状态矩阵，dp[i][w]表示前i个物品最大w重时最大的价值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(thing)):  <span class="comment"># 遍历所有物品</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> range(<span class="number">1</span>, wmax+<span class="number">1</span>):  <span class="comment"># 遍历所有的重量，一直到最大的wmax重量</span></span><br><span class="line">            <span class="keyword">if</span> thing[i][<span class="string">'w'</span>] &gt; w:</span><br><span class="line">                dp[i][w] = dp[i<span class="number">-1</span>][w]  <span class="comment"># 表示当前的i的物品的重量大于所剩的重量，拿不下</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][w] = max(dp[i<span class="number">-1</span>][w], dp[i<span class="number">-1</span>][w-thing[i][<span class="string">'w'</span>]] + thing[i][<span class="string">'v'</span>])  <span class="comment"># 当能拿下时，两种情况，拿和不拿时的最大价值</span></span><br><span class="line">    <span class="keyword">return</span> dp[len(thing)<span class="number">-1</span>][wmax]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    things = [<span class="literal">None</span>, &#123;<span class="string">'v'</span>: <span class="number">3</span>, <span class="string">'w'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'v'</span>: <span class="number">4</span>, <span class="string">'w'</span>: <span class="number">3</span>&#125;,</span><br><span class="line">              &#123;<span class="string">'v'</span>: <span class="number">8</span>, <span class="string">'w'</span>: <span class="number">4</span>&#125;, &#123;<span class="string">'v'</span>: <span class="number">8</span>, <span class="string">'w'</span>: <span class="number">5</span>&#125;, &#123;<span class="string">'v'</span>: <span class="number">10</span>, <span class="string">'w'</span>: <span class="number">9</span>&#125;]  <span class="comment"># 定义物品重量</span></span><br><span class="line">    wmax = <span class="number">20</span>  <span class="comment"># 所能的最大承重</span></span><br><span class="line">    print(maxpackage(things, wmax))</span><br></pre></td></tr></table></figure><p>空间复杂度可以优化，因为dp[i]只与dp[i-1]有关，所以可以用滚动数组。但是此时得w得从大到小遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxpackage</span><span class="params">(thing, wmax)</span>:</span></span><br><span class="line">    <span class="comment"># 01背包问题的优化写法，空间优化</span></span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(wmax+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(thing)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(wmax, thing[i][<span class="string">'w'</span>]<span class="number">-1</span>, <span class="number">-1</span>):  <span class="comment"># 01背包问题</span></span><br><span class="line">        <span class="comment"># for j in range(thing[i]['w'], wmax+1):  # 完全背包问题</span></span><br><span class="line">            dp[j] = max(dp[j], dp[j-thing[i][<span class="string">'w'</span>]]+thing[i][<span class="string">'v'</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[wmax]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    things = [<span class="literal">None</span>, &#123;<span class="string">'v'</span>: <span class="number">3</span>, <span class="string">'w'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'v'</span>: <span class="number">4</span>, <span class="string">'w'</span>: <span class="number">3</span>&#125;,</span><br><span class="line">              &#123;<span class="string">'v'</span>: <span class="number">8</span>, <span class="string">'w'</span>: <span class="number">4</span>&#125;, &#123;<span class="string">'v'</span>: <span class="number">8</span>, <span class="string">'w'</span>: <span class="number">5</span>&#125;, &#123;<span class="string">'v'</span>: <span class="number">10</span>, <span class="string">'w'</span>: <span class="number">9</span>&#125;]  <span class="comment"># 定义物品重量</span></span><br><span class="line">    wmax = <span class="number">20</span>  <span class="comment"># 所能的最大承重</span></span><br><span class="line">    print(maxpackage(things, wmax))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_1_wei_bag_problem</span><span class="params">()</span>:</span></span><br><span class="line">    weight = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    value = [<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">    bag_weight = <span class="number">4</span></span><br><span class="line">    <span class="comment"># 初始化: 全为0</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (bag_weight + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先遍历物品, 再遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(weight)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(bag_weight, weight[i] - <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># 递归公式</span></span><br><span class="line">            dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</span><br><span class="line"></span><br><span class="line">    print(dp)</span><br><span class="line"></span><br><span class="line">test_1_wei_bag_problem()</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> bagWight = <span class="number">4</span>;</span><br><span class="line">    testWeightBagProblem(weight, value, bagWight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWeightBagProblem</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span>[] value, <span class="keyword">int</span> bagWeight)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wLen = weight.length;</span><br><span class="line">    <span class="comment">//定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[bagWeight + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//遍历顺序：先遍历物品，再遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wLen; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = bagWeight; j &gt;= weight[i]; j--)&#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印dp数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= bagWeight; j++)&#123;</span><br><span class="line">        System.out.print(dp[j] + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h4><p>完全背包问题与01背包问题就一个区别，就是01背包是重量从大到小遍历的，完全背包就是从小到大遍历的。</p><p>01背包的核心代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(weight)):  <span class="comment"># 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(bag_weight, weight[i] - <span class="number">1</span>, <span class="number">-1</span>):  <span class="comment"># 遍历背包容量</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</span><br></pre></td></tr></table></figure><p>01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。</p><p>而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即</p><p>完全背包的核心代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(weight)):  <span class="comment"># 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(weight[i], bag_weight + <span class="number">1</span>):  <span class="comment"># 遍历重量</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</span><br></pre></td></tr></table></figure><h4 id="HJ16、购物单（华为机试题）-https-www-nowcoder-com-practice-f9c6f980eeec43ef85be20755ddbeaf4-tpId-37-amp-tqId-21239-amp-rp-1-amp-ru-exam-oj-ta-amp-qru-exam-oj-ta-amp-sourceUrl-2Fexam-2Foj-2Fta-3FtpId-3D37-amp-difficulty-undefined-amp-judgeStatus-undefined-amp-tags-amp-title"><a href="#HJ16、购物单（华为机试题）-https-www-nowcoder-com-practice-f9c6f980eeec43ef85be20755ddbeaf4-tpId-37-amp-tqId-21239-amp-rp-1-amp-ru-exam-oj-ta-amp-qru-exam-oj-ta-amp-sourceUrl-2Fexam-2Foj-2Fta-3FtpId-3D37-amp-difficulty-undefined-amp-judgeStatus-undefined-amp-tags-amp-title" class="headerlink" title="HJ16、购物单（华为机试题）](https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4?tpId=37&amp;tqId=21239&amp;rp=1&amp;ru=/exam/oj/ta&amp;qru=/exam/oj/ta&amp;sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D37&amp;difficulty=undefined&amp;judgeStatus=undefined&amp;tags=&amp;title=) )"></a>HJ16、<a href="[购物单_牛客题霸_牛客网 (nowcoder.com">购物单（华为机试题）</a>](<a href="https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4?tpId=37&amp;tqId=21239&amp;rp=1&amp;ru=/exam/oj/ta&amp;qru=/exam/oj/ta&amp;sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D37&amp;difficulty=undefined&amp;judgeStatus=undefined&amp;tags=&amp;title=" target="_blank" rel="noopener">https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4?tpId=37&amp;tqId=21239&amp;rp=1&amp;ru=/exam/oj/ta&amp;qru=/exam/oj/ta&amp;sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D37&amp;difficulty=undefined&amp;judgeStatus=undefined&amp;tags=&amp;title=</a>) )</h4><p><strong>描述</strong></p><p>王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p><table><thead><tr><th>主件</th><th>附件</th></tr></thead><tbody><tr><td>电脑</td><td>打印机，扫描仪</td></tr><tr><td>书柜</td><td>图书</td></tr><tr><td>书桌</td><td>台灯，文具</td></tr><tr><td>工作椅</td><td>无</td></tr></tbody></table><p>如果要买归类为附件的物品，必须先买该附件所属的主件，且每件物品只能购买一次。</p><p>每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。</p><p>王强查到了每件物品的价格（都是 10 元的整数倍），而他只有 N 元的预算。除此之外，他给每件物品规定了一个重要度，用整数 1 <strong>~</strong> 5 表示。他希望在花费不超过 N 元的前提下，使自己的满意度达到最大。</p><p>满意度是指所购买的每件物品的价格与重要度的乘积的总和，假设设第ii件物品的价格为v[i]v[i]，重要度为w[i]w[i]，共选中了kk件物品，编号依次为j_1,j_2,…,j_kj1,j2,…,jk，则满意度为：v[j_1]<em>w[j_1]+v[j_2]</em>w[j_2]+ … +v[j_k]<em>w[j_k]v[j1]∗w[j1]+v[j2]∗w[j2]+…+v[jk]∗w[jk]。（其中 </em> 为乘号）</p><p>请你帮助王强计算可获得的最大的满意度。</p><p><strong>输入描述</strong></p><p>输入的第 1 行，为两个正整数N，m，用一个空格隔开：</p><p>（其中 N （ N&lt;32000 ）表示总钱数， m （m &lt;60 ）为可购买的物品的个数。）</p><p>从第 2 行到第 m+1 行，第 j 行给出了编号为 j-1 的物品的基本数据，每行有 3 个非负整数 v p q</p><blockquote><p>（其中 v 表示该物品的价格（ v &lt; 10000 ），</p><p>p 表示该物品的重要度（ 1 ~ 5 ），</p><p>q 表示该物品是主件还是附件。如果 q=0 ，表示该物品为主件，如果 q&gt;0 ，表示该物品为附件， q 是所属主件的编号）</p></blockquote><p><strong>示例1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">1000</span> <span class="number">5</span></span><br><span class="line"><span class="number">800</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="number">400</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">300</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">400</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">500</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line">输出：</span><br><span class="line"><span class="number">2200</span></span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">50</span> <span class="number">5</span></span><br><span class="line"><span class="number">20</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">20</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">10</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">10</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="number">10</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">输出：</span><br><span class="line"><span class="number">130</span></span><br><span class="line">说明：</span><br><span class="line">由第<span class="number">1</span>行可知总钱数N为<span class="number">50</span>以及希望购买的物品个数m为<span class="number">5</span>；</span><br><span class="line">第<span class="number">2</span>和第<span class="number">3</span>行的q为<span class="number">5</span>，说明它们都是编号为<span class="number">5</span>的物品的附件；</span><br><span class="line">第<span class="number">4</span>~<span class="number">6</span>行的q都为<span class="number">0</span>，说明它们都是主件，它们的编号依次为<span class="number">3</span>~<span class="number">5</span>；</span><br><span class="line">所以物品的价格与重要度乘积的总和的最大值为<span class="number">10</span>*<span class="number">1</span>+<span class="number">20</span>*<span class="number">3</span>+<span class="number">20</span>*<span class="number">3</span>=<span class="number">130</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>状态矩阵：<code>dp[things][money]</code>表示前things物品的money下最大的价值。</p><p>将物品的价格（重量）和满意度（价值）定义成一个things*3的数据，其中<code>[thing][0]</code>表示主件的价格和满意度，<code>[thing][1]</code>表示附件1，<code>[things][2]</code>表示附件2，当没有附件时定义为0。</p><p>然后依次遍历dp数组，</p><p>判断当前的钱是否能买主件：<code>j &gt;= weight[i][0]</code>：</p><p>若能：</p><ul><li><code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i][0]] + value[i][0])</code></li><li>判断当前附件1是否为空，且当前的钱能否买主件和附件1：<ul><li><code>dp[i][j] = max(dp[i][j], dp[i-1][j], dp[i-1][j-weight[i][0]-weight[i][1]] + value[i][0] + value[i][1])</code></li></ul></li><li>判断当前的附件2是否为空，且当前的钱能否买主件和附件2：<ul><li><code>dp[i][j] = max(dp[i][j], dp[i-1][j], dp[i-1][j-weight[i][0]-weight[i][2]] + value[i][0] + value[i][2])</code></li></ul></li><li>判断当前的钱是否能同时买组件、附件1和附件2：<ul><li><code>dp[i][j] = max(dp[i][j], dp[i-1][j], dp[i-1][j-sum(weight[i][k] for k in range(0, 3))] + sum(value[i][k] for k in range(0, 3)))</code></li></ul></li></ul><p>若不能买：</p><ul><li><code>dp[i][j] = dp[i-1][j]</code></li></ul><p><strong>相对0-1背包问题，只增加了多余的几种情况，需要考虑是否能同时买主件和附件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n, things = map(int, input().split())</span><br><span class="line">n = n // <span class="number">10</span></span><br><span class="line">weight = [[<span class="number">0</span>]*<span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(things+<span class="number">1</span>)]</span><br><span class="line">value = [[<span class="number">0</span>]*<span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(things+<span class="number">1</span>)]</span><br><span class="line">dp = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(things+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, things+<span class="number">1</span>):</span><br><span class="line">    prices, happy, index = map(int, input().split())</span><br><span class="line">    prices //= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> index:</span><br><span class="line">        weight[i][index], value[i][index] = prices, prices*happy</span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> weight[index][<span class="number">1</span>]: <span class="comment"># 表示第一个附件为空</span></span><br><span class="line">        weight[index][<span class="number">1</span>], value[index][<span class="number">1</span>] = prices, prices*happy</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 表示第二个附件为空</span></span><br><span class="line">        weight[index][<span class="number">2</span>], value[index][<span class="number">2</span>] = prices, prices*happy</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, things+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> j &gt;= weight[i][<span class="number">0</span>]:</span><br><span class="line">            dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i][<span class="number">0</span>]] + value[i][<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> weight[i][<span class="number">1</span>] <span class="keyword">and</span> j &gt;= (weight[i][<span class="number">0</span>] + weight[i][<span class="number">1</span>]):  <span class="comment"># 当前价格支持购买i组件和1附件</span></span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i][<span class="number">0</span>]-weight[i][<span class="number">1</span>]] + value[i][<span class="number">0</span>] + value[i][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> weight[i][<span class="number">2</span>] <span class="keyword">and</span> j &gt;= (weight[i][<span class="number">0</span>] + weight[i][<span class="number">2</span>]):  <span class="comment"># 当前价格支持购买i组件和2附件</span></span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i][<span class="number">0</span>]-weight[i][<span class="number">2</span>]] + value[i][<span class="number">0</span>] + value[i][<span class="number">2</span>])</span><br><span class="line">                <span class="keyword">if</span> j &gt;= sum(weight[i][k] <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">3</span>)):  <span class="comment"># 编号2的附件都有，那么编号1的附件肯定有，判断当前金额够不够买</span></span><br><span class="line">                    dp[i][j] = max(dp[i][j], dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-sum(weight[i][k] <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">3</span>))] + sum(value[i][k] <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">3</span>)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line"></span><br><span class="line">print(dp[things][n]*<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><p>参考：<a href="https://labuladong.gitee.io/algo/3/28/96/" target="_blank" rel="noopener">一个方法团灭 LeetCode 股票买卖问题 :: labuladong的算法小抄 (gitee.io)</a> </p><h3 id="其他乱七八糟的题"><a href="#其他乱七八糟的题" class="headerlink" title="其他乱七八糟的题"></a>其他乱七八糟的题</h3><h4 id="剑指Offer-48-最长不含重复字符的子字符串"><a href="#剑指Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指Offer 48 最长不含重复字符的子字符串 )"></a><a href="[剑指 Offer 48. 最长不含重复字符的子字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指Offer 48 最长不含重复字符的子字符串</a> )</h4><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 </p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: "abcabcbb"</span></span><br><span class="line"><span class="section">输出: 3 </span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: "pwwkew"</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。</span></span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">"pwke"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>状态定义：dp[j]代表以字符s[j]为结尾的“最长不重复子字符串”的长度。</p><p>转移方程：固定右边界j，设字符s[j]左边距离最近的相同字符为s[i]，即s[j]=s[i]</p><ol><li>当i&lt;0时，即s[j]左边无相同字符，则<code>dp[j]=dp[j-1]+1</code></li><li>当<code>dp[j-1] &lt; j-i</code>，说明字符s[i]在子字符串dp[j-1]区间之外，则<code>dp[j] = dp[j-1] + 1</code>。</li><li>当<code>dp[j-1] &gt;= j-i</code>，说明字符s[i]在子字符串dp[j-1]区间之中，则dp[j]的左边界由s[i]决定，即<code>dp[j] = j - i</code>。</li></ol><p>$$<br>d p[j]= \begin{cases}d p[j-1]+1 &amp; , d p[j-1]&lt;j-i \ j-i &amp; , d p[j-1] \geq j-i\end{cases}<br>$$</p><p>动态规划+哈希表：</p><p>哈希表统计：可以用哈希表来存s[j]最后一次出现的索引位置，即上面的i。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        res, temp = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            i = d.get(s[j], <span class="number">-1</span>)</span><br><span class="line">            d[s[j]] = j</span><br><span class="line">            temp = temp + <span class="number">1</span> <span class="keyword">if</span> temp &lt; j - i <span class="keyword">else</span> (j - i)</span><br><span class="line">            res = max(res, temp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-62-圆圈中最后剩下的数字-力扣（LeetCode）（22届顺丰笔试）"><a href="#剑指-Offer-62-圆圈中最后剩下的数字-力扣（LeetCode）（22届顺丰笔试）" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字 - 力扣（LeetCode）（22届顺丰笔试）"></a><a href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener"><strong>剑指 Offer 62. 圆圈中最后剩下的数字 - 力扣（LeetCode）（22届顺丰笔试）</strong></a></h4><p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: n = 5, m = 3</span></span><br><span class="line"><span class="section">输出: 3</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: n = 10, m = 17</span></span><br><span class="line"><span class="section">输出: 2</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>约瑟夫环问题：</p><p>动态规划解析：</p><ul><li>状态定义：设[i, m] 的解为 dp[i]；</li><li>转移方程：通过以下方式可从 dp[i-1]递推得到dp[i]；<ul><li><code>dp[i] = (dp[i - 1] + m) % i</code></li></ul></li><li>初始状态：[1, m]问题的解恒为0，即dp[i] = 0</li><li>返回值：返回[n, m]问题的解dp[n]；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastRemaining</span><span class="params">(self, n: int, m: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        f = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            f = (f + m) % i</span><br><span class="line">        <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure><h4 id="22-括号生成-力扣（LeetCode）"><a href="#22-括号生成-力扣（LeetCode）" class="headerlink" title="22. 括号生成 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成 - 力扣（LeetCode）</a></h4><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。 </p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">3</span></span><br><span class="line">输出：[<span class="string">"((()))"</span>,<span class="string">"(()())"</span>,<span class="string">"(())()"</span>,<span class="string">"()(())"</span>,<span class="string">"()()()"</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">1</span></span><br><span class="line">输出：[<span class="string">"()"</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>dp</p><p>dp[i]为一个矩阵，里面保存的是i对括号的所有可能。</p><p>然后可以发现，每次加一对括号时，dp[i + 1]的结果，就是将前面的i对括号的结果分别可以分开放在当前()的里面或者外面，</p><p>假设放在括号里面的为p，放在外面的为q，那么当前的dp[i + 1]就为 ( + p + ) + q。</p><p>所有遍历p和q所有的可能就行，p + q = i</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line"></span><br><span class="line">        dp = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = [<span class="string">""</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                p = dp[j]</span><br><span class="line">                q = dp[i - <span class="number">1</span> - j]</span><br><span class="line">                <span class="keyword">for</span> k1 <span class="keyword">in</span> p:</span><br><span class="line">                    <span class="keyword">for</span> k2 <span class="keyword">in</span> q:</span><br><span class="line">                        dp[i].append(<span class="string">'('</span> + k1 + <span class="string">')'</span> + k2)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h4 id="hard-32-最长有效括号-力扣（LeetCode）"><a href="#hard-32-最长有效括号-力扣（LeetCode）" class="headerlink" title="(hard) 32. 最长有效括号 - 力扣（LeetCode）"></a>(hard) <a href="https://leetcode.cn/problems/longest-valid-parentheses/" target="_blank" rel="noopener">32. 最长有效括号 - 力扣（LeetCode）</a></h4><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。 </p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"(()"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最长有效括号子串是 <span class="string">"()"</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">")()())"</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长有效括号子串是 <span class="string">"()()"</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">""</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>dp思路： dp[i]表示以下标i字符结尾的最长有效括号的长度，将dp全部初始化为0，有效的子串一定是以’)’结尾的，返回dp的最大值。</p><p>从前往后遍历字符串求解dp值，每两个字符检查一次：</p><ol><li>s[i] = ‘)’ 且 s[i - 1] = ‘(‘，也就是字符串形如”……..()”，可以得到：<code>dp[i]  = dp[i - 2] + 2</code>。</li><li>s[i] = ‘)’ 且 s[i - 1] = ‘)’，也就是字符串形如”………))”，我们可以推出：如果s[i - dp[i - 1] - 1] = ‘(‘，那么<code>dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2</code>。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        s, dp = list(s), [<span class="number">0</span>] * (len(s))</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> i - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i - <span class="number">1</span>] == <span class="string">'('</span>:</span><br><span class="line">                    dp[i] = (dp[i - <span class="number">2</span>] <span class="keyword">if</span> i - <span class="number">2</span> &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>) + <span class="number">2</span></span><br><span class="line">                <span class="keyword">elif</span> i - <span class="number">1</span> - dp[i - <span class="number">1</span>] &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i - <span class="number">1</span> - dp[i - <span class="number">1</span>]] == <span class="string">'('</span>:</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + (dp[i - <span class="number">1</span> - dp[i - <span class="number">1</span>] - <span class="number">1</span>] <span class="keyword">if</span> i - <span class="number">1</span> - dp[i - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>) + <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            res = max(res, dp[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>栈</strong></p><p>始终保持栈底元素为当前已经遍历过的元素中[最后一个没有被匹配的右括号的下标]，</p><ul><li>对于遇到的每个’(‘，将它的下标放入栈中。</li><li>对于遇到的每个’)’，我们先弹出栈顶元素表示匹配了当前右括号：<ul><li>如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的[最后一个没有被匹配的右括号的下标]</li><li>如果栈不为空，当前右括号的下标减去栈顶元素即为[以该右括号为结尾的最长有效括号的长度]</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        stack, res = [<span class="number">-1</span>], <span class="number">0</span></span><br><span class="line">        s = list(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    stack.append(i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res = max(res, i - stack[<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="96-不同的二叉搜索树-力扣（LeetCode）"><a href="#96-不同的二叉搜索树-力扣（LeetCode）" class="headerlink" title="96. 不同的二叉搜索树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树 - 力扣（LeetCode）</a></h4><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。 </p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>dp，遍历根节点，然后把根节点左边的数能形成的二叉搜索树总数乘上右边的数能形成的二叉搜索树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h1 id="基础算法模板"><a href="#基础算法模板" class="headerlink" title="基础算法模板"></a>基础算法模板</h1><h4 id="单调栈模板"><a href="#单调栈模板" class="headerlink" title="单调栈模板"></a>单调栈模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出每个数左边离它最近的比它大/小的数</span><br><span class="line"><span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; check(stk[tt], i)) tt -- ;</span><br><span class="line">    stk[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单调队列模板"><a href="#单调队列模板" class="headerlink" title="单调队列模板"></a>单调队列模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="line"><span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速幂求余"><a href="#快速幂求余" class="headerlink" title="快速幂求余"></a>快速幂求余</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求 (x^a) % p —— 快速幂求余</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remainder</span><span class="params">(x, a, p)</span>:</span></span><br><span class="line">    rem = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> a % <span class="number">2</span>: rem = (rem * x) % p</span><br><span class="line">        x = x ** <span class="number">2</span> % p</span><br><span class="line">        a //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> rem</span><br></pre></td></tr></table></figure><h4 id="获取一个数字的二进制"><a href="#获取一个数字的二进制" class="headerlink" title="获取一个数字的二进制"></a>获取一个数字的二进制</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getBin</span><span class="params">(n: int)</span> -&gt; str:</span></span><br><span class="line">    <span class="string">"""获取一个数字的二进制"""</span></span><br><span class="line">    b = str(bin(n))</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> b[<span class="number">3</span>:]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> b[<span class="number">2</span>:]</span><br></pre></td></tr></table></figure><h4 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line">print(list(permutations([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])))  <span class="comment"># [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]</span></span><br></pre></td></tr></table></figure><h4 id="判断回文数"><a href="#判断回文数" class="headerlink" title="判断回文数"></a>判断回文数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(x: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="string">"""判断是否是回文数"""</span></span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">-1</span> <span class="keyword">and</span> str(x)[::<span class="number">-1</span>] == str(x)</span><br></pre></td></tr></table></figure><h4 id="字典排序"><a href="#字典排序" class="headerlink" title="字典排序"></a>字典排序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">d = dict(collections.Counter(<span class="string">'Hello World'</span>))</span><br><span class="line"><span class="comment">#  d.items() 是  [(k, v), (k, v),(k, v)...] 组成的列表</span></span><br><span class="line">print(sorted(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure><h4 id="字典计数"><a href="#字典计数" class="headerlink" title="字典计数"></a>字典计数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一共有三种初始方法</span></span><br><span class="line"><span class="comment"># 1. 传入一个序列</span></span><br><span class="line">print(collections.Counter([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>]))</span><br><span class="line"><span class="comment"># 2.传入一个字典</span></span><br><span class="line">print(collections.Counter(&#123;<span class="string">'a'</span>: <span class="number">2</span>, <span class="string">'b'</span>: <span class="number">3</span>, <span class="string">'c'</span>: <span class="number">1</span>&#125;))</span><br><span class="line"><span class="comment"># 3.直接利用=传参</span></span><br><span class="line">print(collections.Counter(a=<span class="number">2</span>, b=<span class="number">3</span>, c=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h4 id="最大公约数gcd"><a href="#最大公约数gcd" class="headerlink" title="最大公约数gcd"></a>最大公约数gcd</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(n1, n2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> gcd(n2, n1 % n2) <span class="keyword">if</span> n2 &gt; <span class="number">0</span> <span class="keyword">else</span> n1</span><br></pre></td></tr></table></figure><h4 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(n1, n2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> gcd(n2, n1 % n2) <span class="keyword">if</span> n2 &gt; <span class="number">0</span> <span class="keyword">else</span> n1</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcm</span><span class="params">(n1, n2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n1 * n2 // gcd(n1, n2)</span><br></pre></td></tr></table></figure><h4 id="序列组合"><a href="#序列组合" class="headerlink" title="序列组合"></a>序列组合</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line"></span><br><span class="line">print(list(combinations([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>)))  <span class="comment"># [(1, 2), (1, 3), (2, 3)]</span></span><br></pre></td></tr></table></figure><h4 id="组合数方案"><a href="#组合数方案" class="headerlink" title="组合数方案"></a>组合数方案</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">c</span><span class="params">(m, n)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    <span class="keyword">return</span> math.factorial(n) // (math.factorial(m) * math.factorial(n - m))</span><br></pre></td></tr></table></figure><h4 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">23</span>, <span class="number">131</span>, <span class="number">5</span>, <span class="number">124</span>, <span class="number">35</span>]</span><br><span class="line">arr = sorted(arr, key=<span class="keyword">lambda</span> item: item, reverse=<span class="literal">True</span>)</span><br><span class="line">print(arr)</span><br></pre></td></tr></table></figure><h4 id="素数打表"><a href="#素数打表" class="headerlink" title="素数打表"></a>素数打表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrim</span><span class="params">(n: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="string">"""判断是否是质数  O(✓n)"""</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(n ** <span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countPrim</span><span class="params">(n: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="string">"""[0, n) 内有多少个质数 厄拉多塞筛法 O(n*(?n))"""</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    signs = [<span class="literal">True</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> signs[i]:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + i, n, i):</span><br><span class="line">                signs[j] = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h1 id="竞赛技巧"><a href="#竞赛技巧" class="headerlink" title="竞赛技巧"></a>竞赛技巧</h1><h4 id="根据数据范围选择方法："><a href="#根据数据范围选择方法：" class="headerlink" title="根据数据范围选择方法："></a>根据数据范围选择方法：</h4><ol><li>做算法题代码的操作次数应该控制在$10 ^ {8}$以内最佳，否则一般会TLE。</li><li>$ n \leq 30 $，指数级别，一般可以dfs+剪枝，状态压缩dp。</li><li>$ n  \leq 100 $ =&gt; $ O(n ^ {3}) $，可以三维dp，三维for循环，或者最短路径的floyd。</li><li>$ n  \leq 1000 $ =&gt; $ O(n ^ {2}), O(n ^ {2} log n) $，dp，二分，</li><li>$ n \leq 10 ^ {5} $，支持sort，set/map，二分，</li><li>$ n \leq 10 ^ {6} $，单调栈、单调队列，只能一次for，hash，双指针，并查集，kmp，</li><li>$ n \leq 10 ^ {8} $，双指针，kmp，二分，最多只能支持一次for，线性筛素数。</li><li>$ n \leq 10 ^ {9}$ &gt;= $ O(\sqrt n)$，判断素数或者质数，只能支持根号级别的循环。</li><li>$ n \leq 10 ^ {18} $ &gt;= $O(log n)$，最大公约数，快速幂。</li><li>$ n \leq 10 ^ {1000} $ &gt;= $ O((log n) \times 2)$ ，高精度加减乘除，将数字转字符串。</li></ol><h4 id="顺时针旋转数组"><a href="#顺时针旋转数组" class="headerlink" title="顺时针旋转数组"></a>顺时针旋转数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrix = [[row[j] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)] <span class="comment"># 顺时针旋转90度</span></span><br></pre></td></tr></table></figure><h4 id="二分计算中位数防止整数越界"><a href="#二分计算中位数防止整数越界" class="headerlink" title="二分计算中位数防止整数越界"></a>二分计算中位数防止整数越界</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mid = (m + n) // 2</span></span><br><span class="line">mid = m + (n - m) // <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="向上取整转化为向下取整"><a href="#向上取整转化为向下取整" class="headerlink" title="向上取整转化为向下取整"></a>向上取整转化为向下取整</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果要对 b / a 向上取整，可以转换为 对 (b + (a - 1) ) / a 向下取整。</span></span><br><span class="line">对 b / a 向上取整，即为   == (b + (a - <span class="number">1</span>)) // a</span><br></pre></td></tr></table></figure><h4 id="有序set、list、dict的库"><a href="#有序set、list、dict的库" class="headerlink" title="有序set、list、dict的库"></a>有序set、list、dict的库</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedSet <span class="keyword">as</span> SS</span><br><span class="line"><span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedDict</span><br><span class="line"><span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedSet</span><br><span class="line"><span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> sortedlist</span><br></pre></td></tr></table></figure><h4 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br></pre></td></tr></table></figure><h4 id="回溯问题模板"><a href="#回溯问题模板" class="headerlink" title="回溯问题模板"></a>回溯问题模板</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 符合条件的结果集合</span></span><br><span class="line">ans = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trackback</span><span class="params">(路径，选择列表)</span>：</span></span><br><span class="line"><span class="function"><span class="title">if</span> 满足结束条件：</span></span><br><span class="line"><span class="function">    <span class="title">ans</span>.<span class="title">append</span><span class="params">(list<span class="params">(路径)</span>)</span></span></span><br><span class="line"><span class="function">        <span class="title">return</span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">    <span class="title">for</span> 选择：选择列表：</span></span><br><span class="line"><span class="function">    剪枝</span></span><br><span class="line"><span class="function">    做选择</span></span><br><span class="line"><span class="function">        <span class="title">backtrack</span><span class="params">(路径，选择列表)</span></span></span><br><span class="line"><span class="function">        撤销选择</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;p&gt;线性结构：数组、队列、栈、链表&lt;/p&gt;
&lt;p&gt;非线性结构：树，&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>杂题集锦</title>
    <link href="http://yoursite.com/2022/07/05/%E6%9D%82%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://yoursite.com/2022/07/05/杂题集锦/</id>
    <published>2022-07-05T12:34:54.902Z</published>
    <updated>2022-08-09T16:27:24.785Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代码技巧知识点"><a href="#代码技巧知识点" class="headerlink" title="代码技巧知识点"></a>代码技巧知识点</h3><a id="more"></a><h4 id="顺时针旋转数组"><a href="#顺时针旋转数组" class="headerlink" title="顺时针旋转数组"></a>顺时针旋转数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrix = [[row[j] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)] <span class="comment"># 顺时针旋转90度</span></span><br></pre></td></tr></table></figure><h4 id="快速幂求余"><a href="#快速幂求余" class="headerlink" title="快速幂求余"></a>快速幂求余</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求 (x^a) % p —— 快速幂求余</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remainder</span><span class="params">(x, a, p)</span>:</span></span><br><span class="line">    rem = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> a % <span class="number">2</span>: rem = (rem * x) % p</span><br><span class="line">        x = x ** <span class="number">2</span> % p</span><br><span class="line">        a //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> rem</span><br></pre></td></tr></table></figure><h4 id="二分计算中位数防止整数越界"><a href="#二分计算中位数防止整数越界" class="headerlink" title="二分计算中位数防止整数越界"></a>二分计算中位数防止整数越界</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mid = (m + n) // 2</span></span><br><span class="line">mid = m + (n - m) // <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="向上取整转化为向下取整"><a href="#向上取整转化为向下取整" class="headerlink" title="向上取整转化为向下取整"></a>向上取整转化为向下取整</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果要对 b / a 向上取整，可以转换为 对 (b + (a - 1) ) / a 向下取整。</span></span><br><span class="line">对 b / a 向上取整，即为   == (b + (a - <span class="number">1</span>)) // a</span><br></pre></td></tr></table></figure><h4 id="有序set、list、dict的库"><a href="#有序set、list、dict的库" class="headerlink" title="有序set、list、dict的库"></a>有序set、list、dict的库</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedSet <span class="keyword">as</span> SS</span><br><span class="line"><span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedDict</span><br><span class="line"><span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedSet</span><br><span class="line"><span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> sortedlist</span><br></pre></td></tr></table></figure><h4 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br></pre></td></tr></table></figure><h4 id="回溯问题模板"><a href="#回溯问题模板" class="headerlink" title="回溯问题模板"></a>回溯问题模板</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 符合条件的结果集合</span></span><br><span class="line">ans = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trackback</span><span class="params">(路径，选择列表)</span>：</span></span><br><span class="line"><span class="function"><span class="title">if</span> 满足结束条件：</span></span><br><span class="line"><span class="function">    <span class="title">ans</span>.<span class="title">append</span><span class="params">(list<span class="params">(路径)</span>)</span></span></span><br><span class="line"><span class="function">        <span class="title">return</span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">    <span class="title">for</span> 选择：选择列表：</span></span><br><span class="line"><span class="function">    剪枝</span></span><br><span class="line"><span class="function">    做选择</span></span><br><span class="line"><span class="function">        <span class="title">backtrack</span><span class="params">(路径，选择列表)</span></span></span><br><span class="line"><span class="function">        撤销选择</span></span><br></pre></td></tr></table></figure><h3 id="杂题集锦"><a href="#杂题集锦" class="headerlink" title="杂题集锦"></a>杂题集锦</h3><h4 id="牛客联系赛101、A千层蛋糕-https-ac-nowcoder-com-acm-contest-11247-A"><a href="#牛客联系赛101、A千层蛋糕-https-ac-nowcoder-com-acm-contest-11247-A" class="headerlink" title="牛客联系赛101、A千层蛋糕](https://ac.nowcoder.com/acm/contest/11247/A) )"></a><a href="[A-千层蛋糕_牛客练习赛101 (nowcoder.com">牛客联系赛101、A千层蛋糕</a>](<a href="https://ac.nowcoder.com/acm/contest/11247/A" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/11247/A</a>) )</h4><p>给出一个长度为n的序列a，定义$b_{i}$为$a_{1 \sim i}$中的最大值，$c_{i}$为 $a_{1\sim i}$的最小值。现在你可以将$a$重新排列，要求最大化$\sum_{i=1}^{n}\left(b_{i}-c_{i}\right)$并输出这个值。</p><p><em>输入描述</em></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行输入一个正整数 n (<span class="number">1</span>≤n≤<span class="number">10</span>^<span class="number">6</span>)。</span><br><span class="line"></span><br><span class="line">接下来一行 n 个正整数表示序列 ai (<span class="number">1</span>≤ai≤<span class="number">10</span>^<span class="number">9</span>)。</span><br></pre></td></tr></table></figure><p><em>输出描述</em></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一行一个整数，表示重排序列 <span class="selector-tag">a</span> 后上面表达式的最大值。</span><br></pre></td></tr></table></figure><p><em>示例1</em></p><blockquote><p>输入：</p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;<span class="number">5</span></span><br><span class="line">&gt; &gt;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p>输出：</p><blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; &gt; 16</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br></pre></td></tr></table></figure></blockquote></blockquote><p><em>示例2</em></p><blockquote><p>输入：</p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; <span class="number">3</span></span><br><span class="line">&gt; &gt; <span class="number">4</span> <span class="number">8</span> <span class="number">1</span></span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p>输出：</p><blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; &gt; 14</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br></pre></td></tr></table></figure></blockquote></blockquote><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    n = int(input())</span><br><span class="line">    arr = list(map(int, input().split()))</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>: print(<span class="number">0</span>, end=<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print((max(arr) - min(arr)) * (n<span class="number">-1</span>), end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="牛客练习赛101、B荒神在此-https-ac-nowcoder-com-acm-contest-11247-B"><a href="#牛客练习赛101、B荒神在此-https-ac-nowcoder-com-acm-contest-11247-B" class="headerlink" title="牛客练习赛101、B荒神在此](https://ac.nowcoder.com/acm/contest/11247/B) )"></a><a href="[B-荒神在此_牛客练习赛101 (nowcoder.com">牛客练习赛101、B荒神在此</a>](<a href="https://ac.nowcoder.com/acm/contest/11247/B" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/11247/B</a>) )</h4><p>给出一个数$n$，求有多少个长度为$n$的序列$a$（下标为$1 \sim n$），要求满足：</p><ol><li>对于所有$i \in[1, n], \quad 0 \leq a_{i} \leq i$。</li><li>$\sum_{i=1}^{n} i \times a_{i}$ 是一个奇数</li></ol><p>因为答案很大，所以需要输出答案对 998244353 取模。</p><p><em>输入描述</em></p><p>第一行给出一个正整数n （1 &lt;= n &lt;= 10 ^7）</p><p><em>输出描述</em></p><p>输出一行一个整数表示对998244353取模后的答案</p><p><strong>示例1</strong></p><blockquote><p>输入</p><blockquote><p>2</p></blockquote><p>输出</p><blockquote><p>3</p></blockquote></blockquote><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    n = int(input())</span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        res = (res * (i + <span class="number">1</span>)) % <span class="number">998244353</span></span><br><span class="line">    print(res, end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="牛客练习赛101、C推理小丑-https-ac-nowcoder-com-acm-contest-11247-C"><a href="#牛客练习赛101、C推理小丑-https-ac-nowcoder-com-acm-contest-11247-C" class="headerlink" title="牛客练习赛101、C推理小丑](https://ac.nowcoder.com/acm/contest/11247/C) )"></a><a href="[C-推理小丑_牛客练习赛101 (nowcoder.com">牛客练习赛101、C推理小丑</a>](<a href="https://ac.nowcoder.com/acm/contest/11247/C" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/11247/C</a>) )</h4><p>给出一个长度为$n$的序列$a$，满足$ a_{i} &lt; a_{i+1} (i \in [1, n-1])$。</p><p>要求一个最小的x满足$ a_{i} and x &lt; a_{i+1} and x (i \in [1, n-1])$。</p><p>其中$and$表示按位与：将两个整数作为二进制数，对二进制表示中的每一位逐一运算，只有对应的两个二进位都为1时，结果位才为1。</p><p><em>输入描述</em></p><p>第一行给出一个正整数$n$ $(1 \leq n \leq 10^{5})$</p><p>接下来一行给出n 个非负整数表示$a_{i}$ $(0 \leq a_{i} \leq 2^{31})$</p><p><em>输出描述</em></p><p>输出一行一个非负整数表示满足条件最小的$x$。</p><p><strong>示例1</strong></p><blockquote><p>输入</p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; <span class="number">5</span></span><br><span class="line">&gt; &gt; <span class="number">0</span> <span class="number">2</span> <span class="number">5</span> <span class="number">114</span> <span class="number">514</span></span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p>输出</p><blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; &gt; 534</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br></pre></td></tr></table></figure></blockquote></blockquote><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    n = int(input())</span><br><span class="line">    arr = list(map(int, input().split()))</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &amp; ans) &lt; (arr[i+<span class="number">1</span>] &amp; ans): <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">99999</span>):</span><br><span class="line">                <span class="keyword">while</span> temp &amp; ans:</span><br><span class="line">                    temp &lt;&lt;= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> arr[i] &amp; (temp + ans) &lt; arr[i+<span class="number">1</span>] &amp; (temp + ans): <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp &lt;&lt;= <span class="number">1</span></span><br><span class="line">        ans += temp</span><br><span class="line">    print(ans, end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="LeetCode299场周赛、2、统计放置放置的方式数"><a href="#LeetCode299场周赛、2、统计放置放置的方式数" class="headerlink" title="LeetCode299场周赛、2、统计放置放置的方式数 )"></a><a href="[2320. 统计放置房子的方式数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-number-of-ways-to-place-houses/">LeetCode299场周赛、2、统计放置放置的方式数</a> )</h4><p>一条街道上共有 n * 2 个 地块 ，街道的两侧各有 n 个地块。每一边的地块都按从 1 到 n 编号。每个地块上都可以放置一所房子。</p><p>现要求街道同一侧不能存在两所房子相邻的情况，请你计算并返回放置房屋的方式数目。由于答案可能很大，需要对 10^9 + 7 取余后再返回。</p><p>注意，如果一所房子放置在这条街某一侧上的第 i 个地块，不影响在另一侧的第 i 个地块放置房子。</p><p><strong>示例1</strong></p><blockquote><p>输入：n = 1<br>输出：4<br>解释：<br>可能的放置方式：</p><ol><li>所有地块都不放置房子。</li><li>一所房子放在街道的某一侧。</li><li>一所房子放在街道的另一侧。</li><li>放置两所房子，街道两侧各放置一所。</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countHousePlacements</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = &#123;<span class="string">'0'</span>: [<span class="number">1</span>] * (n+<span class="number">1</span>), <span class="string">'1'</span>: [<span class="number">1</span>] * (n+<span class="number">1</span>)&#125;  <span class="comment"># 0表示不放，1表示放房子</span></span><br><span class="line">        mod = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="string">'0'</span>][i] = (dp[<span class="string">'0'</span>][i<span class="number">-1</span>] + dp[<span class="string">'1'</span>][i<span class="number">-1</span>]) % mod</span><br><span class="line">            dp[<span class="string">'1'</span>][i] = dp[<span class="string">'0'</span>][i<span class="number">-1</span>] % mod</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> int((dp[<span class="string">'0'</span>][n] + dp[<span class="string">'1'</span>][n]) ** <span class="number">2</span> % mod)</span><br></pre></td></tr></table></figure><h4 id="LeetCode299场周赛、2、拼接数组的最大分数"><a href="#LeetCode299场周赛、2、拼接数组的最大分数" class="headerlink" title="LeetCode299场周赛、2、拼接数组的最大分数 )"></a><a href="[2321. 拼接数组的最大分数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-score-of-spliced-array/">LeetCode299场周赛、2、拼接数组的最大分数</a> )</h4><p>给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，长度都是 n 。</p><p>你可以选择两个整数 left 和 right ，其中 0 &lt;= left &lt;= right &lt; n ，接着 交换 两个子数组 nums1[left…right] 和 nums2[left…right] 。</p><p>例如，设 nums1 = [1,2,3,4,5] 和 nums2 = [11,12,13,14,15] ，整数选择 left = 1 和 right = 2，那么 nums1 会变为 [1,12,13,4,5] 而 nums2 会变为 [11,2,3,14,15] 。<br>你可以选择执行上述操作 一次 或不执行任何操作。</p><p>数组的 分数 取 sum(nums1) 和 sum(nums2) 中的最大值，其中 sum(arr) 是数组 arr 中所有元素之和。</p><p>返回 可能的最大分数 。</p><p>子数组 是数组中连续的一个元素序列。arr[left…right] 表示子数组包含 nums 中下标 left 和 right 之间的元素（含 下标 left 和 right 对应元素）。</p><p><strong>示例 1</strong></p><blockquote><p>输入：nums1 = [60,60,60], nums2 = [10,90,10]<br>输出：210<br>解释：选择 left = 1 和 right = 1 ，得到 nums1 = [60,90,60] 和 nums2 = [10,60,10] 。<br>分数为 max(sum(nums1), sum(nums2)) = max(210, 80) = 210 。</p></blockquote><p><strong>示例2</strong></p><blockquote><p>输入：nums1 = [20,40,20,70,30], nums2 = [50,20,50,40,20]<br>输出：220<br>解释：选择 left = 3 和 right = 4 ，得到 nums1 = [20,40,20,40,20] 和 nums2 = [50,20,50,70,30] 。<br>分数为 max(sum(nums1), sum(nums2)) = max(140, 220) = 220 。</p></blockquote><p><strong>示例3</strong></p><blockquote><p>输入：nums1 = [7,11,13], nums2 = [1,1,1]<br>输出：31<br>解释：选择不交换任何子数组。<br>分数为 max(sum(nums1), sum(nums2)) = max(31, 3) = 31 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumsSplicedArray</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(a: List[int], b: List[int])</span>:</span></span><br><span class="line">            temp, dt = <span class="number">0</span> , <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">                temp = max(<span class="number">0</span>, temp + (b[i] - a[i]))</span><br><span class="line">                dt = max(dt, temp)</span><br><span class="line">            <span class="keyword">return</span> sum(a) + dt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(work(nums1, nums2), work(nums2, nums1))</span><br></pre></td></tr></table></figure><h4 id="LeetCode298场周赛、2、个位数字为K的整数之和"><a href="#LeetCode298场周赛、2、个位数字为K的整数之和" class="headerlink" title="LeetCode298场周赛、2、个位数字为K的整数之和 )"></a><a href="[2310. 个位数字为 K 的整数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-numbers-with-units-digit-k/">LeetCode298场周赛、2、个位数字为K的整数之和</a> )</h4><p>给你两个整数 num 和 k ，考虑具有以下属性的正整数多重集：</p><p>每个整数个位数字都是 k 。<br>所有整数之和是 num 。<br>返回该多重集的最小大小，如果不存在这样的多重集，返回 -1 。</p><p>注意：</p><p>多重集与集合类似，但多重集可以包含多个同一整数，空多重集的和为 0 。<br>个位数字 是数字最右边的数位。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">58</span>, k = <span class="number">9</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">多重集 [<span class="number">9</span>,<span class="number">49</span>] 满足题目条件，和为 <span class="number">58</span> 且每个整数的个位数字是 <span class="number">9</span> 。</span><br><span class="line">另一个满足条件的多重集是 [<span class="number">19</span>,<span class="number">39</span>] 。</span><br><span class="line">可以证明 <span class="number">2</span> 是满足题目条件的多重集的最小长度。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">37</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：个位数字为 <span class="number">2</span> 的整数无法相加得到 <span class="number">37</span> 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">0</span>, k = <span class="number">7</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：空多重集的和为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>所有整数之和num 的个位数一定是由若干个个位数为k的数相加才能得到的，所以枚举，从1开始枚举，用num减去n个个位数字为k的数，看最后的结果是不是10的倍数（即余10是不是为0），若是，则说明满足，将那个余10为0 的数随便加在某个个位数字k的数上面都行。当n个个位数字位k的数的和大于num时，说明当前没有这样的多重集。</p><p>需要判断两个特殊情况，num为0时，空的多重集的和为0，当k为0时，说明当前的num必须为10的倍数的时候才能有多重集且最少可以有1个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumNumbers</span><span class="params">(self, num: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> num % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> res * k &lt;= num:</span><br><span class="line">            <span class="keyword">if</span> (num - res * k) % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="D-Breezing-牛客小白月赛53-nowcoder-com"><a href="#D-Breezing-牛客小白月赛53-nowcoder-com" class="headerlink" title="D-Breezing_牛客小白月赛53 (nowcoder.com)"></a><a href="https://ac.nowcoder.com/acm/contest/11230/D" target="_blank" rel="noopener">D-Breezing_牛客小白月赛53 (nowcoder.com)</a></h4><p>勇敢牛牛得到一个数列$B_{i}$，他认为这个数列不够可爱，于是决定重新创造一个数列A，规则如下：</p><ul><li>对于所有的$i$，需要保证$A_{i}$在$[1, B_{i}]$这个区间内。</li></ul><p>现在，我们称数列A的可爱值k为[数列A中相邻两个数差的绝对值的和]，求最大的可爱值。</p><p><em>输入描述</em></p><blockquote><p>第一行，一个正整数 n ($ 2 \leq n \leq 10^{5} $)</p><p>第二行，n个正整数，表示数列B中的数，$ 1 \leq B_{i} \leq 10^{4} $</p></blockquote><p><em>输出描述</em></p><blockquote><p>一行，一个非负整数表示最大的可爱值 k。</p></blockquote><p><strong>示例1</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">11</span> <span class="number">45</span> <span class="number">14</span> <span class="number">19</span> <span class="number">1</span> <span class="number">9</span> <span class="number">8</span> <span class="number">10</span></span><br><span class="line">输出：</span><br><span class="line"><span class="number">149</span></span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">107</span> <span class="number">97</span> <span class="number">119</span> <span class="number">97</span> <span class="number">105</span> <span class="number">105</span></span><br><span class="line">输出：</span><br><span class="line"><span class="number">550</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>状态机的dp</p><p><code>dp[i][0]</code>表示i位置为最大值$B_{i}$时候的最大可爱值，<code>dp[i][1]</code>表示i位置为最小值1时候的最大可爱值。</p><p>则每次针对当前的位置i，需要考虑到前面为最大值和最小值两种情况，所有有两个dp转移方程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    n = int(input())</span><br><span class="line">    arr = list(map(int, input().split()))</span><br><span class="line">    dp = [[<span class="number">0</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + abs(arr[i] - <span class="number">1</span>), dp[i<span class="number">-1</span>][<span class="number">0</span>] + abs(arr[i] - arr[i - <span class="number">1</span>]))</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] + abs(arr[i<span class="number">-1</span>] - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    print(max(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]), end=<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="4492-减法操作-AcWing题库"><a href="#4492-减法操作-AcWing题库" class="headerlink" title="4492. 减法操作 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/4495/" target="_blank" rel="noopener">4492. 减法操作 - AcWing题库</a></h4><p>给定一个整数n，执行如下算法：</p><ol><li>如果 n = 0，则结束算法。</li><li>找到n的最小质因子d。</li><li>令n减去d并跳转步骤1。</li></ol><p>请你计算，在算法执行的过程中，一共进行了多少次减法操作。</p><p><em>输入格式</em></p><p>一个整数n</p><p><em>输出格式</em></p><p>一个整数，表示减法操作的次数。</p><p><strong>数据范围</strong></p><p>$ 2 \leq n \leq 10^{10} $</p><p><strong>示例1</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">5</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">输入：<span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>质因子：如果b能被a整除，则称a为b的质因子。</p><p>可以发现，如果当前这个数为偶数，那么它的最小质因子一定是2，减去2之后还是为偶数，所以可以发现偶数的减法操作就为n / 2</p><p>奇数的最小质因子一定为奇数，那么当这个奇数减去一个最小的质因子，剩下的数一定是偶数，假设这个最小质因子为x，那么剩下的减法操作为(n - x) / 2，加上减去那个奇数的最小质因子，所以总共的减法操作为： 1 + (n - x) / 2</p><p>找最小质因子，用试除法，遍历到sqrt(n)就行。</p><p><strong>其实奇数只要不是素数，那么它的最小质因子一定是3或5或7，如果是素数，就直接前去他自己就行</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isprime</span><span class="params">(m)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(sqrt(m)) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> m % i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    n = int(input())</span><br><span class="line">    flag = isprime(n)</span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        print(<span class="number">1</span> + (n - flag) // <span class="number">2</span>, end=<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="number">1</span>, end=<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="2336-无限集中的最小数字-力扣（LeetCode）"><a href="#2336-无限集中的最小数字-力扣（LeetCode）" class="headerlink" title="2336. 无限集中的最小数字 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/smallest-number-in-infinite-set/" target="_blank" rel="noopener">2336. 无限集中的最小数字 - 力扣（LeetCode）</a></h4><p>现有一个包含所有正整数的集合 [1, 2, 3, 4, 5, …] 。</p><p>实现 SmallestInfiniteSet 类：</p><p>SmallestInfiniteSet() 初始化 SmallestInfiniteSet 对象以包含 所有 正整数。<br>int popSmallest() 移除 并返回该无限集中的最小整数。<br>void addBack(int num) 如果正整数 num 不 存在于无限集中，则将一个 num 添加 到该无限集中。</p><p><strong>示例：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[<span class="string">"SmallestInfiniteSet"</span>, <span class="string">"addBack"</span>, <span class="string">"popSmallest"</span>, <span class="string">"popSmallest"</span>, <span class="string">"popSmallest"</span>, <span class="string">"addBack"</span>, <span class="string">"popSmallest"</span>, <span class="string">"popSmallest"</span>, <span class="string">"popSmallest"</span>]</span><br><span class="line">[[], [<span class="number">2</span>], [], [], [], [<span class="number">1</span>], [], [], []]</span><br><span class="line">输出</span><br><span class="line">[null, null, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, null, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">解释</span><br><span class="line">SmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet();</span><br><span class="line">smallestInfiniteSet.addBack(<span class="number">2</span>);    <span class="comment">// 2 已经在集合中，所以不做任何变更。</span></span><br><span class="line">smallestInfiniteSet.popSmallest(); <span class="comment">// 返回 1 ，因为 1 是最小的整数，并将其从集合中移除。</span></span><br><span class="line">smallestInfiniteSet.popSmallest(); <span class="comment">// 返回 2 ，并将其从集合中移除。</span></span><br><span class="line">smallestInfiniteSet.popSmallest(); <span class="comment">// 返回 3 ，并将其从集合中移除。</span></span><br><span class="line">smallestInfiniteSet.addBack(<span class="number">1</span>);    <span class="comment">// 将 1 添加到该集合中。</span></span><br><span class="line">smallestInfiniteSet.popSmallest(); <span class="comment">// 返回 1 ，因为 1 在上一步中被添加到集合中，</span></span><br><span class="line">                                   <span class="comment">// 且 1 是最小的整数，并将其从集合中移除。</span></span><br><span class="line">smallestInfiniteSet.popSmallest(); <span class="comment">// 返回 4 ，并将其从集合中移除。</span></span><br><span class="line">smallestInfiniteSet.popSmallest(); <span class="comment">// 返回 5 ，并将其从集合中移除。</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= num &lt;= 1000</code></li><li>最多调用 <code>popSmallest</code> 和 <code>addBack</code> 方法 <strong>共计</strong> <code>1000</code> 次</li></ul><p><strong>代码</strong></p><p>用有序set保存前1000个数进行操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedSet <span class="keyword">as</span> SS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallestInfiniteSet</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.set = SS()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">1001</span>):</span><br><span class="line">            self.set.add(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">popSmallest</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.set.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBack</span><span class="params">(self, num: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.set.add(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your SmallestInfiniteSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = SmallestInfiniteSet()</span></span><br><span class="line"><span class="comment"># param_1 = obj.popSmallest()</span></span><br><span class="line"><span class="comment"># obj.addBack(num)</span></span><br></pre></td></tr></table></figure><h4 id="每日打卡-735-行星碰撞-力扣（LeetCode）"><a href="#每日打卡-735-行星碰撞-力扣（LeetCode）" class="headerlink" title="每日打卡. 735. 行星碰撞 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/asteroid-collision/" target="_blank" rel="noopener">每日打卡. 735. 行星碰撞 - 力扣（LeetCode）</a></h4><p>给定一个整数数组 asteroids，表示在同一行的行星。</p><p>对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。</p><p>找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：asteroids = [<span class="number">5</span>,<span class="number">10</span>,<span class="number">-5</span>]</span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">10</span>]</span><br><span class="line">解释：<span class="number">10</span> 和 <span class="number">-5</span> 碰撞后只剩下 <span class="number">10</span> 。 <span class="number">5</span> 和 <span class="number">10</span> 永远不会发生碰撞。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：asteroids = [<span class="number">8</span>,<span class="number">-8</span>]</span><br><span class="line">输出：[]</span><br><span class="line">解释：<span class="number">8</span> 和 <span class="number">-8</span> 碰撞后，两者都发生爆炸。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：asteroids = [<span class="number">10</span>,<span class="number">2</span>,<span class="number">-5</span>]</span><br><span class="line">输出：[<span class="number">10</span>]</span><br><span class="line">解释：<span class="number">2</span> 和 <span class="number">-5</span> 发生碰撞后剩下 <span class="number">-5</span> 。<span class="number">10</span> 和 <span class="number">-5</span> 发生碰撞后剩下 <span class="number">10</span> 。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>栈模拟。只有遇到向左移动并且左边的向右移动的时候才会出现碰撞。</p><p>遇到正数时，说明向右移动，直接入栈。</p><p>遇到负数时：</p><ol><li>若栈不为空，并且栈顶的元素为正数时，去掉栈顶的小于当前负数绝对值的所有正数。</li><li>如果去掉之后剩下的栈顶等于当前负数的绝对值，则说明大小是一样的，把栈顶去掉。</li><li>如果步骤1去掉之后栈为空或者栈顶为负数时，说明都是往左动的，此时把负数入栈，否则说明当前的栈顶为正数并且比当前负数的绝对值大。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">asteroidCollision</span><span class="params">(self, asteroids: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(asteroids)):</span><br><span class="line">            <span class="keyword">if</span> asteroids[i] &gt; <span class="number">0</span>:</span><br><span class="line">                res.append(asteroids[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> res <span class="keyword">and</span> res[<span class="number">-1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> res[<span class="number">-1</span>] &lt; abs(asteroids[i]):</span><br><span class="line">                    <span class="keyword">if</span> res[<span class="number">-1</span>] == abs(asteroids[i]):</span><br><span class="line">                        res.pop()</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        res.pop()</span><br><span class="line">                <span class="keyword">if</span> res <span class="keyword">and</span> res[<span class="number">-1</span>] == <span class="number">-1</span> * asteroids[i]:</span><br><span class="line">                    res.pop()</span><br><span class="line">                <span class="keyword">elif</span> <span class="keyword">not</span> res <span class="keyword">or</span> res[<span class="number">-1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                    res.append(asteroids[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="A-Pair-牛客挑战赛62-nowcoder-com"><a href="#A-Pair-牛客挑战赛62-nowcoder-com" class="headerlink" title="A-Pair_牛客挑战赛62 (nowcoder.com)"></a><a href="https://ac.nowcoder.com/acm/contest/11202/A" target="_blank" rel="noopener">A-Pair_牛客挑战赛62 (nowcoder.com)</a></h4><p>给定n个整数，第i个位$a_{i}$，请你统计有多少对无序对$(i , j)$，满足 $ i \ne j $ 且$ (a_{i}$ &amp; $a_{j})$ $ &gt; ( a_{i} \oplus  b_{i}) 。</p><p>其中&amp;代表二进制按位与，$ \oplus $代表二进制按位异或。</p><p>无序对的意思是(i, j) 和 (j, i) 被视为同一对。</p><p><em>输入描述：</em></p><blockquote><p>第一行输入正整数n，接下来一行n个整数表示$a_{i}$</p><p>$ 1 \leq n \leq 2 \times 10^{5}, 0 \leq a_{i} \leq 10^{9}$</p></blockquote><p><em>输出描述：</em></p><blockquote><p>一行一个数字表示答案。</p></blockquote><p><strong>示例1</strong></p><blockquote><p>8<br>12 7 11 6 5 0 2 8</p><p>输出：</p><p>6</p></blockquote><p><strong>示例2</strong></p><blockquote><p>6<br>3 7 2 6 1 1</p><p>输出：</p><p>3</p></blockquote><p><strong>思路</strong></p><p>两个数的按位与大于按位异或，我推出来的结论是：</p><p>0 是不与任何数满足这个条件的，然后，0~1里面的任意挑选两个数都是满足的，2~3里面任意挑选两个数都是满足的，4~7里面任意挑选两个数都是满足，8~15里面任意挑选两个数都是满足的，16~31里面任意挑选两个数都是满足的。</p><p>推出来这个规律之后就可以看出，我们只要统计每个的$2^{i} 到 2^{i + 1} - 1$里面数的有多少个，然后在这些数中随机选两个出来，因为是无序对，所以结果还要除2。假设某个区间里面的是n个 ，那么随机选两个数的总数就为n <em> (n-1)，除2之后就是n</em>(n-1) &gt;&gt; 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    n = int(input())</span><br><span class="line">    arr = list(map(int, input().split()))</span><br><span class="line">    flag = [<span class="number">0</span>] * (int(math.log2(<span class="number">10</span> ** <span class="number">9</span>)) + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="keyword">if</span> a:</span><br><span class="line">            flag[int(math.log2(a))] += <span class="number">1</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(flag)):</span><br><span class="line">        <span class="keyword">if</span> flag[i] &gt; <span class="number">1</span>:</span><br><span class="line">            res += (flag[i] * (flag[i] - <span class="number">1</span>)) &gt;&gt; <span class="number">1</span></span><br><span class="line">    print(res, end=<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="4498-指针-AcWing题库"><a href="#4498-指针-AcWing题库" class="headerlink" title="4498. 指针 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/4501/" target="_blank" rel="noopener">4498. 指针 - AcWing题库</a></h4><p> 给定一个全圆量角器。</p><p>初始时，请你对指针进行n次拨动操作，每次操作给定一个拨动角度$a_{i}$，由你将指针拨动$a_{i}$度，每次的拨动方向(顺时针或逆时针)由你自由决定。</p><p>请你判断，能否通过合理选择每次拨动的方向，使得指针最终仍然能指向刻度0。</p><p><em>输入格式</em></p><p>第一行包含整数n。</p><p>接下来n行，每行包含一个整数$a_{i}$，表示一次操作的拨动角度。</p><p><em>输出格式</em></p><p>如果可以做到指针最终仍然指向刻度0，则输出<code>YES</code>，否则输出<code>NO</code>。</p><p><em>数据范围</em></p><p>$ 1 \leq n \leq 15, 1 \leq a_{i} \leq 180$</p><p><strong>输入样例1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure><p><strong>输出样例1</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">YES</span></span><br></pre></td></tr></table></figure><p><strong>输入样例2</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>输出样例2</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NO</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>二维dp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    n = int(input())</span><br><span class="line">    dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">361</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        temp = int(input())</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            dp[i][temp] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">361</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[i - <span class="number">1</span>][j]:</span><br><span class="line">                    dp[i][(j + temp) % <span class="number">360</span>] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">if</span> j &gt;= temp:</span><br><span class="line">                        dp[i][j - temp] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][<span class="number">360</span> - abs(j - temp)] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dp[n - <span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">        print(<span class="string">"YES"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"NO"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="C-糖果分配-SZU-N303-B笔试训练赛2-nowcoder-com"><a href="#C-糖果分配-SZU-N303-B笔试训练赛2-nowcoder-com" class="headerlink" title="C-糖果分配_SZU-N303-B笔试训练赛2 (nowcoder.com)"></a><a href="https://ac.nowcoder.com/acm/contest/38536/C" target="_blank" rel="noopener">C-糖果分配_SZU-N303-B笔试训练赛2 (nowcoder.com)</a></h4><p>昌子哥特别喜欢吃糖果，每天他都要吃两颗糖且要是<strong>不同种类</strong>的糖果<strong>各一颗</strong>. </p><p>  现在他面前有三种糖果，分别为a,b,c个,他希望他能吃最多的天数，现在他问你寻求帮助。请你告诉他最多能吃多少天</p><p><strong>输入描述</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行为一个整数T(<span class="number">1</span>&lt;=T&lt;=<span class="number">100</span>)</span><br><span class="line">接下来T行，每行三个整数<span class="selector-tag">a</span>,<span class="selector-tag">b</span>,c分别代表三种糖果的个数.(<span class="number">0</span> &lt;= <span class="selector-tag">a</span>,<span class="selector-tag">b</span>,c &lt;= <span class="number">1</span>e9)</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于每组数据，请输出一个整数<span class="built_in">day</span>代表能吃的最多天数</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">输出：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">n = int(input())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">    arr = list(map(int, input().split()))</span><br><span class="line">    arr.sort()</span><br><span class="line">    <span class="keyword">if</span> arr[<span class="number">2</span>] &gt;= arr[<span class="number">1</span>] + arr[<span class="number">0</span>]: print(arr[<span class="number">1</span>] + arr[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(sum(arr) // <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="E-求逆序数-SZU-N303-B笔试训练赛2-nowcoder-com"><a href="#E-求逆序数-SZU-N303-B笔试训练赛2-nowcoder-com" class="headerlink" title="E-求逆序数_SZU-N303-B笔试训练赛2 (nowcoder.com)"></a><a href="https://ac.nowcoder.com/acm/contest/38536/E" target="_blank" rel="noopener">E-求逆序数_SZU-N303-B笔试训练赛2 (nowcoder.com)</a></h4><p>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。  </p><p>  比如一个元素个数为4的数列，其元素为2，4，3，1，则(2,1)，(4,3)，(4,1)，(3,1)是逆序，逆序数是4  </p><p>  现在求给定数列的逆序数</p><p><strong>输入描述</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行为<span class="built_in">N</span>，表示数列的元素个数(<span class="built_in">N</span>&lt;=<span class="number">2000</span>)</span><br><span class="line">第二行为<span class="built_in">N</span>个用空格隔开的整数,其值在<span class="built_in">int</span>范围内</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出占一行，为逆序数的个数</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line">输出：</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">margesort</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">    res = margesort(left, mid) + margesort(mid + <span class="number">1</span>, right)</span><br><span class="line">    </span><br><span class="line">    i, j = left, mid + <span class="number">1</span></span><br><span class="line">    temp[left:(right + <span class="number">1</span>)] = arr[left:(right + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(left, right + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i == mid + <span class="number">1</span>:</span><br><span class="line">            arr[k] = temp[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> j == right + <span class="number">1</span> <span class="keyword">or</span> temp[i] &lt;= temp[j]:</span><br><span class="line">            arr[k] = temp[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arr[k] = temp[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            res += mid - i + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">n = int(input())</span><br><span class="line">arr = list(map(int, input().split()))</span><br><span class="line">temp = [<span class="number">0</span>] * n</span><br><span class="line">print(margesort(<span class="number">0</span>, n - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h4 id="C-零钱问题-SZU-N303-B笔试训练赛3-nowcoder-com"><a href="#C-零钱问题-SZU-N303-B笔试训练赛3-nowcoder-com" class="headerlink" title="C-零钱问题_SZU-N303-B笔试训练赛3 (nowcoder.com)"></a><a href="https://ac.nowcoder.com/acm/contest/38538/C" target="_blank" rel="noopener">C-零钱问题_SZU-N303-B笔试训练赛3 (nowcoder.com)</a></h4><p>现有N元钱，兑换成小额的零钱，有多少种换法？币值包括1 2 5分，1 2 5角，1 2 5 10 20 50 100元。<br> (由于结果可能会很大，输出Mod 10^9 + 7的结果) </p><p><strong>输入描述</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行输入一个整数<span class="built_in">T</span>，代表有<span class="built_in">T</span>组数据</span><br><span class="line">接下来<span class="built_in">T</span>行，每行输入<span class="number">1</span>个数<span class="built_in">N</span>，<span class="built_in">N</span> = <span class="number">100</span>表示<span class="number">1</span>元钱。(<span class="number">1</span> &lt;= <span class="built_in">N</span> &lt;= <span class="number">100000</span>)</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出Mod <span class="number">10</span>^<span class="number">9</span> + <span class="number">7</span>的结果</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">输出：</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">res = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span> ,<span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">500</span>, <span class="number">1000</span>, <span class="number">2000</span>, <span class="number">5000</span>, <span class="number">10000</span>]</span><br><span class="line">dp = [<span class="number">0</span>] * <span class="number">100001</span></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">100001</span>):</span><br><span class="line">        dp[j] = (dp[j] + dp[j - i]) % mod</span><br><span class="line"></span><br><span class="line">n = int(input())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">    print(dp[int(input())])</span><br></pre></td></tr></table></figure><h4 id="D-多喝嘤料-SZU-N303-B笔试训练赛3-nowcoder-com"><a href="#D-多喝嘤料-SZU-N303-B笔试训练赛3-nowcoder-com" class="headerlink" title="D-多喝嘤料_SZU-N303-B笔试训练赛3 (nowcoder.com)"></a><a href="https://ac.nowcoder.com/acm/contest/38538/D" target="_blank" rel="noopener">D-多喝嘤料_SZU-N303-B笔试训练赛3 (nowcoder.com)</a></h4><p>  3个空瓶换一瓶。 </p><p>  4个瓶盖换一瓶。 </p><p>  问已购买n瓶嘤料的QAQ能喝到多少瓶嘤料？</p><p><strong>输入描述</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行一个正整数<span class="built_in">T</span>(<span class="number">0</span>&lt;<span class="built_in">T</span>&lt;=<span class="number">100</span>)</span><br><span class="line">随后<span class="built_in">T</span>行，每行一个整数<span class="built_in">n</span>(<span class="comment">0&lt;=n&lt;=1000000</span>)</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">T</span>行，每行一个整数表示结果。</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">22</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">t = int(input())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(t):</span><br><span class="line">    ans = int(input())</span><br><span class="line">    a = b = ans</span><br><span class="line">    <span class="keyword">while</span> a &gt;=<span class="number">3</span> <span class="keyword">or</span> b &gt;= <span class="number">4</span>:</span><br><span class="line">        t = a // <span class="number">3</span> + b // <span class="number">4</span></span><br><span class="line">        a = a % <span class="number">3</span> + t</span><br><span class="line">        b = b % <span class="number">4</span> + t</span><br><span class="line">        ans += t</span><br><span class="line">    print(ans)</span><br></pre></td></tr></table></figure><h4 id="E-迷雾森林-SZU-N303-B笔试训练赛3-nowcoder-com"><a href="#E-迷雾森林-SZU-N303-B笔试训练赛3-nowcoder-com" class="headerlink" title="E-迷雾森林_SZU-N303-B笔试训练赛3 (nowcoder.com)"></a><a href="https://ac.nowcoder.com/acm/contest/38538/E" target="_blank" rel="noopener">E-迷雾森林_SZU-N303-B笔试训练赛3 (nowcoder.com)</a></h4><p>赛时提示：保证出发点和终点都是空地 </p><p>  帕秋莉掌握了一种木属性魔法 </p><p>  这种魔法可以生成一片森林（类似于迷阵），但一次实验时，帕秋莉不小心将自己困入了森林 </p><p>  帕秋莉处于地图的左下角，出口在地图右上角，她只能够向上或者向右行走 </p><p>  现在给你森林的地图，保证可以到达出口，请问有多少种不同的方案 </p><p>  答案对2333取模</p><p><strong>输入描述</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一行两个整数m , <span class="built_in">n</span>表示森林是m行<span class="built_in">n</span>列</span><br><span class="line">接下来m行，每行<span class="built_in">n</span>个数，描述了地图</span><br><span class="line"><span class="number">0</span>  -  空地</span><br><span class="line"><span class="number">1</span>  -  树（无法通过）</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个整数表示答案</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">输出：</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">m, n = map(int, input().split(<span class="string">' '</span>))</span><br><span class="line">matrix = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">    matrix[i] = list(map(int, input().split()))</span><br><span class="line"></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">dp[m - <span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">mod = <span class="number">2333</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> (i == m - <span class="number">1</span> <span class="keyword">and</span> j == <span class="number">0</span>) <span class="keyword">or</span> matrix[i][j]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> i == m - <span class="number">1</span>:</span><br><span class="line">            dp[i][j] = dp[i][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">            dp[i][j] = dp[i + <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j] = dp[i + <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>] % mod</span><br><span class="line"><span class="comment"># print(dp)</span></span><br><span class="line">print(dp[<span class="number">0</span>][n - <span class="number">1</span>] % mod)</span><br></pre></td></tr></table></figure><h4 id="F-扫雷-SZU-N303-B笔试训练赛3-nowcoder-com"><a href="#F-扫雷-SZU-N303-B笔试训练赛3-nowcoder-com" class="headerlink" title="F-扫雷_SZU-N303-B笔试训练赛3 (nowcoder.com)"></a><a href="https://ac.nowcoder.com/acm/contest/38538/F" target="_blank" rel="noopener">F-扫雷_SZU-N303-B笔试训练赛3 (nowcoder.com)</a></h4><p>小sun上课的时候非常喜欢玩扫雷。他现小sun有一个初始的雷矩阵，他希望你帮他生成一个扫雷矩阵。 </p><p> 扫雷矩阵的每一行每一列都是一个数字，每个数字的含义是与当前位置相邻的8个方向中，有多少个雷（在下图中，雷用<code>*</code>表示）；如果当前位置就是雷的话，仍输出一个<code>*</code>。 </p><p><strong>输入描述</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行两个整数<span class="built_in">n</span>,m，代表矩阵有<span class="built_in">n</span>行m列</span><br><span class="line"></span><br><span class="line">接下来共<span class="built_in">n</span>行，每行m个字符</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出共<span class="built_in">n</span>行m列，为扫雷矩阵。</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line">....</span><br><span class="line">..**</span><br><span class="line">*.*.</span><br><span class="line">.*.*</span><br><span class="line">输出：</span><br><span class="line"><span class="number">0122</span></span><br><span class="line"><span class="number">13</span>**</span><br><span class="line">*<span class="number">4</span>*<span class="number">4</span></span><br><span class="line"><span class="number">2</span>*<span class="number">3</span>*</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line">....</span><br><span class="line">*..*</span><br><span class="line">.*.*</span><br><span class="line">输出：</span><br><span class="line"><span class="number">1111</span></span><br><span class="line">*<span class="number">23</span>*</span><br><span class="line"><span class="number">2</span>*<span class="number">3</span>*</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">m, n = map(int, input().split())</span><br><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(m):</span><br><span class="line">    a.append(list(input()))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">2</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        a.insert(<span class="number">0</span>, [<span class="number">0</span>] * (n + <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">if</span> i == m + <span class="number">1</span>:</span><br><span class="line">        a.append([<span class="number">0</span>] * (n + <span class="number">2</span>))</span><br><span class="line">    a[i].insert(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    a[i].append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">dir = [[<span class="number">-1</span>, <span class="number">-1</span>], [<span class="number">-1</span>, <span class="number">0</span>], [<span class="number">-1</span>, <span class="number">1</span>], [<span class="number">0</span>, - <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">-1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> a[i][j] == <span class="string">'*'</span>:</span><br><span class="line">            print(<span class="string">'*'</span>, end=<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> dir:</span><br><span class="line">                <span class="keyword">if</span> a[i + x][j + y] == <span class="string">'*'</span>:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            print(count, end=<span class="string">""</span>)</span><br><span class="line">    print(<span class="string">''</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;代码技巧知识点&quot;&gt;&lt;a href=&quot;#代码技巧知识点&quot; class=&quot;headerlink&quot; title=&quot;代码技巧知识点&quot;&gt;&lt;/a&gt;代码技巧知识点&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Python版(MOOC)笔记</title>
    <link href="http://yoursite.com/2022/07/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Python%E7%89%88-MOOC-%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/07/05/数据结构Python版-MOOC-笔记/</id>
    <published>2022-07-05T12:32:40.363Z</published>
    <updated>2022-07-05T12:34:01.446Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items == []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.items.append(item)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items[<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 括号匹配</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parChecker</span><span class="params">(parsy)</span>:</span></span><br><span class="line">    s = Stack()</span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; len(parsy) <span class="keyword">and</span> flag:</span><br><span class="line">        <span class="keyword">if</span> parsy[index] == <span class="string">')'</span>:</span><br><span class="line">            <span class="keyword">if</span> s.isEmpty():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s.push(parsy[index])</span><br><span class="line">        index = index + <span class="number">1</span></span><br><span class="line">    flag = <span class="literal">True</span> <span class="keyword">if</span> s.isEmpty() <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line">print(parChecker(<span class="string">"(((()))()()()))"</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">resverse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items[::<span class="number">-1</span>]</span><br><span class="line"><span class="comment"># 十进制转换为十六以下任意进制</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">baseConverter</span><span class="params">(decNumber, base)</span>:</span></span><br><span class="line">    </span><br><span class="line">    baseNum = <span class="string">"0123456789ABCDEF"</span></span><br><span class="line">    s = Stack()</span><br><span class="line">    <span class="keyword">while</span> decNumber:</span><br><span class="line">        s.push(int(baseNum[decNumber % base]))</span><br><span class="line">        decNumber = decNumber // base</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x+y, map(str, s.resverse()))</span><br><span class="line"></span><br><span class="line">print(baseConverter(<span class="number">25</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><h5 id="中缀表达式转换为后缀表达式"><a href="#中缀表达式转换为后缀表达式" class="headerlink" title="中缀表达式转换为后缀表达式"></a>中缀表达式转换为后缀表达式</h5><p><strong>思路：</strong></p><ul><li>遇到数据直接输出</li><li>遇到字符：<ul><li>若栈空，push入栈</li><li>若栈不空，当前字符优先级比栈顶的高则入栈，否则栈顶出栈，然后当前字符入栈（<strong>注意：一定要输出到当前比栈顶的优先级小</strong>）</li></ul></li><li>遇到”(“：入栈。</li><li>遇到”)”：栈顶出栈直到遇到”(“。</li><li>最后，把栈中的所有元素输出。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">infixToPostfix</span><span class="params">(infixexpr)</span>:</span></span><br><span class="line">    print(<span class="string">""</span>.join(infixexpr))</span><br><span class="line">    prec = &#123;<span class="string">"*"</span>: <span class="number">3</span>, <span class="string">"/"</span>: <span class="number">3</span>, <span class="string">"+"</span>: <span class="number">2</span>, <span class="string">"-"</span>: <span class="number">2</span>, <span class="string">"("</span>: <span class="number">1</span>, <span class="string">")"</span>: <span class="number">1</span>&#125;  <span class="comment"># 定义优先级</span></span><br><span class="line">    opStack = Stack()</span><br><span class="line">    postfix = []</span><br><span class="line">    tokenlist = [str(x) <span class="keyword">for</span> x <span class="keyword">in</span> infixexpr]</span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> tokenlist:</span><br><span class="line">        <span class="keyword">if</span> token <span class="keyword">in</span> <span class="string">"ABCDEF"</span> <span class="keyword">or</span> token <span class="keyword">in</span> <span class="string">"0123456789"</span>:</span><br><span class="line">            postfix.append(token)</span><br><span class="line">        <span class="keyword">elif</span> token == <span class="string">"("</span>:</span><br><span class="line">            opStack.push(token)</span><br><span class="line">        <span class="keyword">elif</span> token == <span class="string">")"</span>:</span><br><span class="line">            topToken = opStack.pop()</span><br><span class="line">            <span class="keyword">while</span> topToken != <span class="string">"("</span>:</span><br><span class="line">                postfix.append(topToken)</span><br><span class="line">                topToken = opStack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">not</span> opStack.isEmpty()) <span class="keyword">and</span> (prec[opStack.peek()] &gt;= prec[token]):</span><br><span class="line">                postfix.append(opStack.pop())</span><br><span class="line">            opStack.push(token)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> opStack.isEmpty():</span><br><span class="line">        postfix.append(opStack.pop())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join(postfix)</span><br></pre></td></tr></table></figure><h5 id="后缀表达式求值"><a href="#后缀表达式求值" class="headerlink" title="后缀表达式求值"></a>后缀表达式求值</h5><p><strong>思路</strong>：因为后缀表达式遍历先访问到的是操作数，后访问到的是操作符，所以要用一个栈先把操作数存下来，当访问到一个操作符之后从栈顶弹出两个操作数，计算然后再压入栈，最后栈中所剩下的一个数就为最后结果。</p><ul><li>遇到数字，入栈</li><li>遇到字符，取出栈顶两个数，注意第一个栈顶是后面的一个操作数，计算结果然后在入栈。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">infixToPostfix</span><span class="params">(infixexpr)</span>:</span></span><br><span class="line">    print(<span class="string">""</span>.join(infixexpr))</span><br><span class="line">    prec = &#123;<span class="string">"*"</span>: <span class="number">3</span>, <span class="string">"/"</span>: <span class="number">3</span>, <span class="string">"+"</span>: <span class="number">2</span>, <span class="string">"-"</span>: <span class="number">2</span>, <span class="string">"("</span>: <span class="number">1</span>, <span class="string">")"</span>: <span class="number">1</span>&#125;  <span class="comment"># 定义优先级</span></span><br><span class="line">    opStack = Stack()</span><br><span class="line">    postfix = []</span><br><span class="line">    tokenlist = [str(x) <span class="keyword">for</span> x <span class="keyword">in</span> infixexpr]</span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> tokenlist:</span><br><span class="line">        <span class="keyword">if</span> token <span class="keyword">in</span> <span class="string">"ABCDEF"</span> <span class="keyword">or</span> token <span class="keyword">in</span> <span class="string">"0123456789"</span>:</span><br><span class="line">            postfix.append(token)</span><br><span class="line">        <span class="keyword">elif</span> token == <span class="string">"("</span>:</span><br><span class="line">            opStack.push(token)</span><br><span class="line">        <span class="keyword">elif</span> token == <span class="string">")"</span>:</span><br><span class="line">            topToken = opStack.pop()</span><br><span class="line">            <span class="keyword">while</span> topToken != <span class="string">"("</span>:</span><br><span class="line">                postfix.append(topToken)</span><br><span class="line">                topToken = opStack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">not</span> opStack.isEmpty()) <span class="keyword">and</span> (prec[opStack.peek()] &gt;= prec[token]):</span><br><span class="line">                postfix.append(opStack.pop())</span><br><span class="line">            opStack.push(token)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> opStack.isEmpty():</span><br><span class="line">        postfix.append(opStack.pop())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join(postfix)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calPostfix</span><span class="params">(postfix)</span>:</span></span><br><span class="line">    ans = <span class="number">0.0</span></span><br><span class="line">    numStack = Stack()</span><br><span class="line">    postfix = [str(x) <span class="keyword">for</span> x <span class="keyword">in</span> postfix]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> postfix:</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> <span class="string">"*/+-"</span>:</span><br><span class="line">            a = numStack.pop()</span><br><span class="line">            b = numStack.pop()</span><br><span class="line">            <span class="keyword">if</span> x == <span class="string">"*"</span>:</span><br><span class="line">                ans = a * b + <span class="number">0.0</span></span><br><span class="line">            <span class="keyword">elif</span> x == <span class="string">"/"</span>:</span><br><span class="line">                ans = b / a + <span class="number">0.0</span></span><br><span class="line">            <span class="keyword">elif</span> x == <span class="string">"-"</span>:</span><br><span class="line">                ans = b - a + <span class="number">0.0</span></span><br><span class="line">            <span class="keyword">elif</span> x == <span class="string">"+"</span>:</span><br><span class="line">                ans = b + a + <span class="number">0.0</span></span><br><span class="line">            numStack.push(ans)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            numStack.push(int(x))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numStack.peek()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(calPostfix(infixToPostfix(<span class="string">"(3*6+2)/8"</span>)))</span><br></pre></td></tr></table></figure><h5 id="栈的所有课程代码"><a href="#栈的所有课程代码" class="headerlink" title="栈的所有课程代码"></a>栈的所有课程代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">resverse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 括号匹配</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parChecker</span><span class="params">(parsy)</span>:</span></span><br><span class="line">    s = Stack()</span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; len(parsy) <span class="keyword">and</span> flag:</span><br><span class="line">        <span class="keyword">if</span> parsy[index] == <span class="string">')'</span>:</span><br><span class="line">            <span class="keyword">if</span> s.isEmpty():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s.push(parsy[index])</span><br><span class="line">        index = index + <span class="number">1</span></span><br><span class="line">    flag = <span class="literal">True</span> <span class="keyword">if</span> s.isEmpty() <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 十进制转换为任意进制</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">baseConverter</span><span class="params">(decNumber, base)</span>:</span></span><br><span class="line">    baseNum = <span class="string">"0123456789ABCDEF"</span></span><br><span class="line">    s = Stack()</span><br><span class="line">    <span class="keyword">while</span> decNumber:</span><br><span class="line">        s.push(int(baseNum[decNumber % base]))</span><br><span class="line">        decNumber = decNumber // base</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x + y, map(str, s.resverse()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">infixToPostfix</span><span class="params">(infixexpr)</span>:</span></span><br><span class="line">    print(<span class="string">""</span>.join(infixexpr))</span><br><span class="line">    prec = &#123;<span class="string">"*"</span>: <span class="number">3</span>, <span class="string">"/"</span>: <span class="number">3</span>, <span class="string">"+"</span>: <span class="number">2</span>, <span class="string">"-"</span>: <span class="number">2</span>, <span class="string">"("</span>: <span class="number">1</span>, <span class="string">")"</span>: <span class="number">1</span>&#125;  <span class="comment"># 定义优先级</span></span><br><span class="line">    opStack = Stack()</span><br><span class="line">    postfix = []</span><br><span class="line">    infix = [str(x) <span class="keyword">for</span> x <span class="keyword">in</span> infixexpr]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> infix:</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> <span class="string">"0123456789"</span> <span class="keyword">or</span> x <span class="keyword">in</span> <span class="string">"ABCDEF"</span>:</span><br><span class="line">            postfix.append(x)</span><br><span class="line">        <span class="keyword">elif</span> x <span class="keyword">in</span> [<span class="string">"*"</span>, <span class="string">"/"</span>, <span class="string">"+"</span>, <span class="string">"-"</span>]:</span><br><span class="line">            <span class="keyword">if</span> opStack.isEmpty():</span><br><span class="line">                opStack.push(x)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">not</span> opStack.isEmpty()) <span class="keyword">and</span> (prec[opStack.peek()] &gt;= prec[x]):  <span class="comment"># &gt;=</span></span><br><span class="line">                    postfix.append(opStack.pop())</span><br><span class="line">                opStack.push(x)</span><br><span class="line">        <span class="keyword">elif</span> x <span class="keyword">in</span> [<span class="string">"("</span>, <span class="string">")"</span>]:</span><br><span class="line">            <span class="keyword">if</span> x == <span class="string">"("</span>:</span><br><span class="line">                opStack.push(x)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                op = opStack.pop()</span><br><span class="line">                <span class="keyword">while</span> op <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">"("</span>]:</span><br><span class="line">                    postfix.append(op)</span><br><span class="line">                    op = opStack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"error"</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> opStack.isEmpty():</span><br><span class="line">        postfix.append(opStack.pop())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join(postfix)</span><br><span class="line"></span><br><span class="line"><span class="comment"># def infixToPostfix(infixexpr):</span></span><br><span class="line"><span class="comment">#     print("".join(infixexpr))</span></span><br><span class="line"><span class="comment">#     prec = &#123;"*": 3, "/": 3, "+": 2, "-": 2, "(": 1, ")": 1&#125;  # 定义优先级</span></span><br><span class="line"><span class="comment">#     opStack = Stack()</span></span><br><span class="line"><span class="comment">#     postfix = []</span></span><br><span class="line"><span class="comment">#     tokenlist = [str(x) for x in infixexpr]</span></span><br><span class="line"><span class="comment">#     for token in tokenlist:</span></span><br><span class="line"><span class="comment">#         if token in "ABCDEF" or token in "0123456789":</span></span><br><span class="line"><span class="comment">#             postfix.append(token)</span></span><br><span class="line"><span class="comment">#         elif token == "(":</span></span><br><span class="line"><span class="comment">#             opStack.push(token)</span></span><br><span class="line"><span class="comment">#         elif token == ")":</span></span><br><span class="line"><span class="comment">#             topToken = opStack.pop()</span></span><br><span class="line"><span class="comment">#             while topToken != "(":</span></span><br><span class="line"><span class="comment">#                 postfix.append(topToken)</span></span><br><span class="line"><span class="comment">#                 topToken = opStack.pop()</span></span><br><span class="line"><span class="comment">#         else:</span></span><br><span class="line"><span class="comment">#             while (not opStack.isEmpty()) and (prec[opStack.peek()] &gt;= prec[token]):</span></span><br><span class="line"><span class="comment">#                 postfix.append(opStack.pop())</span></span><br><span class="line"><span class="comment">#             opStack.push(token)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     while not opStack.isEmpty():</span></span><br><span class="line"><span class="comment">#         postfix.append(opStack.pop())</span></span><br><span class="line"><span class="comment">#     return "".join(postfix)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calPostfix</span><span class="params">(postfix)</span>:</span></span><br><span class="line">    ans = <span class="number">0.0</span></span><br><span class="line">    numStack = Stack()</span><br><span class="line">    postfix = [str(x) <span class="keyword">for</span> x <span class="keyword">in</span> postfix]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> postfix:</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> <span class="string">"*/+-"</span>:</span><br><span class="line">            a = numStack.pop()</span><br><span class="line">            b = numStack.pop()</span><br><span class="line">            <span class="keyword">if</span> x == <span class="string">"*"</span>:</span><br><span class="line">                ans = a * b + <span class="number">0.0</span></span><br><span class="line">            <span class="keyword">elif</span> x == <span class="string">"/"</span>:</span><br><span class="line">                ans = b / a + <span class="number">0.0</span></span><br><span class="line">            <span class="keyword">elif</span> x == <span class="string">"-"</span>:</span><br><span class="line">                ans = b - a + <span class="number">0.0</span></span><br><span class="line">            <span class="keyword">elif</span> x == <span class="string">"+"</span>:</span><br><span class="line">                ans = b + a + <span class="number">0.0</span></span><br><span class="line">            numStack.push(ans)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            numStack.push(int(x))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numStack.peek()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(calPostfix(infixToPostfix(<span class="string">"(3*6+2)/8"</span>)))</span><br></pre></td></tr></table></figure><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, items=[])</span>:</span></span><br><span class="line">        self.items = items</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.items.insert(<span class="number">0</span>, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">len</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br></pre></td></tr></table></figure><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><h5 id="动态规划找零钱问题"><a href="#动态规划找零钱问题" class="headerlink" title="动态规划找零钱问题"></a>动态规划找零钱问题</h5><p><strong>思路</strong>：先初始化最开始的几种硬币的个数为1。递推公式：</p><p>minCoins[n] = min(minCoins[n-v1], minCoins[n-v2], minCoins[n-v3]) + 1。</p><p>其中v1，v2，v3分别为硬币的货币大小值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dpmakeChange</span><span class="params">(coinValueList, change)</span>:</span></span><br><span class="line">    minCoins = [<span class="number">0</span>] * <span class="number">64</span></span><br><span class="line">    <span class="keyword">for</span> cents <span class="keyword">in</span> range(<span class="number">1</span>, change + <span class="number">1</span>):</span><br><span class="line">        minCount = cents</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> coinValueList <span class="keyword">if</span> c &lt;= cents]:</span><br><span class="line">            minCount = minCoins[cents - j] + <span class="number">1</span> <span class="keyword">if</span> minCoins[cents - j] + <span class="number">1</span> &lt; minCount <span class="keyword">else</span> minCount</span><br><span class="line">        minCoins[cents] = minCount</span><br><span class="line">    <span class="keyword">return</span> minCoins[change]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(dpmakeChange([<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">25</span>], <span class="number">63</span>))</span><br></pre></td></tr></table></figure><h5 id="记录所选硬币的找零钱问题"><a href="#记录所选硬币的找零钱问题" class="headerlink" title="记录所选硬币的找零钱问题"></a>记录所选硬币的找零钱问题</h5><p>思路：在重新新建一个列表记录每次当前零钱所取的最后一个硬币，然后减去这个硬币数，一直向前遍历直到零钱为0时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dpmakeChange</span><span class="params">(coinValueList, change)</span>:</span></span><br><span class="line">    minCoins = [<span class="number">0</span>] * <span class="number">64</span></span><br><span class="line">    coinUsed = [<span class="number">0</span>] * <span class="number">64</span></span><br><span class="line">    <span class="keyword">for</span> cents <span class="keyword">in</span> range(<span class="number">1</span>, change + <span class="number">1</span>):</span><br><span class="line">        minCount = cents</span><br><span class="line">        newCoin = coinValueList[<span class="number">0</span>]  <span class="comment"># add</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> coinValueList <span class="keyword">if</span> c &lt;= cents]:</span><br><span class="line">            <span class="comment"># minCount = minCoins[cents - j] + 1 if minCoins[cents - j] + 1 &lt; minCount else minCount</span></span><br><span class="line">            <span class="keyword">if</span> minCoins[cents - j] + <span class="number">1</span> &lt; minCount:</span><br><span class="line">                minCount = minCoins[cents - j] + <span class="number">1</span></span><br><span class="line">                newCoin = j  <span class="comment"># 记录当前所选的硬币</span></span><br><span class="line">        coinUsed[cents] = newCoin  <span class="comment"># 存下当前要所选的最后一个硬币</span></span><br><span class="line">        minCoins[cents] = minCount</span><br><span class="line">    printCoin(coinUsed, change)</span><br><span class="line">    <span class="keyword">return</span> minCoins[change]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printCoin</span><span class="params">(usedCoins, change)</span>:</span></span><br><span class="line">    cents = change</span><br><span class="line">    <span class="keyword">while</span> cents &gt; <span class="number">0</span>:</span><br><span class="line">        print(usedCoins[cents])</span><br><span class="line">        cents = cents - usedCoins[cents]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(dpmakeChange([<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">25</span>], <span class="number">63</span>))</span><br></pre></td></tr></table></figure><h5 id="最大价值的背包问题"><a href="#最大价值的背包问题" class="headerlink" title="最大价值的背包问题"></a>最大价值的背包问题</h5><p>dp三个关键：</p><ul><li><p>状态矩阵的定义：把dp(i, w)表示为：前i个物品中，组合不超过w重量，得到的最大价值。</p></li><li><p>状态矩阵的初始化：</p></li><li><p>递推公式：<br>$$<br>dp(i, W)= \begin{cases}0 &amp; \text { if } i=0 \ 0 &amp; \text { if } W=0 \ dp(i-1, W) &amp; \text { if } w_{i}&gt;W \ \max \left{dp(i-1, W), v_{i}+dp\left(i-1, W-w_{i}\right)\right} &amp; \text { otherwise }\end{cases}<br>$$</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义二维空数组</span></span><br><span class="line"><span class="comment"># matrix = [[0 for i in range(3)] for i in range(3)]</span></span><br><span class="line"><span class="comment"># matrix = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxpackage</span><span class="params">(thing, wmax)</span>:</span></span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(wmax+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(thing))]  <span class="comment"># 初始化状态矩阵，dp[i][w]表示前i个物品最大w重时最大的价值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(thing)):  <span class="comment"># 遍历所有物品</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> range(<span class="number">1</span>, wmax+<span class="number">1</span>):  <span class="comment"># 遍历所有的重量，一直到最大的wmax重量</span></span><br><span class="line">            <span class="keyword">if</span> thing[i][<span class="string">'w'</span>] &gt; w:</span><br><span class="line">                dp[i][w] = dp[i<span class="number">-1</span>][w]  <span class="comment"># 表示当前的i的物品的重量大于所剩的重量，拿不下</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][w] = max(dp[i<span class="number">-1</span>][w], dp[i<span class="number">-1</span>][w-thing[i][<span class="string">'w'</span>]] + thing[i][<span class="string">'v'</span>])  <span class="comment"># 当能拿下时，两种情况，拿和不拿时的最大价值</span></span><br><span class="line">    <span class="keyword">return</span> dp[len(thing)<span class="number">-1</span>][wmax]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    things = [<span class="literal">None</span>, &#123;<span class="string">'v'</span>: <span class="number">3</span>, <span class="string">'w'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'v'</span>: <span class="number">4</span>, <span class="string">'w'</span>: <span class="number">3</span>&#125;,</span><br><span class="line">              &#123;<span class="string">'v'</span>: <span class="number">8</span>, <span class="string">'w'</span>: <span class="number">4</span>&#125;, &#123;<span class="string">'v'</span>: <span class="number">8</span>, <span class="string">'w'</span>: <span class="number">5</span>&#125;, &#123;<span class="string">'v'</span>: <span class="number">10</span>, <span class="string">'w'</span>: <span class="number">9</span>&#125;]  <span class="comment"># 定义物品重量</span></span><br><span class="line">    wmax = <span class="number">20</span>  <span class="comment"># 所能的最大承重</span></span><br><span class="line">    print(maxpackage(things, wmax))</span><br></pre></td></tr></table></figure><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""二分查找"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(arr, item)</span>:</span></span><br><span class="line">    pre, post = <span class="number">0</span>, len(arr) - <span class="number">1</span></span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> pre &lt;= post <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">        mid = (pre + post) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] == item:</span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> arr[mid] &gt; item:</span><br><span class="line">                post = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 递归写法</span></span><br><span class="line">    <span class="comment"># if len(arr) &lt;= 0:</span></span><br><span class="line">    <span class="comment">#     return False</span></span><br><span class="line">    <span class="comment"># else:</span></span><br><span class="line">    <span class="comment">#     mid = (0 + len(arr)-1) // 2</span></span><br><span class="line">    <span class="comment">#     if arr[mid] == item:</span></span><br><span class="line">    <span class="comment">#         return True</span></span><br><span class="line">    <span class="comment">#     else:</span></span><br><span class="line">    <span class="comment">#         if arr[mid] &gt; item:</span></span><br><span class="line">    <span class="comment">#             return binarySearch(arr[:mid], item)</span></span><br><span class="line">    <span class="comment">#         else:</span></span><br><span class="line">    <span class="comment">#             return binarySearch(arr[mid+1:], item)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = list(int(x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line">    print(binarySearch(arr, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>不稳定，因为中值的选取影响，如果选取的中值出现一边没有任何数据，那个时间复杂度就为n^2，由于递归关系可能更久，空间复杂度为1，不需要申请额外的空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(arr, first, last)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> first &gt; last:  <span class="comment"># 递归结束条件</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    flagnum = arr[first]  <span class="comment"># 选取基准值</span></span><br><span class="line"></span><br><span class="line">    left = first+<span class="number">1</span>  <span class="comment"># 左右标初始化</span></span><br><span class="line">    right = last</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> arr[left] &lt;= flagnum:  <span class="comment"># 左标向右移动，直到找到比基准值大的数</span></span><br><span class="line">            left = left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> arr[right] &gt;= flagnum:  <span class="comment"># 右标向左移动，直到找到比基准值小的数</span></span><br><span class="line">            right = right<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:  <span class="comment"># 如果没有找到就退出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arr[left], arr[right] = arr[right], arr[left]  <span class="comment"># 将两个数交换然后左右标继续移动</span></span><br><span class="line">    arr[right], arr[first] = flagnum, arr[right]  <span class="comment"># 全部移动完成之后表示左标左边都比基准数小，右标右边都比基准数大，此时把中值就位</span></span><br><span class="line">    quickSort(arr, first, right<span class="number">-1</span>)  <span class="comment"># 对左右边的数列继续快排</span></span><br><span class="line">    quickSort(arr, right+<span class="number">1</span>, last)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort2</span><span class="params">(arr)</span>:</span>  <span class="comment"># 申请了额外的空间，但是看起来更简洁</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    left = []</span><br><span class="line">    right = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> arr[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">if</span> n &lt;= arr[<span class="number">0</span>]:</span><br><span class="line">            left.append(n)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right.append(n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quickSort2(left) + [arr[<span class="number">0</span>]] + quickSort2(right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(quickSort2([<span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure><h4 id="其他排序方法"><a href="#其他排序方法" class="headerlink" title="其他排序方法"></a>其他排序方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randomList</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        arr = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            arr.append(random.randrange(<span class="number">100</span>))</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        冒泡排序：</span></span><br><span class="line"><span class="string">        时间复杂度：n^2</span></span><br><span class="line"><span class="string">        最差时间：n^2</span></span><br><span class="line"><span class="string">        空间复杂度：1</span></span><br><span class="line"><span class="string">        稳定</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        arr_len = len(arr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, arr_len):  <span class="comment"># important part</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, arr_len - i):  <span class="comment"># important part</span></span><br><span class="line">                <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                    arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        选择排序：</span></span><br><span class="line"><span class="string">        时间复杂度：n^2</span></span><br><span class="line"><span class="string">        最差时间：n^2</span></span><br><span class="line"><span class="string">        空间复杂度：1</span></span><br><span class="line"><span class="string">        不稳定</span></span><br><span class="line"><span class="string">        原理：先找到起始数组中最小的元素，将它交换到i=0；然后寻找剩下元素中最小的元素，</span></span><br><span class="line"><span class="string">        将它交换到i=1的位置……直到找到第二小的元素，将它交换到n-2的位置。这时，整个数组排序完成。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">selectSort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        arr_len = len(arr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(arr_len):</span><br><span class="line">            min_index = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, arr_len):</span><br><span class="line">                min_index = j <span class="keyword">if</span> arr[j] &lt; arr[min_index] <span class="keyword">else</span> min_index</span><br><span class="line">            arr[min_index], arr[i] = arr[i], arr[min_index]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        插入排序：</span></span><br><span class="line"><span class="string">        时间复杂度：n^2</span></span><br><span class="line"><span class="string">        最差时间：n^2</span></span><br><span class="line"><span class="string">        空间复杂度：1</span></span><br><span class="line"><span class="string">        稳定</span></span><br><span class="line"><span class="string">        原理：把左边第一个元素当成是已经排好序的序列，每次从后面的序列中选出一个数然后插入到左边已经排好序的序列中。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertSort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        arr_len = len(arr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, arr_len):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> arr[i] &lt; arr[j]:</span><br><span class="line">                    arr[j+<span class="number">1</span>:i+<span class="number">1</span>] = arr[j:i]</span><br><span class="line">                    arr[j] = arr[i]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        归并排序：</span></span><br><span class="line"><span class="string">        时间复杂度：nlog2(n)</span></span><br><span class="line"><span class="string">        最差时间：nlog2(n)</span></span><br><span class="line"><span class="string">        空间复杂度：额外的一半需要用来做归并，N</span></span><br><span class="line"><span class="string">        稳定</span></span><br><span class="line"><span class="string">        原理：对数组进行拆分再拆分，直到都只剩一个元素不能拆分为止，然后分别对拆分之后的左右序列进行合并，</span></span><br><span class="line"><span class="string">        然后再合并大一点的数组（合并之后的），直到最终合成一个最大的数组。分两个函数完成，一个负责拆分，一个排序合并。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(arr) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        mid = len(arr) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># left, right = arr[0:mid], arr[mid:]</span></span><br><span class="line">        left, right = self.merge_sort(arr[<span class="number">0</span>:mid]), self.merge_sort(arr[mid:])</span><br><span class="line"></span><br><span class="line">        ilist = []</span><br><span class="line">        <span class="keyword">while</span> right <span class="keyword">and</span> left:</span><br><span class="line">            <span class="keyword">if</span> left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]:</span><br><span class="line">                ilist.append(left.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ilist.append(right.pop(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">        ilist.extend(right <span class="keyword">if</span> right <span class="keyword">else</span> left)</span><br><span class="line">        <span class="keyword">return</span> ilist</span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        快速排序：</span></span><br><span class="line"><span class="string">        时间复杂度：nlog2(n)</span></span><br><span class="line"><span class="string">        最差时间：n^2</span></span><br><span class="line"><span class="string">        空间复杂度：nlog2(n)</span></span><br><span class="line"><span class="string">        不稳定 ，因为中值的选取如果导致一边始终没有数据的话，时间复杂度加上递归可能会比n^2还要差</span></span><br><span class="line"><span class="string">        原理：任意找一个数为基准数，一般是数列的第一个数，将序列以该基准元素为基准，分割成比它小的左边和比它大的右边，此时，该基准元素所在的位置就是</span></span><br><span class="line"><span class="string">        排序终了之后的准确位置，在对左右两边的序列继续执行同样的操作，直到整个序列有序。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        left = []</span><br><span class="line">        right = []</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> arr[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> n &lt;= arr[<span class="number">0</span>]:</span><br><span class="line">                left.append(n)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right.append(n)</span><br><span class="line">        <span class="keyword">return</span> self.quick_sort(left) + [arr[<span class="number">0</span>]] + self.quick_sort(right)</span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     first = arr[0]</span></span><br><span class="line">        <span class="comment">#     left = self.quick_sort([l for l in arr[1:] if l &lt; first])</span></span><br><span class="line">        <span class="comment">#     right = self.quick_sort([r for r in arr[1:] if r &gt; first])</span></span><br><span class="line">        <span class="comment">#     return left + [first] + right</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        希尔排序：</span></span><br><span class="line"><span class="string">        时间复杂度：nlog2(n)</span></span><br><span class="line"><span class="string">        最差时间：n^s   1&lt;s&lt;2 s是所选分组</span></span><br><span class="line"><span class="string">        空间复杂度：1</span></span><br><span class="line"><span class="string">        不稳定</span></span><br><span class="line"><span class="string">        原理：把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，</span></span><br><span class="line"><span class="string">        每组包含的关键词越来越多，当增量减少至1时，整个文件恰好被分成一组，算法终止。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        gap = len(arr)</span><br><span class="line">        <span class="keyword">while</span> gap &gt; <span class="number">1</span>:</span><br><span class="line">            gap = gap // <span class="number">2</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, len(arr)):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(i % gap, i, gap):</span><br><span class="line">                    <span class="keyword">if</span> arr[i] &lt; arr[j]:</span><br><span class="line">                        arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        堆排序：</span></span><br><span class="line"><span class="string">        时间复杂度：</span></span><br><span class="line"><span class="string">        最差时间：</span></span><br><span class="line"><span class="string">        空间复杂度：</span></span><br><span class="line"><span class="string">        不稳定</span></span><br><span class="line"><span class="string">        原理：</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        基数排序：</span></span><br><span class="line"><span class="string">        时间复杂度：</span></span><br><span class="line"><span class="string">        最差时间：</span></span><br><span class="line"><span class="string">        空间复杂度：</span></span><br><span class="line"><span class="string">        不稳定</span></span><br><span class="line"><span class="string">        原理：</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># write code here</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># num = list(map(lambda x: int(x), input().split(' ')))</span></span><br><span class="line">    arr_len = int(input())</span><br><span class="line">    num = Solution().randomList(arr_len)</span><br><span class="line">    print(str(num).replace(<span class="string">', '</span>, <span class="string">' '</span>).replace(<span class="string">'\''</span>, <span class="string">''</span>)[<span class="number">1</span>:<span class="number">-1</span>] + <span class="string">' '</span>)</span><br><span class="line">    bubble_num = Solution().bubble_sort(num)</span><br><span class="line">    print(<span class="string">"bubble: "</span> + str(bubble_num).replace(<span class="string">', '</span>, <span class="string">' '</span>).replace(<span class="string">'\''</span>, <span class="string">''</span>)[<span class="number">1</span>:<span class="number">-1</span>] + <span class="string">' '</span>)</span><br><span class="line">    select_num = Solution().selectSort(num)</span><br><span class="line">    print(<span class="string">"select: "</span> + str(select_num).replace(<span class="string">', '</span>, <span class="string">' '</span>).replace(<span class="string">'\''</span>, <span class="string">''</span>)[<span class="number">1</span>:<span class="number">-1</span>] + <span class="string">' '</span>)</span><br><span class="line">    insert_num = Solution().insertSort(num)</span><br><span class="line">    print(<span class="string">"insert: "</span> + str(insert_num).replace(<span class="string">', '</span>, <span class="string">' '</span>).replace(<span class="string">'\''</span>, <span class="string">''</span>)[<span class="number">1</span>:<span class="number">-1</span>] + <span class="string">' '</span>)</span><br><span class="line">    merge_num = Solution().merge_sort(num)</span><br><span class="line">    print(<span class="string">"merge: "</span> + str(merge_num).replace(<span class="string">', '</span>, <span class="string">' '</span>).replace(<span class="string">'\''</span>, <span class="string">''</span>)[<span class="number">1</span>:<span class="number">-1</span>] + <span class="string">' '</span>)</span><br><span class="line">    quick_num = Solution().quick_sort(num)</span><br><span class="line">    print(<span class="string">"quick: "</span> + str(quick_num).replace(<span class="string">', '</span>, <span class="string">' '</span>).replace(<span class="string">'\''</span>, <span class="string">''</span>)[<span class="number">1</span>:<span class="number">-1</span>] + <span class="string">' '</span>)</span><br><span class="line">    shell_num = Solution().shell_sort(num)</span><br><span class="line">    print(<span class="string">"shell: "</span> + str(shell_num).replace(<span class="string">', '</span>, <span class="string">' '</span>).replace(<span class="string">'\''</span>, <span class="string">''</span>)[<span class="number">1</span>:<span class="number">-1</span>] + <span class="string">' '</span>)</span><br></pre></td></tr></table></figure><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><h5 id="数的列表的实现方式"><a href="#数的列表的实现方式" class="headerlink" title="数的列表的实现方式"></a>数的列表的实现方式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""二叉树的列表实现"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BinaryTree</span><span class="params">(r)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [r, [], []]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertLeft</span><span class="params">(root, newBranch)</span>:</span></span><br><span class="line">    t = root.pop(<span class="number">1</span>)  <span class="comment"># 先把左节点取出来</span></span><br><span class="line">    <span class="comment"># if len(t) &gt; 1:  # 左节点不会控</span></span><br><span class="line">    <span class="comment">#     root.insert(1, [newBranch, t, []])  # 在1处insert的，所以不影响右节点</span></span><br><span class="line">    <span class="comment"># else:</span></span><br><span class="line">    <span class="comment">#     root.insert(1, [newBranch, [], []])</span></span><br><span class="line">    root.insert(<span class="number">1</span>, [newBranch, t <span class="keyword">if</span> len(t) &gt; <span class="number">1</span> <span class="keyword">else</span> [], []])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertRight</span><span class="params">(root, newBranch)</span>:</span></span><br><span class="line">    t = root.pop(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> root.insert(<span class="number">2</span>, [newBranch, [], t <span class="keyword">if</span> len(t) &gt; <span class="number">1</span> <span class="keyword">else</span> []])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getRootVal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> root[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setRootVal</span><span class="params">(root, newVal)</span>:</span></span><br><span class="line">    root[<span class="number">0</span>] = newVal</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLeftVal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> root[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getRightVal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> root[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h5 id="树的链表的实现方式"><a href="#树的链表的实现方式" class="headerlink" title="树的链表的实现方式"></a>树的链表的实现方式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""二叉树的链表实现"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree_Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, rootObj)</span>:</span></span><br><span class="line">        self.key = rootObj</span><br><span class="line">        self.leftChild = <span class="literal">None</span></span><br><span class="line">        self.rightChild = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertLeftChild</span><span class="params">(self, newNode)</span>:</span></span><br><span class="line">        leftChild = self.leftChild</span><br><span class="line">        <span class="keyword">if</span> leftChild <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.leftChild = BinaryTree_Node(newNode)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.leftChild = BinaryTree_Node(newNode).leftChild = leftChild</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertRight</span><span class="params">(self, newNode)</span>:</span></span><br><span class="line">        rightChild = self.rightChild</span><br><span class="line">        <span class="keyword">if</span> rightChild <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.rightChild = BinaryTree_Node(newNode)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.rightChild = BinaryTree_Node(newNode).rightChild = rightChild</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRightChild</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.rightChild</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeftChild</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.leftChild</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRootVal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.key</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setRootVal</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.key = data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self)</span>:</span>  <span class="comment"># 前序遍历</span></span><br><span class="line">        print(self.key)</span><br><span class="line">        <span class="keyword">if</span> self.leftChild:</span><br><span class="line">            self.leftChild.preorder()</span><br><span class="line">        <span class="keyword">if</span> self.rightChild:</span><br><span class="line">            self.rightChild.preorder()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(self)</span>:</span>  <span class="comment"># 后序遍历</span></span><br><span class="line">        <span class="keyword">if</span> self.leftChild:</span><br><span class="line">            self.leftChild.preorder()</span><br><span class="line">        <span class="keyword">if</span> self.rightChild:</span><br><span class="line">            self.rightChild.preorder()</span><br><span class="line">        print(self.key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self)</span>:</span>  <span class="comment"># 中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> self.leftChild:</span><br><span class="line">            self.leftChild.preorder()</span><br><span class="line">        print(self.key)</span><br><span class="line">        <span class="keyword">if</span> self.rightChild:</span><br><span class="line">            self.rightChild.preorder()</span><br></pre></td></tr></table></figure><h5 id="树的遍历函数体的实现"><a href="#树的遍历函数体的实现" class="headerlink" title="树的遍历函数体的实现"></a>树的遍历函数体的实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(tree: BinaryTree_Node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> tree:</span><br><span class="line">        print(tree.getRootVal())</span><br><span class="line">        preorder(tree.getLeftChild())</span><br><span class="line">        preorder(tree.getRightChild())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(tree: BinaryTree_Node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> tree:</span><br><span class="line">        postorder(tree.getLeftChild())</span><br><span class="line">        postorder(tree.getRightChild())</span><br><span class="line">        print(tree.getRootVal())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(tree: BinaryTree_Node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> tree:</span><br><span class="line">        inorder(tree.getLeftChild())</span><br><span class="line">        print(tree.getRootVal())</span><br><span class="line">        inorder(tree.getRightChild())</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本结构&quot;&gt;&lt;a href=&quot;#基本结构&quot; class=&quot;headerlink&quot; title=&quot;基本结构&quot;&gt;&lt;/a&gt;基本结构&lt;/h3&gt;&lt;h4 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h4&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>python学习笔记</title>
    <link href="http://yoursite.com/2022/07/05/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/07/05/python学习笔记/</id>
    <published>2022-07-05T12:25:55.031Z</published>
    <updated>2022-07-05T12:33:43.168Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h3><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><h5 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h5><p>整数、浮点数、</p><p>字符串：用单引号<code>&#39;abc&#39;</code>和双引号<code>&quot;abc&quot;</code>括起来的任意文本，用<code>r&#39;abc&#39;</code>表示<code>&#39;&#39;</code>中的字符默认不转义。</p><p>布尔值：<code>True</code>和<code>False</code>，可以参与<code>and</code>、<code>or</code>和<code>not</code>运算。</p><p>空值：<code>None</code></p><a id="more"></a><p>变量：可以是任意数据类型，这种变量本身类型不固定的语言称为动态语言，静态语言在定义变量是必须指定变量类型，如java</p><p>常量：通常用全部大写的变量名表示常量，但不是一定的，只是习惯，不会保证不被改变。</p><blockquote><p><code>/</code>除法返回浮点数。<code>//</code>称为地板除，返回整数，只取结果的整数部分，<code>%</code>表示取余。整数的运算结果一直是整数。</p></blockquote><h5 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h5><p>ASCII编码是一个字节，而Unicode编码通常是两个字节。为了节省空间，就把Unicode编码转化为“可变长编码”的<code>UTF-8</code>编码。UTF-8编码会把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母为1个字节，汉字通常为3个字节，</p><p>计算机系统编码方式：在计算机内存中，同一使用Unicode编码，需要保存到硬盘和需要传输的时候，就会转换成UTF-8编码。浏览网页的时候，服务器会把动态生成的Unicode内容转换成UTF-8再传输到浏览器。</p><p>字符串：<code>ord()</code>返回字符的整数，<code>chr()</code>转换为对应的字符。</p><blockquote><p>在python3中是以Unicode编码的，一个字符对应多个字节，如果要在网络传输，或者保存到内存，需要转为UTF-8编码，把<code>str</code>变为以字节为单位的<code>bytes</code>，<code>x = b&#39;abc&#39;</code>。反过来，从网络和磁盘读到的字节流<code>bytes</code>变为<code>str</code>，就需要用到<code>decode()</code>。</p></blockquote><p>通常保存源代码的时候会指定保存为UTF-8编码，在代码前面会加上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure><p>格式化输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Hi, %s, you have $%d.'</span> % (<span class="string">'Michael'</span>, <span class="number">1000000</span>)</span><br></pre></td></tr></table></figure><p>前面用占位符，后面对应替换内容，<code>%d</code>-整数，<code>%f</code>-浮点数，<code>%s</code>-字符串，<code>%x</code>-十六进制整数。</p><h5 id="list和tuple"><a href="#list和tuple" class="headerlink" title="list和tuple"></a>list和tuple</h5><p>list：列表，是一种有序的集合，可以随时添加和删除元素，列表中元素可以是不同的数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>] <span class="comment"># 定义list</span></span><br><span class="line">len(arr)</span><br><span class="line">arr[<span class="number">-1</span>]  <span class="comment"># 返回最后一个元素</span></span><br><span class="line">arr.append()  <span class="comment"># 添加元素</span></span><br><span class="line">arr.insert(<span class="number">1</span>, <span class="string">'1'</span>) <span class="comment"># 在索引为1处加入元素</span></span><br><span class="line">arr.pop()  <span class="comment"># 删除末尾的元素，并返回。</span></span><br></pre></td></tr></table></figure><p>tuple：元组，也是一种有序列表，一旦被初始化就不能修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple = (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>)  <span class="comment"># 定义tuple</span></span><br></pre></td></tr></table></figure><blockquote><p>! tuple 中只有一个元素的时候，需要加一个逗号消除歧义，<code>tuple = (1, )</code>。</p></blockquote><h5 id="dict和set"><a href="#dict和set" class="headerlink" title="dict和set"></a>dict和set</h5><p>dict：字典，也称为map，只用键-值(key-value)来存储，具有极快的查找速度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'key1'</span>: value1, <span class="string">'key2'</span>: value2, <span class="string">'key3'</span>: value3&#125;  <span class="comment"># 定义dict</span></span><br><span class="line">d[<span class="string">'key1'</span>]  <span class="comment"># dict的检索</span></span><br><span class="line">d.get(<span class="string">'key4'</span>, <span class="number">-1</span>)  <span class="comment"># 如果key不存在，可以返回None，或者指定的value</span></span><br></pre></td></tr></table></figure><blockquote><p>dict的key必须是不可变对象。list是可变的，不可作为key</p></blockquote><p>set：也是一组key的集合，但不存储value，set可以看成数学意义上的无序和无重复元素的集合，并且可以做交集、并集等操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># set的定义</span></span><br><span class="line">s.add(<span class="number">4</span>)  <span class="comment"># 添加元素到set中，自动过滤重复元素</span></span><br><span class="line">s.remove(<span class="number">4</span>)  <span class="comment"># 删除元素</span></span><br><span class="line">s1 &amp; s2  <span class="comment"># 交集</span></span><br><span class="line">s1 | s2  <span class="comment"># 并集</span></span><br></pre></td></tr></table></figure><h5 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h5><p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。</p><p>默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！</p><p>要注意定义可变参数和关键字参数的语法：</p><p><code>*args</code>是可变参数，args接收的是一个tuple；</p><p><code>**kw</code>是关键字参数，kw接收的是一个dict。</p><p>以及调用函数时如何传入可变参数和关键字参数的语法：</p><p>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；</p><blockquote><p><code>func(*args)</code>其中<code>*args</code>表示把<code>args</code>这个list中的所有元素作为可变参数传进去。</p></blockquote><p>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})</code>。</p><p>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。</p><p>命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。</p><p>定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符<code>*</code>，否则定义的将是位置参数。</p><h4 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h4><h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><p>list 和 tuple 都支持切片操作，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">L[<span class="number">0</span>:<span class="number">3</span>]  <span class="comment"># 从索引0开始直到索引3为止但不包括索引3。</span></span><br><span class="line">L[:<span class="number">3</span>]  <span class="comment"># 从索引0开始时0可以省略</span></span><br><span class="line">L[<span class="number">-2</span>:]  <span class="comment"># 倒数的两个元素</span></span><br><span class="line">L[<span class="number">-2</span>:<span class="number">-1</span>]  <span class="comment"># 倒数的第二个元素</span></span><br><span class="line">L[:<span class="number">10</span>:<span class="number">2</span>]  <span class="comment"># 从索引0到索引10每隔2个取一个。</span></span><br></pre></td></tr></table></figure><blockquote><p>字符串也是一种list，每个元素就是一个字符，所以字符串也可以切片操作且结果仍是字符串。</p></blockquote><h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><p>给定一个<code>list</code>或<code>tuple</code>，可以通过<code>for</code>来循环遍历整个<code>list</code>或<code>tuple</code>，这种遍历成为迭代(Iteration)。</p><blockquote><p><code>for</code>默认迭代是key，如果要迭代value用<code>for value in d.values()</code>，如果要同时迭代key和value，可以用<code>for k, v in d.items()</code>。</p></blockquote><p><code>enumerate</code>函数可以把一个<code>list</code>变成索引-元素对。<code>for i, value in enumerate([&#39;a&#39;, &#39;b&#39;, &#39;v&#39;])</code></p><h5 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h5><p>可以用来创建list的生成式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[x * x <span class="keyword">for</span> x <span class="keyword">in</span> rang(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>] <span class="comment"># 1到10偶数的平方</span></span><br><span class="line">[x + y <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'abc'</span> <span class="keyword">for</span> y <span class="keyword">in</span> <span class="string">'xyz'</span>] <span class="comment"># 全排列</span></span><br><span class="line">[x + <span class="string">'='</span> + v <span class="keyword">for</span> x, v <span class="keyword">in</span> d.items()]</span><br></pre></td></tr></table></figure><p>在一个列表生成式中，<code>for</code>后面的<code>if</code>不能带<code>else</code>，<code>for</code>前面的<code>if</code>必须带<code>else</code>。因为<code>for</code>前面的<code>if...else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code>。</p><blockquote><p>用<code>isinstance(x, str)</code>可以判断数据类型，<code>x</code>为待判断的变量，<code>str</code>为是否为这个数据类型。</p></blockquote><h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5><p>生成器就是一种一遍循环一遍计算的机制，这样就不必创建一个完整的List，节省内存空间，List可以直接访问任意元素，但是生成器就得遍历才能得到下一个返回值。一般采用<code>for</code>循环来迭代遍历，因为生成器也是可迭代对象。</p><ul><li>创建生成器一个最简单的方式就是将列表生成器的<code>[]</code>改成<code>()</code>。</li><li>另一种方法就是，在一个函数中，一个变量有<code>yield</code>关键字，则就是generator函数，</li></ul><p>generator函数和普通函数执行流程不一样，普通函数是顺序执行。generator函数在每次调用<code>next()</code>时候执行，遇到<code>yield</code>时返回，再次执行时从上次返回的<code>yield</code>语句继续执行。</p><blockquote><p>调用genetator函数会创建一个generator对象，多吃调用generator函数会创建多个相互独立的generator。</p></blockquote><p>调用生成器函数的正确写法是先创建一个generator对象，然后不断对这个对象调用<code>next()</code>。因为如果直接对生成器函数执行<code>next()</code>函数则会每次创建一个独立的generator。</p><blockquote><p>区分普通函数和generator函数的区别在于普通函数直接返回结果，遇到return和程序结束时函数结束，generator函数实际返回一个generator对象，遇到<code>yield</code>关键字时结束。</p></blockquote><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p>可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>。</p><p>一类是集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等。</p><p>一类是<code>generator</code>，包括生成器和带<code>yield</code>的generator function。</p><blockquote><p>使用<code>isinstance()</code>判断一个对象是否为<code>Iterable</code>对象。<code>isinstance(num, Iterable)</code></p></blockquote><p>生成器不但可以作用于<code>for</code>循环，还可以被<code>next()</code>函数不断调用并返回下一个值。</p><p>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>。</p><p>生成器都是<code>Iterator</code>对象，但是<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。</p><blockquote><p>把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数。<code>isinstance(iter(&#39;abs&#39;), Iterator)</code>。</p></blockquote><p><code>Iterator</code>可以表示一个无限大的数据流，可以不用提前知道序列的长度，只能通过不断的<code>next()</code>函数来计算下一个数据，所以<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时才会计算。</p><p>只要能作用于<code>for</code>循环的对象都是<code>Iterable</code>类型。</p><p>只要能作用于<code>next()</code>函数的对象都是<code>Iterator</code>类型，他们表示一个惰性计算的序列。</p><h4 id="函数式变成"><a href="#函数式变成" class="headerlink" title="函数式变成"></a>函数式变成</h4><h5 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h5><p>变量可以指向一个函数。</p><p>一个函数传入到另外一个函数作为参数，这种函数称为高阶函数。</p><h5 id="map-reduce-函数"><a href="#map-reduce-函数" class="headerlink" title="map()/reduce()函数"></a>map()/reduce()函数</h5><p><code>map()</code>传入的第一个参数为<code>f</code>，即函数本身，另一个参数为<code>Iterable</code>，将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回，因为<code>Iterator</code>是惰性序列，所以用<code>list</code>把整个序列都计算出来并返回一个list。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(map(str, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]))</span><br></pre></td></tr></table></figure><p><code>reduce()</code>把一个函数作用在一个序列<code>[x1, x2, x3, ....]</code>，这个函数必须接收两个参数，<code>reduce()</code>把结果继续和序列的下一个元素做累积计算，其效果就是<code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code>。</p><p>将字符串数字转换为数字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num = reduce(<span class="keyword">lambda</span>: x, y: x*<span class="number">10</span>+y, map(int, s))</span><br></pre></td></tr></table></figure><h5 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h5><p><code>filter()</code>函数用于过滤序列，和<code>map()</code>相同的是都是接收一个函数和一个序列。和<code>map()</code>不同的是<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>和<code>False</code>来决定保留还是丢弃该元素。</p><blockquote><p>所以，<code>filer()</code>中的函数的返回值需要为bool值。</p></blockquote><p>注意：<code>filer()</code>函数返回的是一个<code>Iterator</code>，是一个惰性序列，所以要强迫<code>filter()</code>完成计算结果，需要用<code>list()</code>函数来获得所有结果并返回list。</p><h5 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h5><p>Python内置的<code>sorted()</code>函数可以实现对List排序，并且可以接收一个<code>key</code>函数来实现自定义排序。<code>key</code>指定的函数将作用于List的每一个元素上，并根据key函数返回的结果进行排序。第三个参数<code>reverse=True</code>表示方向排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>], key=str.lower reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h5 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h5><p>函数可以作为返回值，当函数1返回函数2时，相关的参数和变量都保存在返回的函数2中，这种称为“闭包”。函数1返回函数2时，每次都会创建一个新的函数，相互独立，但函数1中的局部变量是可能变化的。所以，<strong>返回闭包时，返回函数不要引用任何的训练变量，或者后续会发生变化的变量</strong>。</p><p>返回一个函数时，该返回的函数并没有执行，只有在调用的时候才会运行，所以在返回函数中不要引用任何可能会变化的变量。</p><h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>关键词<code>lambda</code>表示匿名函数，冒号前面的<code>x</code>表示函数的参数。</p><p>匿名函数有一个限制就是只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。</p><p>匿名函数也是一个函数对象，可以把匿名函数赋值给一个变量，再利用变量来调用该函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(map(<span class="keyword">lambda</span> x: x*x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br></pre></td></tr></table></figure><h5 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h5><p>函数对象可以赋值给一个变量，并且函数对象有一个<code>__name__</code>属性，可以获得函数的名字。</p><p>假设要增强<code>now()</code>函数的功能，比如，在函数调用钱自动打印日志，但又不希望修改<code>now()</code>函数的定义，这种在代码运行期间动态增加功能的方式，称为“装饰器”(Decorator)。</p><p>本质上，decorator就是一个返回函数的高阶函数，接收一个函数作为参数，并返回一个函数，要借助python的@语法，把装饰器置于函数的定义处。</p><blockquote><p>@的作用：只可以在模块或类定义层内对函数进行修饰，不允许修饰一个类，一个修饰符就是一个函数，将被修饰的函数作为参数，并返回修饰后的同名函数或其他可调用的东西。类似于回调函数，把其他函数作为自己的入参，在目的函数执行前，执行一些自己的操作。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">'2022.05.11'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">warpper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'call %s():'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'2022.05.11'</span>)</span><br></pre></td></tr></table></figure><h5 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h5><p>偏函数的作用就是把一个函数的某些参数给固定住(也就是设置默认值)，返回一个新的函数，调用这个新的函数会更简单。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int2 = functools.partial(int, base = <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>返回的<code>int2</code>为一个函数，实现二进制转换。</p><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>一个模块就是一个<code>.py</code>文件。一个包<code>package</code>下可以包含很多模块，但是必须要有<code>__init__.py</code>文件，如果没有就会把这个目录当成一个普通目录，而不是一个包，<code>__init__.py</code>本身就是一个模块，模块名为包名，可以为空文件。</p><p>任何模块的第一个字符串都被视为模块的文档注释。</p><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>一个模块中正常的函数和变量名都是公开的(Public)，可以直接被引用。</p><p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途。一般自己的变量不要用这种变量名。</p><p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的(private)，不应该是直接引用。而不是不能，python并没有一种方法可以完全限制访问private函数或变量。</p><h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><h5 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h5><p>面向对象最重要的基本概念就是类(class)和实例(instance)，类是抽象的模板，实例是根据类创建出来的一个个具体的“对象”。类名通常是大写开头的单词，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__inin__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure><p><code>__init__</code>方法的第一个参数永远是<code>self</code>，表示创建的实例本身，在<code>__init__</code>方法内部，可以把各种属性绑定到<code>self</code>，因为指向创建的实例本身。</p><p>类中定义的函数与普通函数只有一点区别就是类中定义的函数第一个参数永远都是<code>self</code>，但是实际调用不需要传入。</p><blockquote><p>和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然他们都是同一类的不同实例，但是拥有的变量名称都可能不同。</p></blockquote><h5 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h5><p>把属性的名称前面加上两个下划线<code>__</code>，该属性就变成了私有变量，只有内部可以访问，外部不能访问。</p><p>在Python中，变量名类似<code>__xxx__</code>，也是以双下划线开头的，并且以双下划线结尾是，是特殊变量，特殊变量是可以直接访问的，不是private变量。</p><h5 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h5><p>当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类(Subclass)，而被继承的class称为基类、父类或超类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span>  <span class="comment"># 没类继承时需要继承object</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Animal is running...'</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>子类会有父类的所有属性和方法，当都存在相同的方法时，子类的方法会覆盖父类的方法，这就称为多态。</p><p>静态语言和动态语言</p><p>对于静态语言(java)来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。</p><p>对于动态语言(Python)来说，不一定需要传入<code>Animal</code>类型，只需要保证传入的对象有一个<code>run()</code>方法就可以了。</p><h5 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h5><p><code>type()</code>函数：判断对象类型，返回的是Class类型。</p><p><code>isinstance()</code>函数：判断一个对象是否是该类型本身，或者位于该类型的父继承链上。</p><p><code>dir()</code>函数：获得一个对象的所有属性和方法，返回一个包含字符串的list。</p><p><code>getattr()</code>、<code>setattr()</code>、<code>hasattr()</code>，可以直接操作一个对象的状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(obj, <span class="string">'z'</span>, <span class="number">404</span>) <span class="comment"># 获取属性'z'，如果不存在，返回默认值404</span></span><br></pre></td></tr></table></figure><p>Python是动态语言，根据类创建的实例可以任意绑定属性。但是不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类的属性，但是当删除实例属性之后，在使用相同的名称访问到的将是类的属性。</p><h5 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a><code>__slots__</code></h5><p>当对一个类创建一个实例对象时，可以给该对象添加任意属性，但是用<code>__slots__</code>就可以限制允许创建的属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'name'</span>, <span class="string">'age'</span>) <span class="comment"># 用tuple定义允许绑定的属性名称</span></span><br></pre></td></tr></table></figure><p>所以后面创建一个对象时，只会允许创建’name’和’age’两个属性，若创建别的属性则会报错。<code>__slots__</code>定义的属性仅对当前类的对象起作用，对继承的子类是不起作用的。</p><h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p>Python允许使用多重继承，因此，Mixln是一个常用的设计，Mixin类中包含了其他类要使用的方法，但是不必作为其他类的父类。</p><p>只允许单一继承的语言(java)不能使用MixIn的设计</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTCPServer</span><span class="params">(TCPServer, ForkingMixIn)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">clss MyUDPServer(UDPServer, ThreadingMixIn):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h5 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h5><p>类似<code>__slots__</code>这种形如<code>__xxx__</code>的变量或函数名要注意，这是在Python中有特殊用途的。</p><p><code>__iter__</code>：如果一个类想被用于<code>for .... in</code>循环，类似list或tuple那样，就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象，然后，for循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，</p><p><code>__getitem__</code>：要像list按照下标取出元素，需要实现<code>__getitem__()</code>方法。</p><p><code>__getattr()__</code>方法：当调用一个对象没有属性时就会报错，但是也可以通过该方法返回一个动态属性。当不存在调用的属性时，会试图调用<code>__getattr__()</code>方法来尝试获得属性。</p><p><code>__call__</code>：任何类，定义一个<code>__call__()</code>方法，就允许直接对实例进行调用。直接调用对象时就会执行该函数。而且该方法还可以定义参数，所以对对象进行调用就好比直接对一个函数进行调用一样。</p><blockquote><p>用<code>Callable</code>可以判断一个对象是否能被调用。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">callable(Student())   <span class="comment"># True</span></span><br><span class="line">callable(max)  <span class="comment"># max</span></span><br><span class="line">callable(<span class="literal">None</span>)  <span class="comment"># false</span></span><br><span class="line">callable(<span class="string">'str'</span>)  <span class="comment"># false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;python基础&quot;&gt;&lt;a href=&quot;#python基础&quot; class=&quot;headerlink&quot; title=&quot;python基础&quot;&gt;&lt;/a&gt;python基础&lt;/h3&gt;&lt;h4 id=&quot;基础语法&quot;&gt;&lt;a href=&quot;#基础语法&quot; class=&quot;headerlink&quot; title=&quot;基础语法&quot;&gt;&lt;/a&gt;基础语法&lt;/h4&gt;&lt;h5 id=&quot;数据类型和变量&quot;&gt;&lt;a href=&quot;#数据类型和变量&quot; class=&quot;headerlink&quot; title=&quot;数据类型和变量&quot;&gt;&lt;/a&gt;数据类型和变量&lt;/h5&gt;&lt;p&gt;整数、浮点数、&lt;/p&gt;
&lt;p&gt;字符串：用单引号&lt;code&gt;&amp;#39;abc&amp;#39;&lt;/code&gt;和双引号&lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt;括起来的任意文本，用&lt;code&gt;r&amp;#39;abc&amp;#39;&lt;/code&gt;表示&lt;code&gt;&amp;#39;&amp;#39;&lt;/code&gt;中的字符默认不转义。&lt;/p&gt;
&lt;p&gt;布尔值：&lt;code&gt;True&lt;/code&gt;和&lt;code&gt;False&lt;/code&gt;，可以参与&lt;code&gt;and&lt;/code&gt;、&lt;code&gt;or&lt;/code&gt;和&lt;code&gt;not&lt;/code&gt;运算。&lt;/p&gt;
&lt;p&gt;空值：&lt;code&gt;None&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>newCode剑指Offer</title>
    <link href="http://yoursite.com/2022/06/09/newCode%E5%89%91%E6%8C%87Offer/"/>
    <id>http://yoursite.com/2022/06/09/newCode剑指Offer/</id>
    <published>2022-06-09T13:43:51.982Z</published>
    <updated>2022-07-05T12:38:41.104Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JZ3、数组中重复的数字"><a href="#JZ3、数组中重复的数字" class="headerlink" title="JZ3、数组中重复的数字"></a>JZ3、<a href="https://www.nowcoder.com/practice/6fe361ede7e54db1b84adc81d09d8524?tpId=265&amp;tqId=39207&amp;rp=1&amp;ru=/exam/oj/ta&amp;qru=/exam/oj/ta&amp;sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D13&amp;difficulty=undefined&amp;judgeStatus=undefined&amp;tags=&amp;title=" target="_blank" rel="noopener">数组中重复的数字</a></h4><p>描述：</p><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1</p><p>数据范围：0≤ n ≤10000</p><p>进阶：时间复杂度O(n) ，空间复杂度O(n) </p><a id="more"></a><p><strong>思路</strong></p><p>用set数组或者dict字典遍历一遍数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate</span><span class="params">(self , numbers: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> dict.keys():</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dict[i] = i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="JZ4-、二维数组中的查找"><a href="#JZ4-、二维数组中的查找" class="headerlink" title="JZ4 、二维数组中的查找"></a>JZ4 、<a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=265&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1&amp;sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D13" target="_blank" rel="noopener">二维数组中的查找</a></h4><p>在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>[</p><p>[1,2,8,9],<br>[2,4,9,12],<br>[4,7,10,13],<br>[6,8,11,15]</p><p>]</p><p>给定 target = 7，返回 true。</p><p>给定 target = 3，返回 false。</p><p>数据范围：矩阵的长宽满足 0≤n,m≤500 ， 矩阵中的值满足 0≤val≤10^9<br>进阶：空间复杂度O(1) ，时间复杂度O(n+m)</p><blockquote><p>输入：7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</p><p>返回值：true</p><p>说明：存在7，返回true</p></blockquote><p><strong>思路：</strong></p><p>从左下角开始向右上角查询，（或者右上角向左下角），为什么不是从右下角开始，因为当该位置的值比目标值小时可能是左边也可能是上边。所以从左下角开始，如果比目标值小只可能往右，比目标值大只可能往上，直到超过数组边界。</p><p>或者：对每一行二分，时间复杂度O(m*logn)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @param target int整型 </span></span><br><span class="line"><span class="comment"># @param array int整型二维数组 </span></span><br><span class="line"><span class="comment"># @return bool布尔型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self , target: int, array: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        down = len(array) - <span class="number">1</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> down &gt;= <span class="number">0</span> <span class="keyword">and</span> left &lt; len(array[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">if</span> array[down][left] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> array[down][left] &gt; target:</span><br><span class="line">                    down = down - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="JZ5-、替换空格"><a href="#JZ5-、替换空格" class="headerlink" title="JZ5 、替换空格"></a>JZ5 、<a href="https://www.nowcoder.com/practice/0e26e5551f2b489b9f58bc83aa4b6c68?tpId=265&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1&amp;sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D13" target="_blank" rel="noopener">替换空格</a></h4><p>请实现一个函数，将一个字符串s中的每个空格替换成“%20”。</p><p>例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p>数据范围:0≤len(s)≤1000 。保证字符串中的字符为大写英文字母、小写英文字母和空格中的一种。</p><p><strong>思路</strong></p><p>字符串自带的replace方法，<strong>注意该方法替换字符之后会生成一个新的string，而原来的string还是指向原来string的地址</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @param s string字符串 </span></span><br><span class="line"><span class="comment"># @return string字符串</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self , s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># m = s.replace(' ', '%20')</span></span><br><span class="line">        <span class="comment"># return m</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)</span><br></pre></td></tr></table></figure><h4 id="JZ6-、从尾到头打印链表"><a href="#JZ6-、从尾到头打印链表" class="headerlink" title="JZ6 、从尾到头打印链表"></a>JZ6 、<a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=265&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1&amp;sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D13" target="_blank" rel="noopener">从尾到头打印链表</a></h4><p><strong>描述</strong></p><p>输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。</p><p>返回一个数组为[3,2,1]</p><p>0 &lt;= 链表长度 &lt;= 10000</p><p><strong>思路</strong></p><p>利用栈的特性，往后遍历链表，压栈，最后依次出栈就是从尾到头的链表。</p><p>递归：先走到链表末端，回溯时依次将节点值加入列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @param listNode ListNode类 </span></span><br><span class="line"><span class="comment"># @return int整型一维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self , listNode: ListNode)</span> -&gt; List[int]:</span></span><br><span class="line">        val = []</span><br><span class="line">        node = listNode</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            val.append(node.val)</span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">return</span> val[::<span class="number">-1</span>]</span><br><span class="line">    <span class="comment"># return self.printListFromTailToHead(listNode.next) + [listNode.val] if listNode else []</span></span><br></pre></td></tr></table></figure><h4 id="JZ7-、重建二叉树，根据前中序构建二叉树"><a href="#JZ7-、重建二叉树，根据前中序构建二叉树" class="headerlink" title="JZ7 、重建二叉树，根据前中序构建二叉树"></a>JZ7 、<a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=265&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1&amp;sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D13" target="_blank" rel="noopener">重建二叉树，根据前中序构建二叉树</a></h4><p>给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。</p><p>提示:</p><p>1.vin.length == pre.length</p><p>2.pre 和 vin 均无重复元素</p><p>3.vin出现的元素均出现在 pre里</p><p>4.只需要返回根结点，系统会自动输出整颗树做答案对比</p><p>数据范围：n≤2000，节点的值 −10000≤val≤10000</p><p>要求：空间复杂度 O(n)O(n)，时间复杂度 O(n)O(n)</p><p><strong>思路</strong></p><p>树的结构一般通过递归实现。</p><p>前序的第一个节点为根节点，然后中序遍历中根节点的值的左边就为该根节点的左子树，右边的所有值就为该根节点的右子树。然后通过递归也同样构建子树。</p><p>注意递归结束条件：当前序或者中序为空时说明没有节点了，返回None。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param pre int整型一维数组 </span></span><br><span class="line"><span class="comment"># @param vin int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return TreeNode类</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self , pre: List[int], vin: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> vin:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        index = vin.index(pre[<span class="number">0</span>])</span><br><span class="line">        root = TreeNode(pre.pop(<span class="number">0</span>))</span><br><span class="line">        root.left = self.reConstructBinaryTree(pre, vin[<span class="number">0</span>:index])</span><br><span class="line">        root.right = self.reConstructBinaryTree(pre, vin[index+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h4 id="JZ8-、二叉树的下一个结点"><a href="#JZ8-、二叉树的下一个结点" class="headerlink" title="JZ8 、二叉树的下一个结点"></a>JZ8 、<a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=265&amp;tags=&amp;title=&amp;difficulty=&amp;judgeStatus=3&amp;rp=1&amp;sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D13" target="_blank" rel="noopener">二叉树的下一个结点</a></h4><p>给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针。 （输出给定结点在中序遍历下的下一个结点。）</p><p><strong>思路</strong></p><p>中序遍历下，一个节点的下一个节点：</p><ol><li>当该节点有右子树时，输出右子树的最左边的那个节点。</li><li>没有右子树时，就得往父节点上面查找，得找到第一个当前节点是它的父节点的左孩子的那个节点。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeLinkNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span><span class="params">(self, pNode)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pNode.right:</span><br><span class="line">            cur = pNode.right</span><br><span class="line">            <span class="keyword">while</span> cur.left:</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> pNode.next:</span><br><span class="line">                <span class="keyword">if</span> pNode.next.left == pNode:</span><br><span class="line">                    <span class="keyword">return</span> pNode.next</span><br><span class="line">                pNode = pNode.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h4 id="JZ12-、矩阵中的路径"><a href="#JZ12-、矩阵中的路径" class="headerlink" title="JZ12 、矩阵中的路径"></a>JZ12 、<a href="https://www.nowcoder.com/practice/2a49359695a544b8939c77358d29b7e6?tpId=265&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=3&amp;rp=1&amp;sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D13" target="_blank" rel="noopener">矩阵中的路径</a></h4><p>请设计一个函数，用来判断在一个n乘m的矩阵中是否存在一条包含某长度为len的字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 </p><p>数据范围：0≤n,m≤20 ,1≤len≤25 </p><p>示例：</p><blockquote><p>输入：[[a,b,c,e],[s,f,c,s],[a,d,e,e]],”abcced”</p><p>输出：true</p><p>输入：[[a,b,c,e],[s,f,c,s],[a,d,e,e]],”abcb”</p><p>输出：false</p></blockquote><p><strong>思路</strong></p><p>dfs：</p><ul><li>递归参数：当前元素的行列索引 i  和 j，当前目标字符在word中的下标k。</li><li>终止条件：<ul><li>false：下标越界以及当前元素与字符不匹配，或者已经走过。</li><li>true ：当前的k与字符长度一直，说明全部匹配。</li></ul></li><li>递推：标记当前元素位置，说明已经走过，遍历上下左右四个方向，还原标记的位置，说明该位置回退。</li><li>返回值：返回布尔值说明是否搜索到。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @param matrix char字符型二维数组 </span></span><br><span class="line"><span class="comment"># @param word string字符串 </span></span><br><span class="line"><span class="comment"># @return bool布尔型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self , matrix: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j ,k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= len(matrix) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= len(matrix[<span class="number">0</span>]) <span class="keyword">or</span> matrix[i][j] != word[k]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> k == len(word) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            matrix[i][j] = <span class="string">''</span></span><br><span class="line">            res = dfs(i<span class="number">-1</span>, j, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(i+<span class="number">1</span>, j, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(i, j<span class="number">-1</span>, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(i, j+<span class="number">1</span>, k+<span class="number">1</span>)</span><br><span class="line">            matrix[i][j] = word[k]</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> dfs(i, j, <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="JZ13-、机器人的运动范围"><a href="#JZ13-、机器人的运动范围" class="headerlink" title="JZ13 、机器人的运动范围"></a>JZ13 、<a href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=265&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=3&amp;rp=1&amp;sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D13" target="_blank" rel="noopener">机器人的运动范围</a></h4><p>地上有一个 rows 行和 cols 列的方格。坐标从 [0,0] 到 [rows-1,cols-1] 。一个机器人从坐标 [0,0] 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 threshold 的格子。 例如，当 threshold 为 18 时，机器人能够进入方格   [35,37] ，因为 3+5+3+7 = 18。但是，它不能进入方格 [35,38] ，因为 3+5+3+8 = 19 。请问该机器人能够达到多少个格子？</p><p>数据范围： 0≤threshold≤15  ，1≤rows,cols≤100 </p><p>进阶：空间复杂度 O(nm)  ，时间复杂度O(nm) </p><p>示例：</p><blockquote><p>输入：10,1,100</p><p>输出：29</p><p>说明：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">4</span>],[<span class="number">0</span>,<span class="number">5</span>],[<span class="number">0</span>,<span class="number">6</span>],[<span class="number">0</span>,<span class="number">7</span>],[<span class="number">0</span>,<span class="number">8</span>],[<span class="number">0</span>,<span class="number">9</span>],[<span class="number">0</span>,<span class="number">10</span>],[<span class="number">0</span>,<span class="number">11</span>],[<span class="number">0</span>,<span class="number">12</span>],[<span class="number">0</span>,<span class="number">13</span>],[<span class="number">0</span>,<span class="number">14</span>],[<span class="number">0</span>,<span class="number">15</span>],[<span class="number">0</span>,<span class="number">16</span>],[<span class="number">0</span>,<span class="number">17</span>],[<span class="number">0</span>,<span class="number">18</span>],[<span class="number">0</span>,<span class="number">19</span>],[<span class="number">0</span>,<span class="number">20</span>],[<span class="number">0</span>,<span class="number">21</span>],[<span class="number">0</span>,<span class="number">22</span>],[<span class="number">0</span>,<span class="number">23</span>],[<span class="number">0</span>,<span class="number">24</span>],[<span class="number">0</span>,<span class="number">25</span>],[<span class="number">0</span>,<span class="number">26</span>],[<span class="number">0</span>,<span class="number">27</span>],[<span class="number">0</span>,<span class="number">28</span>] 这<span class="number">29</span>种，后面的[<span class="number">0</span>,<span class="number">29</span>],[<span class="number">0</span>,<span class="number">30</span>]以及[<span class="number">0</span>,<span class="number">31</span>]等等是无法到达的  </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>题目要求机器人能到达的所有路径，并不一定说是一条路径能到达的，所以用一个全局变量ans，只要当当前节点能走且没走过就ans加1，然后标记当前节点已走，后面不用回复节点状态为0，因为不要求不重复的一天路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param threshold int整型 </span></span><br><span class="line"><span class="comment"># @param rows int整型 </span></span><br><span class="line"><span class="comment"># @param cols int整型 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self , threshold: int, rows: int, cols: int)</span> -&gt; int:</span></span><br><span class="line">        m = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(cols)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(rows)]</span><br><span class="line">        ans = [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= rows <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= cols <span class="keyword">or</span> judge(i, j) <span class="keyword">or</span> m[i][j]:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> m[i][j]:</span><br><span class="line">                 ans[<span class="number">0</span>] = ans[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">                 m[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="comment"># m[i][j] = 1</span></span><br><span class="line">            dfs(i<span class="number">-1</span>, j)</span><br><span class="line">            dfs(i+<span class="number">1</span>, j)</span><br><span class="line">            dfs(i, j<span class="number">-1</span>)</span><br><span class="line">            dfs(i, j+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">judge</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> bool(sum([int(n) <span class="keyword">for</span> n <span class="keyword">in</span> str(i)+str(j)]) &gt; threshold)</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h4 id="JZ14-、剪绳子"><a href="#JZ14-、剪绳子" class="headerlink" title="JZ14 、剪绳子"></a>JZ14 、<a href="https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8?tpId=265&amp;tags=&amp;title=&amp;difficulty=&amp;judgeStatus=3&amp;rp=1&amp;sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D13" target="_blank" rel="noopener">剪绳子</a></h4><p><strong>描述</strong></p><p>给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（ m 、 n 都是整数， n &gt; 1 并且 m &gt; 1 ， m &lt;= n ），每段绳子的长度记为 k[1],…,k[m] 。请问 k[1]<em>k[2]</em>…*k[m] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18 。</p><p>数据范围：2≤n≤60<br>进阶：空间复杂度O(1) ，时间复杂度O(n)</p><p>输入描述：</p><p>输入一个数n，意义见题面。</p><p>输出描述：</p><p>输出答案。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">8 </span>= <span class="number">2</span> +<span class="number">3</span> +<span class="number">3</span> , <span class="number">2</span>*<span class="number">3</span>*<span class="number">3</span>=<span class="number">18</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>当分段的每段长度为3时，乘积最大。数学公式可推导。</p><ul><li>当最后余0时，就等分为3之后相乘。</li><li>当最后余1时，就取前面一个3然后分成2*2，乘积最大。</li><li>当最后余2时，也是2乘上前面一个3。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cutRope</span><span class="params">(self , n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x*y, [<span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range((n//<span class="number">3</span>)<span class="number">-1</span>)] + [<span class="number">3</span>+(n % <span class="number">3</span>) <span class="keyword">if</span> n % <span class="number">3</span> &lt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">3</span>*(n % <span class="number">3</span>)]) <span class="keyword">if</span> n &gt;= <span class="number">3</span> <span class="keyword">else</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="JZ17-、打印从1到最大的n位数"><a href="#JZ17-、打印从1到最大的n位数" class="headerlink" title="JZ17 、打印从1到最大的n位数"></a>JZ17 、<a href="https://www.nowcoder.com/practice/4436c93e568c48f6b28ff436173b997f?tpId=265&amp;tqId=39279&amp;rp=1&amp;ru=/exam/oj/ta&amp;qru=/exam/oj/ta&amp;sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D13&amp;difficulty=undefined&amp;judgeStatus=undefined&amp;tags=&amp;title=" target="_blank" rel="noopener">打印从1到最大的n位数</a></h4><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><ol><li>用返回一个整数列表来代替打印</li><li>n 为正整数，0 &lt; n &lt;= 5</li></ol><p>输入：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @param n int整型 最大位数</span></span><br><span class="line"><span class="comment"># @return int整型一维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span><span class="params">(self , n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, pow(<span class="number">10</span>, n))]</span><br></pre></td></tr></table></figure><h4 id="JZ18-、删除链表的节点"><a href="#JZ18-、删除链表的节点" class="headerlink" title="JZ18 、删除链表的节点"></a>JZ18 、<a href="https://www.nowcoder.com/practice/f9f78ca89ad643c99701a7142bd59f5d?tpId=265&amp;rp=1&amp;ru=%2Fexam%2Foj%2Fta&amp;qru=%2Fexam%2Foj%2Fta&amp;sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D13&amp;difficulty=&amp;judgeStatus=3&amp;tags=&amp;title=&amp;gioEnter=menu" target="_blank" rel="noopener">删除链表的节点</a></h4><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</p><p>1.此题对比原题有改动</p><p>2.题目保证链表中节点的值互不相同</p><p>3.该题只会输出返回的链表和结果做对比，所以若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p><p>数据范围:</p><p>0&lt;=链表节点值&lt;=10000</p><p>0&lt;=链表长度&lt;=10000</p><p>输入：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>&#125;,<span class="number">5</span></span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定你链表中值为 <span class="number">5</span> 的第二个节点，那么在调用了你的函数之后，该链表应变为 <span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">9</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>双指针，用一个指针指向当前节点的前一个节点。两个指针同时向后遍历链表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param head ListNode类 </span></span><br><span class="line"><span class="comment"># @param val int整型 </span></span><br><span class="line"><span class="comment"># @return ListNode类</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self , head: ListNode, val: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head.val == val:</span><br><span class="line">            <span class="keyword">return</span> head.next</span><br><span class="line">        pre, cur = head, head.next</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                pre.next = cur.next</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre, cur = cur, cur.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h4 id="JZ22-链表中倒数最后K个节点"><a href="#JZ22-链表中倒数最后K个节点" class="headerlink" title="JZ22 链表中倒数最后K个节点"></a><a href="https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=265&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1&amp;sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D13" target="_blank" rel="noopener">JZ22 链表中倒数最后K个节点</a></h4><p>输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第k个节点。</p><p>如果该链表长度小于k，请返回一个长度为 0 的链表。</p><p>数据范围：0≤n≤10^5，0≤ai≤10^9，0≤k≤10^9</p><p>要求：空间复杂度O(n)，时间复杂度O(n)</p><p>进阶：空间复杂度O(1)，时间复杂度O(n)</p><p><strong>思路</strong></p><p>双指针，先将后面的指针向后移K个节点，然后两个指针同时向后移动，当后面一个指针到链表末尾时，前面的指针指向的就是倒数第K个节点，直接返回该节点就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param pHead ListNode类 </span></span><br><span class="line"><span class="comment"># @param k int整型 </span></span><br><span class="line"><span class="comment"># @return ListNode类</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self , pHead: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        pre, post = pHead, pHead</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> post:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            post = post.next</span><br><span class="line">        <span class="keyword">while</span> post:</span><br><span class="line">            post = post.next</span><br><span class="line">            pre = pre.next</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h4 id="JZ23-链表中环的入口结点"><a href="#JZ23-链表中环的入口结点" class="headerlink" title="JZ23 链表中环的入口结点"></a><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=265&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1&amp;sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D13" target="_blank" rel="noopener">JZ23 链表中环的入口结点</a></h4><p>给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。</p><p>数据范围：n≤10000，1&lt;=结点值&lt;=10000</p><p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p><p>例如，输入{1,2},{3,4,5}时，对应的环形链表如下图所示：</p><p><img src="https://uploadfiles.nowcoder.com/images/20211025/423483716_1635154005498/DA92C945EF643F1143567935F20D6B46" alt="img"></p><p>可以看到环的入口结点的结点值为3，所以返回结点值为3的结点。</p><p><strong>思路</strong></p><p><strong>set集合</strong>：</p><p>依次遍历链表，将遍历过的节点保存在set中，后面遍历时判断下一个节点是不是在set中，如果是，则该下一个节点就为链表环的入口节点。</p><p><strong>快慢指针</strong></p><p>定义一个一次走两个节点的指针和一个一次走一个节点的指针，当两个指针才是重合时说明有环，此时将快指针重新指向链表的头。然后快慢指针依次向后一个节点的遍历，当再次重合时，就为链表环的入口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        s = set()</span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            <span class="keyword">if</span> pHead.next <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">return</span> pHead.next</span><br><span class="line">            s.add(pHead)</span><br><span class="line">            pHead = pHead.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast, slow = pHead, pHead</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.next: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast = pHead</span><br><span class="line">        <span class="keyword">while</span> fast != slow:</span><br><span class="line">            fast, slow = fast.next, slow.next</span><br><span class="line">        <span class="keyword">return</span> fast</span><br></pre></td></tr></table></figure><h4 id="JZ24-反转链表"><a href="#JZ24-反转链表" class="headerlink" title="JZ24 反转链表"></a><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=265&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1&amp;sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D13" target="_blank" rel="noopener">JZ24 反转链表</a></h4><p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。</p><p>数据范围： 0≤n≤1000</p><p>要求：空间复杂度 O(1) ，时间复杂度 O(n) 。</p><p>如当输入链表{1,2,3}时，</p><p>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。</p><p><strong>思路</strong></p><p>双指针，一个保存前一个节点，一个为当前节点。只要当前节点不为空，就把当前节点的next先存下来，然后将当前节点的next指向前一个节点，再把前一个节点和当前节点向后移动一个，继续遍历。</p><p><strong>注意：反转链表之后需要把原头指针的next指向None</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param head ListNode类 </span></span><br><span class="line"><span class="comment"># @return ListNode类</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self , head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        pre, cur = head, head.next</span><br><span class="line">        pre.next = <span class="literal">None</span>  <span class="comment"># 很重要</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            temp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre, cur = cur, temp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;JZ3、数组中重复的数字&quot;&gt;&lt;a href=&quot;#JZ3、数组中重复的数字&quot; class=&quot;headerlink&quot; title=&quot;JZ3、数组中重复的数字&quot;&gt;&lt;/a&gt;JZ3、&lt;a href=&quot;https://www.nowcoder.com/practice/6fe361ede7e54db1b84adc81d09d8524?tpId=265&amp;amp;tqId=39207&amp;amp;rp=1&amp;amp;ru=/exam/oj/ta&amp;amp;qru=/exam/oj/ta&amp;amp;sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D13&amp;amp;difficulty=undefined&amp;amp;judgeStatus=undefined&amp;amp;tags=&amp;amp;title=&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组中重复的数字&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;描述：&lt;/p&gt;
&lt;p&gt;在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1&lt;/p&gt;
&lt;p&gt;数据范围：0≤ n ≤10000&lt;/p&gt;
&lt;p&gt;进阶：时间复杂度O(n) ，空间复杂度O(n) &lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>2021-04-09</title>
    <link href="http://yoursite.com/2021/04/09/2021-04-09/"/>
    <id>http://yoursite.com/2021/04/09/2021-04-09/</id>
    <published>2021-04-09T07:40:58.103Z</published>
    <updated>2021-04-09T09:25:52.450Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="enter password to read." />    <label for="pass">enter password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX1+mXzYJQZF2TOw0Yg7DeJ5aI7MaSUml7v7TEUQOzkLqcFv6gpJErO9fOL+KrwJ5JFYnAXeTZR3J7YVEsd4TpJgDJilzNlJ5+lLvuYZ4iDJu9I/XBwzcbsrl1bgR11AKv/T/wzdyXNqRduS/teCd2wIEr8cvHYl+BJNURzaI9IWdWXuAaouIVeeje+NWQ1ACM4ePWUVj6s7dSZku0n3lF06jP7sMjxvz87Dj8cKSIiiHNS6GctKJOJYCOoNDCLWgTabXx9cCLvZ3iFx2YQlLhUDJ7GYN6tCLBDX5AGcBoqPRf24rbnbTxTEZnQ+S2i8X4k8+Hh+uL7y1X14ekkvY+C1Q2zO18ddeaFMh/GkOyxewtRRjN8lu1940I0f8ZyGBW5A6Ai5r+Y5Zn0eyscIPKNVcfIKUIMHewkg7+reelQdvBl3P6jm5YXMXRrMqls9x0B96AIhe6LQRKmbAEbKH8N0ET0oOI141JmyqEVr8gsf/nim23HvtwWvWtaIPe+2EkxQGTySA6xjKfNQU8ZncX+vVq32fJ7zu5sCh51N1NcdFYn3UJJToNpX3JMU6nBO2RJDGndCcL1p2ikbGwNYwECklyOInSncqH5AwLsDmlx+6G2UESFuy4knUzuuu/jJeUcIEwyaRaDlYp6tMNKSeOuTu/3wA2p64mkR17tZ+5n55Zau1VjvI05LypzVmp4DF6sRaeAAkc0m6gey3/dyq0I6B1q+Iw92GBirhKOmnFZWuWto98YAtl5k32RsvhuHZv4DPMvP01msyTi9oux8eouyesyRnkmdchVYjVqQq2QeC+x9oWRQBWNMUdVZ5MP1VtI8rbzvVLNlAZVf5RtiaHQVgzLrhGL8efAKwOWXjGVvbgAXLUtaD9Ygcwwrli+Va2E1nTW+opBhHBLpMrSScNiQNuzJMTJYJ2Z+rT9r4y3xKNOXX5i2TA+koNGBgAWpDfKmFyxYqeyQzf8FxmKwm/LDP+lFfdFDmGfZFbefsmW67tWmlkmYC8ublSCSCWglcJRpbWV9V7Naatxyo4g/fscjVp41NORMA4ilFzPYpIiFdzQoFJfAXbEv83nsYd+s2u7NfW8LMO5MxdX7WQg2duhKSBbidSVd+C9WTyRc/YJYsbLgfgBPcsILhSxmhEvlFmqNwm4dS5Q+nPxg8eTkqXd3u7LxK3FFlhDyVZGc+NG8JdCW9BmzxBcz+NrytFmf+akW0AousZsm2W9B0Srzehyv1DQ2XN6UTlbprJLYA2+lXfeocJI4kH+Msyc7OeEQ+E/mzX8biW1MMX+NqmtLtxv5LRAbS7/28XhMopGs7fd/MSSaCxEGVbqABSlOYkxAbtEmbcCNPnE9keGIN+KxH5zR4PNnHpRc2S57QELN75kOy18HbUkB/s3xjBUk8zKJZZWdi7gnDtwd+rhAXeqXtGt1LV/aWE9WH2Zbuqp6lkWqKiZflU4w7wF3PNojQyv4MToLgkaJGAazu+uXgZpklGWzgk6TI6ADDC/OA2ekXFVit12eyDGhDKbJ4z+8eRXOddqfITyn8cJAePupyyuHlCFrhuffpIzT5/ESXJBs4UpSUzDko6/hf919KKFDan4+MWT+ia4M4XYJEJ/FymlMNWBa3VPASQ2nBYBhbSgaemThTUEYcvrh0cqdKToW0nkSIUFRz7SiWQovLrJkzAxFxOMzhVqEb+ptuCeaN4mRUpw5XfYkvT0Cs6KtDtPA/oXF7cebtDdpZ8C1HAgMXuxja3sUhCj8KU4MQUx8TRk7ULv1SArybzQXkf4KtTmOrRV8JbH9EuqzExze9m4DsX3YFqrXL5fC9vKOpWjOy1/lIyms1aMUJRK2gllXvZk8Zh/5vir6rKnIMILCN45NC6EeqbdF1CFp0vmIp6vAKCu2ijrixvbI/AqPOMpqlplC47Txj5TjLiX3ce6MgqRxTiihNM2Q6XG6jw1WGDMmubnNNM9gVC8L5S1RNBTGkgt87yLivi1310YFLU/LTTsyg3wadmrr80+R4WNF7Ub2whvHwdXZjRqoSRRyDHVh++yZBmXeWtfxutime4eBWyjYO0sdP8BcuCmS/Atvnp+2ZrwDWAw7mp2ctVs0UATvAXS90mRg0ngcOhlQLdx6Gi8z8iW+1iPuaokzQcI5AK2bFmL4JHjlkjwUO9ph1acSdPLQGlBdF5bdaqivadOVNslYT615T6V5KqDTXNPOFUizDiE6HUHyvL+715hdIiu0PAw+gY8UqFtv6nyUVzDiFNgH7EVfjtxgTquMVH7DbtilMd8QW4eBE1CSKVTvuXWoiHJ3oM9qbP1MoX4/td8nFLmupVEpjTTdMrSKdtN0f3n9Fyl4e52p0aP4EVWoI4I03Qk6d3lJfWHmGBvgCRJ4V03eQzAa5+8wWPi6Qk5XF7675c2e0VO4hHU+SsyZhW7gdaCGgQ6XQ0v+9ghA7ICctGvZUBd2Ldnz9W2gOI6CzspSqHn7Q+BQoJF43rW0isud4gfWYGK9BHuXTH6huEil77eUl4o9RBqeS/gUDp7neD7l94tTv2HAQI+XouJUDS2Z53SFdAB6buC9G9AoZBQ3kObF21rWxxbrNmI4OCLFTDZj54HDkX7mKRA2HZhcvoAOnbmtYDukP8tuw1BMdMrhhRpfjNS4bv4zEcWyUcjsRTLRaeCt3fBOOPwB5grctmUi/XQCgO2CcfI6C1GTHstOsGyS4L43sy0pGZi9u8JSdl75LS3CTwr3mAtfLOP4JUHyp6m45eVLl0P3/bQvlHeMjiBtPf46aLBKTk8k+EHIThVNImkKDRLjJxfnI6FwFvtl1ePdR649YoKazF0JEN6e2karI6ZpKUsOFZaHM+Ef8E8seeIa9MJMJWKWyB++H8AybBnt6EZR30Xb7xV4R6GJaigYN1LG/m0LSm2BTf8ew4f8vgXMXGTIThcp8OEiy2CdGp7xAbdNYsJv4H927Qz0DBPQHxw19GaMoy9CF94n162Gix+5/WDXDTmJ5JKkHIO3RJmgqzIXPpt1DlhwZMXetr/0iTwz6vrNsi4kAimCxJuWGzzvtQZBuP5kmIjPmKercnLS2cssUoHT7tB3ei+e6NxMdN6AFPYaDoNqDjMvgMnKVxHXTrXZOUAxC6ha0G+p58VF0S/y1vxAl5c0kED+XQ08kGPFsMLWgUMeV6kBd+pm2QgK1Hr3M/CFxF1hCLHc8DvHOIpfd8vlH0IbdHzh1UKdqKEo2j371L5ct5LeNYeR2Ocp2pTeUMpJEgt+mQUch/5paXtKBkLeo10ZiJm2qEpVdxeBxFncZb6DFlYTD6wxiJ5L3B0LdE+3ENpC4R4Bw8is16ZedorZ/xssnToH2FO6hsP9tdsQYFies6p7PtfJjMst7qfYAblz/M2QmVnjYMGGeUOVaZFWIpZ1RE64lCRhqPCPimOx7NK3Mc95CTfiMdd8KqEEtg16XsZv/SjfFa5eJ2rlb00N6laIDU8wK0Qfgjn+FheOqvrhn92ihj9ItuOtUXrcS4RAkczONdpsdzQVfAjwMmKHwKds6sXV1JBE84VVkDJIaYJ51+uXLEFqW9wAEgy46thmP9BqJzsaI6G2M5HM495XYovwjPNYvZg/Qz7xusJQrHB1fAaqRqFAPuPz/mm/QDZKSt0Y0A1jZcqwV02PjaqShlQoNkFxEjAEX1wwdJQTvIhyU0IOJ1NxRAVBAb6O9qxKx2ZuBOdUq34RTnEmDk2E3DilITL1SaDEtlH6soeB4F3pvjg6rhG3X4xeb9Zz53OKR5jbyeKai5+7X8+1OK2miOQ6Igo+By4VDT2aBqn+j+plmcO/cf8HTJUlSgXmeM7N+8Stz/rlAA5VMIaP1VehDRiOmyc2N5Rn9ujNM/17TCn/KfYanGDec53HR02P8dZvEP5Yj7vX3OCojcLYSygB4iJqKToZzT0DBeQAezEM3mQF4uX4BXLAQmfyQ4STcuiiNrNZCN0vfSMnmArwbRN9CIYvBSnSRoY1clMK661KJ6/fAiRviw1hlrj7oSqIyvB9Q9q1ODyvuF1HMP7xLYCaB63AK4m/TvVy0xwGbhNtahH1+ZsWuTuCxCWDh/yFT3IuLkNxjrNHUEscz1TstBdInzfyVrAua5oKvvzRkJNWujBMbDOL7yXv7GZPOGN/ADbn0vlExpws59F8cDQTECaNOz7eVeXn0Ue2T//mohTcAgZU8stb4jYo+5KCdmx7JPvd/q/rfYDj38+AObw1I183t0kudctHqDYHas8a7gsb2r5hsBAuzvT9gp+HTaf50jbLgIkYn1OZW1JUnnHqjAf6WfzCmggEFwgT5l4j9yfUUEwxU6ijfWedRsNWSfmO24IMP3cdfF/K2ZJfpntcFi7uPlx5jemZo24ZREi92kj6bDompMfNowKUSKsYxSUYdRtNt68rd+swxxudS88l4BciX/Kvmi2xAOxns2wHjqmxpufpkrBWk5tqHCk3RltAhLQeUsVld66vGjsqlxBRNeK5g+BEsyJb54RxHo6vc6grW8gPe2bQrZY2YGhVFHwJLIv+fDmZuY3tMX5VJqXttYlgKW/mnsplS8JeBoX9yubLtoCg+a5W+Q3s1004us9n+1WWCPb9OzqegBGCiJLgIfBSF16blzJ8xxAHgrhgx0YBaM3rhlKTYLDKr9QMQwzS8N2g46HaBqWKFODtXBirzRar40Q0S1yispvgfvRktVdlYeK0t6n4uOji79OoU2MnUCrPdoQkqUJ3qpggzUwIFkudYnw/XbgQx91XBqagD0tWlRe6Z6lTF54qPZ0aiZtfACqBjdhM1khYfe4Xm7YN0OaU8Nd7dOgZ7kzn29IEhC34MC1wd6f5am7gdLphZU/1ex0ARAANG8hpJEIMYkQjiM7UjuBA44HtDz+aavGv0hJJKKIin5BwmipG4dHOoMVm3AoZmcdRVheVAh/VWXrz/XcIDoeZAPzmABMHGbLyti1waPOG5XNPmyFOuRtf8HKYleQxyL9NWvSbBVGyWPzLxdhCr/RXMUQU8PbhwKLdgOs2PWJncE0yOFbBZ2//BBAQaq5WY4Jp1ei9dewx50aCnuQj4Klfr5Z79O6jNX4doZH6wrRlXfFqbCSBJIhq/MRbmyyptwFfwmKSND8nU84UXYKJlT/tB5thp5koUai4xBrpsSggewfkF6JuUXImPl1DNo0foKp+S7X8NRQL1Qab8OwX537uJRx+YnQPvtQREbOSYsDr+LPX3LCS6UK6FxkwCgVRNOJYdUG8cP2NX0RSHSqYPlsbzJDxaKvUBoXW1xsxtUyJhe+Y/I5U6MieXyf5KaN+WC9YfdDFysIx9OYK6D3ggXrrk6MAx2zgFDVQEGUqlHY1V6w4qhNpP8DC7au9FUIQ0l5fHIOtEpn/bj1JibNCh2kagWEm35QkfthqmOmFj3Yg5KN6aB2gtWdq7OMnTwXXrwAMXB/u0JdUzWPxxUKyL0CqtQ2pNb8RMxyYQJA2Iq8ppraR1i4Ahfbq5jFvVRSonNXqO3qCeBzp2DFfWV1q5qVtOif0VGgL31zaQ7QqknexvjUNEqm7IFLfpbsBksPt+mZdjdAfW5lHWuFeBDbw9/35yOimr8Dk9CH/7nWB1LJkBnNu2mOWJo7PTD+kARGHV5UgB2m6FGDKVolKx8ksL8MwL3yFw1A0S10mbFpZL8MY+uC0mjCrus8kLaxKFOj+cS2cAZs+syAaYFwZMonBvC5eIUXpqx/kzni2EUrhtsztoWe4icTBYTnNDd0ISaxBxYy1j7N7pXhDgRa4VGXXiS3VbYoTeODwzN/wmK4/0QtwEHgpt8AFDO4nQP7ldQCYrLQYiYVOGOVDp1IZYuJIVYucvdTw1DJbz0zii0/JeAl36V50Qz/JY1KOKQF7NU4Pw1larrYGkwuZD35UVKGFuuxUbEc8j/axdwi4ZdbKqsboVgzfxm8ZJpFZBkTHHhcIHjTyNMMuQZ4mB8TEAYggDWtMfkHPhndniM5QXFGoPqH2atdIFzffCy8szj0sJBbXlNM/NLuwRkNbrbnOsdbBCuX10SKVggYMOIh/I2mvnddvt8LNd+ACySS6SV/C0iPhuNlNwvAUUfcIgttJXHaT/1X/8LE6ie3Pc+5+Y8PObEdlUH42Cuv1DPQJQIQqGGiGYZlXWyobx/dq+g/7pTvoT0OaKmwpDOlrizxryQfWAWnZW8W1HFWNwhvNIW3hKjTuRejDETTnzJ6zjUx0s7qSVATZp3G4QqJasuopGKaXPuvBYevdT2AX1xF9bsF62vQo45ZM/IgQdaVbv5HriqPNSPeOKnKohj8AF8OfNVDa86U8SLofzFNrHiHgpMBdWuCQcJr2aY2gQJ95oEAnGhbc7RplOJmW9Aofpi7ikKZVQKFDgs6TQxNSP7JE9DRlqYn+xpwTYekYofgKu7ge8gZwPFGu3hKFNXXuoedxnqlr2ZFb3Jzht5GtsK0lcz+ET/9em19kYMEsyiwD/fCqC2q3Ftzm1B4qMaA9mQahbi8ttdb3iPMkN/NxPDcH8/3j3rbS6uKEmIHas9IU4i6jtahBX8vqvMzF/nqpAbK1Tgpat9Wl0cpEaqroX2+dRsVdmEehxt9PkMgex32jjP3bdXRCSTJIJ6f41WfmbDbHDFoXdUZ67xvqCuw6Ex6tW+h3Zt1Xn6pivO6gVS48NKbqQfO4z9GfpF/zg15Rwp8UYCiv9zGsPr0YuZTi1LgRRAKMzdilVZjUrbOu/kz0oZvU3A/EVIezooYv7UxlPGMTu5kNadOUayKEFwQrwROhM1tuSqqRExsXaD7FeU12mvkv0kQK9Zz8alKbyFlmIv+Z5W8T6o0ld96WRlIbRoCU5pPRswTzUFJmF2v4igP7WgZd8YV2uPoRV55awZaxTlFa6OxNzQ1Xo0wdbSGLk6vnbnRV/lDH7HriObYYBH0kzvZmQa+aXOAoutQgtoii1hfBx12BXm2EirBQ4Pl2iYza8Xa7A+LTR+NUyPEcoabv8OIQFVHermqefwV8ypVmFxfYRBq/qavmmgFJcBQtJUwGdHvm5kAHXxlGEejp/JVhHuCqCsP1ttLvr+w/uchvlbdiMzuKWj5NKWuCIFZTNzQKyUMj4pZ0RZmn+EoZhSun9DDkjh9+wQi8dLeT56AiIAKznE0wIFFhTDiXfY+vFyFEfhSdhY01byfcB0FTgU4d+U51kkKtIcXg+ecgCVhMypXy/eo6VGJ0bimAE6NktTAkjBjw2eLcJnRIz9umd6oxpuj08CmqzxtKWS8OHRU4pfmXFanbFRUtEC45DWH73lhf+rndPbwFZPMOnXga+OBTxBd7rFOTZuOxGBu4YJyyrEwNATDRV4BQfiKXE8X4qV017wgSOVIoMMsml8oMGs5mHA219J9mkUFBjFh6Rn5aYtkgxYXPVhYUXRXamKsoTfEHEn5dJz0mNYmEEWOcfEc143ac2U+rv9Z7zB6p9L5nVaVTWBC1VQ/iwrogL4fcM1HkT8BF5TEKU1nSBo38c+WH8DoG9B9jUW2w7AeceMMCsDu1BcUb8xgLWcB4TmjC1zsYpMQTDnmL/krUGPT4nsKmhgM8vPr4ioShVXFreakSdyz6kNMIwe8sYPd/spsTopz+plypWA1mQMvpMe2BI4l/MAdzwhHT7QVidG5M1xPOBLyLv2drZdj49/fefi8+Ct+R5+OEhUEuzgFg8YQ28R3RTi4y9tM+fOkgqXCU+iiDdGL91+gxu7prti1/dfaPETJb1Cz1DzSSBYvkglbJO7MmWF6IpQW78Pa1I/ln7dranNKdwmGu5OcW/iAPXbr7WOP5BhSWckjTcFNXGIaLBVr+CKE6eyL9H1PleZ9ah/nMiMXCRm0jEPzSxhccLW11wp04fI1F2K646O8QnlLQM69dJsqRZ8usvBqxxz6kiSQ9Sz7JjZaQ0U9cqBWkIofzrj0nKCp01K3MCJ5t/dNcP0b/w5SBQ7Sk1Z7ucPORkz0gSoBM+ilBapnkCRJI8jk5ZDcaHHAX0UttHIrpk5RZbaREsfUJXWMAZKF/FfnKhDYnQURv4G5FAZFOSebRsavGLlZQnyQVXQnERxPyYLUlZDYWVzhYVnHE3yYJ3Z82TNkAma1nNlxxh8unuXQCedmhyQmkbsstS1tcSSdU6Y7zr3tpD36VzESvjjV17URnVEFoNZ+el7bsjMNF5orN5tls+p77ekyvtmRjLCArtT/IcjRsOcMFuyICnbDevO6M7rxFzZvSl9Zurw3hM7/l6errqajF7/EYVrBKMxrr/Mg8opuOead6pIStuDQHWNHfZH05H7xQWJy7tubuW+vEUO4HrwQBNI97WCsEQ9s0hrfSJqTYtdbVQ5YSpn8yAiGyi9mlQ69+Am+m+8/a/Jm+R63XC6AfR3mUsWK3FMERW1j8CnIJKmhhh1jgV6jAfVykyeV/S5Nv2vnJp7g8Rj2hRpvr9aU5dPFMXOBn1KzbXUmNBmpPtkkC3e/ge0HUsi0MP/tMu1HdD4g5hrwsIBE614jLMjsisTzhEHhDx9QlmvqCgfwiny60cTgMmDXAY9W8+Uqw9W9EC9swJcUY4kcU0Y7LtcbpF1twIb9hgKt2oOpU5t7tMTKKntdds7it7xuGEXYv6vx3qBeW0mUysMwIWBuBggr9ZnZvdcwk4Ju32A1/q5ppqf8AKIyNJQE5+l7I5R0hOpQx4T6PGuqm3fcnpTJiHKxNMgE50JVY+PMwEDXNZxNdXVs9MBlMqKU9131ghYlzKNd505zRuZnI8vophMT2SbLfMkn6dH+PuX7XRtCXPtwHJEsdQErTOkjrh43vTYoVDEWvIrvzX6amJxtnyHiOZccqnRIftu+2UuQK5VnovDHMtjDVaHgIGwu9b+qNioEgbZ0GbU3YIs32SaTeou6DRbo0ytgHuzIyNhDQVzccsQR3FtrXK+sUOQFfX76Z2xrFoP2PQB2rpeWs9gK7KxY6KSwospReU9s9oMq2kl5CyE/ikQ1u6x/TUVk5fdsv28q7a/wiljDwVPb1JkHcMouswibzl0CvGCedOMqtiZjeicHROllqkCCdT3Pw3YNeMB50uuZNxcPugH67kf5Y08UEjbkf6i7niucJXwBxYZu3WCm92gu+L0iUSfzSGVcc/0tL2elis9+6TIIPG+UEviifjnLsEkG/0dC66T5lu5kud7wOlSehcfU1LwEu0W5kesee5aUwTOO1JS9/DgBkt+kOSjWkRF7AHJMXwqFMhDL6X9g6ixH8yE0ir/v8AiJEFtTt8qubswwx4JceH/3rkt8TH8hZTqm2z9zvY29xq5TEdcDxaA/lpXjm7rLvB+3oXFv02Dc8barSEA3gWQC5Sf6cAA6CBBsjiNaC1aVesFYiLgCVt7g/aP0RHlGN/wrFR0uvgaeDtmo/LGEKKNIpMzq7aprEPuysnc7qkD/SUP464eKDDdZilq14RlnA2EPKAgVpYdoxjhp04WAuczN3g4qXRokeLitrwEWZLCcgEN7aIH2zPpOjq+UzbgNxVI78faxF8Z+EF0G9+R246mUO0TJ0dYDRuCgnjiQFrvnbSDs6+H5GarEZs12YXGlFm1hkj3h/daNQ1DCito1HHIimnyj4D05iHAM4UDuu3CuR7Aq0zaPOLYgVoIMfBDzwiUo/HTzeT9NPWkXUkCASG9waSXX3RbSZ+6wVT1KpXlj5QB6iYsqR0D+UzYuKNaqtSlmo17xW6bMNn8tSVMdfl+IWWc5yKVTQ6C6HsPWNjV5zn5PhHaxSRGZY6lnHeYCS3KCkOj7v5TCTwwrYqXUIyj7DYQPR82enFr9RoxXl/Zi0AIkQScsCfswc/0XFzZsV+qO9TQ8HCPlAF2lesivXvf4qN2nQ61drOY/r6vJ7DT9YJJ3JHHGijv+7txbarLWqUiDj0XLaWH67UrL7VyPGs1WW8ha+x5g+2n2FpXPodhUgWNMHNot2a6r14eEyytO1FvYVpoxGAHWXSrvFIde/EddYHkV2+luP4OWPCuJUQKeRQH9wasRKGYPGVW/leryBt/Et3LzuKOOHDesHqLPrQbcihvwOn4kmYi/vrgqTRcXb486fLuGkZg0/mQaarTfxTEuXXsJp/ttNPzZO+Sf7X5zcQXH1wDvSdS0iPO5fm3NL880bcOMuSZHo9frK+Meqk2qfXZ1aBlOTwPeQRyTUMN4SzGcXBkFO5me6VyJumCDZagaq/njssomiGu3hRyw5RqW9BG0fFUUAiq638S0DkBW/OPuTb4nVqBO2rfcPUlyW4bwrl+NQUxc2PLsKknOZnnUVnvxHMheF1yuvmVPSe/Jdyu6lReAIQMcJB8i31nSByr003d5Wi3WM2QBXkAEqLKoqc4JwsW1LG0T4tM53bwWv3/ycMq0v3zd7N/iE/owoRHgwmemA21fWuUDIefnYW02dPWDmaDme43u9bfKKS0PxftwtExFlcLNM6m73BmHdD7xqlzUXtVHboyZxOsTVzw1O//5O3Sz3tUvZJmCdAdu8pllj2QF6g9wkxtzQRAm2H7mWIVGhPXe9yoUEqzU28ABqP7Six3W7pEsHXMPKL3bK4VMQz1LldHm80GdChl8DozcUiZbdz8BqZEysnttaakOCO7G5kLMYZtujxTTgzPEQJPHIL89DhUCvmV0IXiZRrYCF69GA3lrYY7Y7Y6RUcuupEb3NmN/vYvWPSpJhcvNb9H7H1qhYj63joBpcSptkaEePPcrTPgd/B0crNVMckc1NTB1s4fz1EJ4C3JeHTtXeZU8Cu3lPi5XMZX6OaoL385RnublT9eHfRDuT6K3Q77THYzkobwyIzv6S0p/GG6dazgw47u6I6K7uOtQu02OwxJjCRzHoOEvAqFINpGEdxBr5KivaN81tVv/AOPuSWrzFKa7Hk4LUtrZxgfOkAFUM+fd8xY1LqFXiqcab79DRTRA253WUuz1hXceUK96STkuRJYe8BdT5gBLbvcy2k9/UTOj9kUPSfavTLLpBc5B7uehNr+CZGIYm30yW8dwtQUwAcF6F+4+82V9a21TJveU11n/aIYQsssyylSdvFjI6U69ZVg37Ao+YLV855tD04IDJxi6pvYupPu9QvAiKfh0WT8KIUxWfJqFxXIcZRvfu5wvdFHMdIStVf2y3aJ8NbCCGK1spAf90XIjJ1Vw6XbrCh97kPWwQtRR4Gtz0mO9yPtAASzT6jFpr5U0l7lwvrj57c3KJAOGuhNgYkvbaOQYjIh9rYLhQE9uRreJ5ZCNoXdfKRv3CZ9nEyYBvw5zoe8v35WJMd2P25DGCPE9ADs+eBr4MN1+iKYb0j0lE/DQDhltvhtPWhIERZ3OqAELbCWAFC2z0dtN4gZ+Q9BUbvN4NzO1pVfjS83cjCa/tyDGeWFY0hvAEddxX9wpvbgA+4lZHJgb7kvm27SHrhoPuLkFup0AR4a4fJM2MxPZR/fakTlcrI4k5HWoYK8wumZzolHuk9TkGlPdqXh2EMeOnlLwEX0wrHEWbNm8gTIcERzRGoiOZ92pZHtqY87kGqG0XnJr5GwynIwv/7OPHADRTCJh2TEAsZo+bMJTa3pvQI6wbHjexDjlpL8dw3NvOlz9xFILOvM2h4E4iBEm8eHjZXNzE8xh2gi4iWcQg/tgm1++PEgHFbkXh+Th5lsqn+v3IxjrbKNgFsSx9IijZURAyCVkucQroPqXfBUz31rYL80IHNaOOD/4dW0Lty1HuvlIT+V/FEr3Kd64mjIGLxLZaFX2eThqvBzeshbuHKcE+5QalKxk7zME7ZizBIXk8Nc5kxrA99OZ9aUg4rbs5gEF0lKh7ewBhLFIrPs6Ws25yF6+G4f8oz+Mr9QPMDyz/hQJ4gud1tvlvRiWCrfuBdhkznCVUfwStzHeIYyNIk3PgEWDEC0EEVkoldCIDfv27VitQWmNeFbqVdp/Sf98WRGPyrQGPGjnKN8v0i9M6Wk6I5+lVWF9kvyik2l8Ifb4i6FKFf1zK0Tsj7R2r/iNC48fwF6GokbWJJB50w5Y8LyqKzCDCF7Gr/YcbYT9Q05Uik//NGFIuGZeL6R1cxJO21uxg1g5+2ccCwc0WxEGUw4zChrOI50TDnpmbVkoNyoVZNy3IV0ZWlcY0nAPTRFTaIKGqXYtY5mhCDb1eMOFsHx6Gbh/BEnHq7sygktJAxgxyept4DTnMbIf2aipijq4+PpkfwKt3UI+yxpi3wKHcwukQzsFqAEb595sHgItJ9v2OKpc2NxxGctjQhS8lG1yNVfWDTJtCRvufQwKTSqeIIF4gw+P0l5dZC6jl1Gqdu/Rywx6CM30shgt9wCVryS5HicbTZ5pT0lHYbuJLS2YxP7Z48IglNg4fQUJECJYm6fjOz5eJIVLCVoMqj7SXd8LU+GJuC5hBcFfWIFe4FQbqGTnirmTH4pXPfaCCiSbidN0IDIBfh9rpD+TQR5gC+ddVGUl4mTmPTBWYUCLwWi9aVpdfV3KL1uk5nIsjIxXaRgksE7+K97DknjBmFYgwFcxcHRTevwkfLD4r6Sj+2rMaJc11HRdtqPpmvrgnsxekvoWq/PnUY2pJmrhIJASqfTeYWd0C6iCSZl6exGq/G2rDg6a5h9gdtqw29gLpkEM+fkIdhuxCAEhvv5lPXd0tE7zO+u561HGv6beryjxxKuWw+d7jMQGMZVTNtI82b6NSN8V9rI6VBnsmH0ZDBaS3PAjROJY/8tbz9ybtUo4TXSVzfkz8Y6wej1BlQ8B3RajLOKdnTA7ln128im9cveDVoejZrIGJ9HZPFYnImQGihQ8RxxlcK473v+3TxIZx5DJv+Pn0ly224k3ybpQrRjQS3OXiFl6womYiFHoG2InXBzbgsOYisvr/EW7F5vpmqWws4vVK61MDQEX4x2d9jJEp+IXtsyoYEVBl+lh4w/6qOUeIT1YP6DrDyXhLfd6sgF7L4IgIcNIXFZy9Apsz0NVrxbf5h8zCxyPdXe8/zCpdH3VYiEiYEcb/T+9IZdo9TxVhbVzJqbaUuLLsr0DWVzjfddsayZwbUgG7M214ULQna9LvWkMD7uzDBgLs97eoMTC+aA1IQfDKVxqTJidAkqqrpqqrLZVeyP6LZwVCLFsFjQv+uRmejOgZz5DAcGTVsDOtl4honr/BcD/TTG56XdjWRXNlXSP2tqRjti1LqSx5bJRp0QEpuU9FhuqAfx2MbiLXvnIULxNUFREoWpe7jzYPog4FjE4cP/Bjk/SVeFeAXvilfvDhFoinpn2pB6dtE+mRY2tBZNqp3BW0X4T56OAgA8juzPGLx29cNlIhMnRxjrwLFi7o4v4gjCu4jmsRR18U36tRl98jNh6haVN/n/HL+mcet6BMQhXUHPaniyDDE5n4vA8oQoWrQVfj7yxGg8R7d5B7R+u9/GjdESRltOvXMysm7Sn9MZpPOH4cCGsteDqlLJ3bXzft7uvwJ6QBCQhhNRlCZJwamhrnHtL1KCyEzo350u3cRhhht53mnP7hTfzlB8k9P2J6kQfvPW+VOqFY2agp383nvzLpjCaObs6jQpAtzt71ylyAyrNxH4D9s1N3Tzr9a/YaghiPgWu4Ptd3/O0bu/+ADRYFsJ5xJ25Fpyz3brk46fMZPkX3gZMssi7xSV9BKrQk/2SWTOQgbAVDiTojyHEeuRajVc1+aRqErXBZNwM4jaLmQQKHwXHxGwDgTMkz2AL4pIX2490xFLvo62je8JSzcbV65NmHjXYoTLaJ5UBrBP5qDLvVOYrmfcjXbhHu++7Qmp/aJIsgIpVd3IfEPdQ0CwvE4bIbsehVEXPgaPmsg/VBt5AS7+qfjZwZHmfgHlvn5wfx0bAYi/CPD6ogpjP2hD9g7zl577wfKX09Vghzqw6IjCMzEfbmu6a515jC0LvQYEAwMFbOSydW+1sDk0AAmHaprcYcgYqxNztYCymOSY1EIP3OlQo+gqk39O+Rs2MkJctOi1/1afFqWPRLik9YqWPkHdM5dSwOHmIUbXFocgo1nKaazaTdcgY2rO8Yy0pPECwnh1oQ0nlIAKxc1a0EwWbIlbKQKRaw5wp9Qtdg1G2iLKzvvNPJ4o5AroNb3NyOUMhYoC7IseKKbXwjF2IgqyVy1d/FSMTvHd8Nvfjg776WLmY9aot65B/mCUHrrJcvu7Y8I6kenrKl+OP8HwlAoLtYXVct42o52Lq+X9UPAWPDHLf5ToFf4HfEeX/oHNGv2YPOJvf2D1tPzlxUxEkA1D26b8bdy983ta6Min+SRhM9m9nqdYWg2iyZUIGZP8wqoJ523thnEzOqDZjiYRaoJT9ztYNtLUdkFpYdAczPt8T+lCFYKEXfdDPYJqTIbCN0YwY+I2SQ/4L2egBTf4cvs9F+bKTMIUU/JoUia3FIXcTTv1jl1IzQmVxSEB9s/eXjDVCsM4Eb5GTZDoDLVTFUfPLrJKJ8m8VjLtDbr6ldX63a6m6CTRJR9WNK7EdyzMZyGtBuBqh6FRkSaMV54WeGM2PwcvQ9oom6a/qLR1PT7VrIHcT9/+6svg57fUXHRvgZBkzOPAUO3Cqm4w48k5KBAZnqIm6vBlixrKoncV5PrCMSeF0irFzvUyFhFNFmGW0gkmT+vF5Y2Q3k4VFoppC1RG8IAbLU3xOuazlsN9oDkOA4oReacDIVl5SFwS7HQME+N9gzsFZD7N4YdVXe680Ji5rWpV/29nziuoEUquq/8Zm0HWTvKNTxKdR3hJRzu83GUbZy6cuuiEBiXIIhhUbKAQjJ3RBMGBJizIsUiOau0qRwE8EF0K0wvu9n5C0ECk50gKMZ/qsOD/lqMY8muY+9dAMdTzSACyvxIhsLlz4Fmw4uwCeygk5LYI64Nqd5XvbLgH5s97qxUgYuFsSjdme0Cx5a6MpftjrfHcbHN1BpGJGir2a5g1Uf52lb3M+ZwS7K3ePO1CyeORSVwnkS6waqewkIjCNYECNIp0xLXFk0A5uxWxoIfHwvSnrPibe/cL+VLSNjydUESQQk1OqVewBXkwm9EIWi6BFgrMNBeqg79mP4mkEJZjRTYEuOTa3pfy8JHrJ/wvYe23Rd+ArX9njfbLJSgksI2tr4f7jQgydZn+7kHGrb1WppsjIIQln+k2CmeGSpyy1jGf/a4UaVvIoINzxF5JTqSp6SCMi1PqRfOk0hAk4/nFXNtuE5YkE6ExxFt8PmM7OuUiWZdYauKMkTlHsL9yGBpCBPwZY6TAegFjjNDlkWQSLrf0/bMc4ICyjiWzMkYUUkvObJzAOx5E7DP1hiNT2XJBIDLqRAaD8Zohms5H4esCGxIcfxySEmQ2dMO4+DGE8vazNLN3u7bAYsClzKv+P3FVtTxURaJxLlB5sGT/xOPljJXQIc9wdg8WN9OZArb7JsY11GVGw13Epuy75SGV9honUzCYTZcT1RFabIzZCshk0ALMc1kKGAFq0m7gGIQYpmPTb/zPXX/DrGqYOY3FWPTgZOBPbmX/3ZCs/C3ZtvdIqm5D3zs0B63lNt7TgNnIGbqj5lw/+i/4CfuXSY4UqRdLI3SCFhDcQxz0H1Z8r55/PYbSipNtKEoiX7yl1fR5FEtjtcKQfze8qVk7WbBsESY8GSmB0ftynKjQQFzIUv0zUcB4hUuCtKDLwV8w9r0rfRyV3L50Mf1ZSah3299j4zPKI7NX9w7WAqSYpdprQWx0WYSGYhnJFmO3GImcyMO8X5oz6d1tmclyO02cQ/8WuTVTOxclVKZumAqzYxJ+4mOKkVncJ4Mb3+GwYXND1vx8Gno+FdIgfBOzzL6WAj4pqZoNthHyHhLvyQS+x6XBNXTMFxoEBEiLszfQ6lRof5noZ72gAeFnnSSl7vxNEbvaso99jd4ygIWot1uR6CKBuerOf4it0SpoGvlSUaa5QEgm0XdSaPsYII3jptFmB2fynfz+LRIVBIBWhiYAEcDXQooU8F9M8PGEHiKqWwrGgjgg7SJs6XPeKsLxGPvwXi1z5xHEZeCcXt9SjuFPOLmhNU6qVMd1L25S49QdQ+k93H0S7a6GMhDQ5DyDoOCwi2SesydEmynMDfFkZ8uc3AlPFboOvLpTJHrNP8X8zlYJdMAaiUlwoSur5wxAyYdFdJVD52Eo2YxarYB5+0UdVkc3yoDA3R4s5Hh/+ojhkA7KyKsW2OS1waKcKyrpqWexCzgO4W2kO+QYCuwkwpawXUbUEh4K4rv1ri+yI/pu2FjfN5yxS6KNU0CuKBDxtxny7VMp/h1q3+xoFYm59WOKPUmvsBXk/S4IP6OuhRtQVPBsn9nw8NqLsJ7V7z6UAJAapX2eYj7wvQWKsPpdNO0yjojQI0tJbm5ugeQmdnwcg/6N1zesvCAh/zWvX2AA1n8OxBF5Xfe2byCqOrWVOjjfq8ofMZ9/FTiBh16mWaV55+j1sYLQdfg7SBTJnjOpSx0qSHlh0NKUmMneW4E1YRZ8mKt40JLdTN1vWrxB/l+Ap1HqTmIp5rwYdfBEQOVhZ3rM/xkUso1cXG8Zbm5P2+VuDdjO6TaQzn7E2jnJXbbyoxjt77E9HBu8itvs9QbnjgFWvd1RrYPpcME55qVEbIoJo2sE0mM22SVMgTdJopJwJjv29VyWDIAi6nESWCn/cQ5eUesW6NRx871nX3aj0vYb3zBwmW7qegaoqx5FVP9/aCC/0TiAslOoKPnfzWKkJPWXyEQKFETTh+oVHH7jv2pPeh1VrO6Gbkn4UBD+ODwq3beW5XzZz0arY+nqddAUoM9qAmnH0uCG0VJnEU3NBQJzpTAnMK/ACepuYrnl5DbJzogXWZa3AbdVKmuFAKajepspxajO2drD2J/+rDhmAOKDc5O66L4OQwViKdrPi0sjajVVedpWxw96syOGQo72au9s6gGckNr1h7/IEZax/6dFeWMgkl7ClerTAvsBAv25k/Z6uSe7JTTeAqxAT+CQYgqfHAsztWnpD6sM/UIoAqaMvVIBJz+vzdBVRQdO7GPOWwnwTr6lOtZ44FYlWy//nSNzwU7Z+XtH6g+Aaj19JFxGP+uKaxr61uNOlu1EmFCp8BKVs61sarm+3YmFLrk+XW8PNWft2EQNWjtTLWKk1enx+y6YbQoCnFzz4MtfxiumoLIDcBvFZY6+yEs3Dn1IGTM+2+Ucm192P9AQHsRxyaHtwFgdp8LiwrHe5P8wXS2ueosKkQjfZBlgv25XYHipPDfIT0vQ6UJaC84uT4g+ElyAWVAdfZpHd+raHNwc4jxvhFluNGSXrmNfoGrZQiMRhj9fyb6oLvtKU89YMZP7W2oDn7jgO2/4kzbVvSMzYG1Iju/ElqvcFpnPwrSiWp8OIz4HvprPl4ewnpdUAqT/JiGZfCLWLoBH5HQBl8b0dK+6+JBwwQEVtRWxbaU6v7Sik/VHZM+W8kFSN5IyASCZqmwgxnBY5Q1elS9U6j3g+1WfwWArOAWy2Bg1cxkx7r/NwWEDgjzgwD3QGc6nYX2UXNM7TGk2ZIanp0emzQ0wbyPRlHD3KS9sPzu116wkxUB9Pgw7FrugHuW9G0RVln05lChecjpZ4yvRpyzsGX+YVmiOIS9kYmtvyHJF+BmKQvP7dN7ZIbOXyZT2BiiCOsO6A7ygUtkLxFB6x5wCsFSU5FQJ1ntlt6Alp64CRqRrGAyVW08XdIKfM3YdFoZBs1Kchq8jJPaYMY/Z3ozmUKJGPqiWac3KIbEfbeDapPdRlOaYKLlmG7feUPJsPXNOLhjODY3OKJReZneHL6Fg1jR4BSL4a4a0aWRIe9yD2zgLGRwEHLo50x67lkErRCjbhmrVBjgrL/GXfj7mCc7Nf3la1u/bGuXcsolDAk2rW3gDtju/LR5DbJEmAXXy76wpaJlrHSZguJyPD7finjlyfRxJ/ZoQwS9aypnja659bvJzxalmC5ZiQABan/qDVX8RfT+yvCDPb98Gw0Qp3RuPozyEWSGFEYNsn4zI4uJxSMEPnrUzKt9uQzlQGYTXf3vJsEuLWJjDAfxo6WNQ1/OVIEzHrB6nqbhMrzc/oKwW5aZQqsPFCCWS9Nk75SfV/mU6N2NMJ/a+ZHOIO2g0fTCaxwifc8LdlkTV6qhkI8wRNIFq5R7f2yFx94YUPuNNCgE6pAml8WHwrdzBwlXzG9MaT9RhDGFbpdMbQmCrzcg638NdvypiDDuNu9OQNE+qSkb4wDUtVXRvV+/v9isOsVcY6podfyEzcTej1lKtfQICM7WtRrgD46EYQ2E60JaDouGh4F11dDfT3/DnUkiKbc58OlbpBzaYdAcjfjbRGcfvagjpPceIEp7MEV4cMQVaz++0jRzZ7U+qpebxNrfHQEvLmweBmreNBvzKq72/C3cb3AJbdUBKqxtPMKWDNxaAxOJeHv82b4qpv0Yw3QbCaOnvJAPtZMcxai07ylnXGgyL9xPCAS3To5GKaywrhim0iL9k0d0/g4zFdID4g37PR96E93evjUCFEe/M48kLLxhhT/Co0rGXDrUsJgUxSuIUeJQlsOnz41tTzj4+Rc+dFK1e/uwUPuDTpZcX7SIdJ08SMUVxWtpGJdCgovf3D6dWs5+fyfNNduiVLXsRfpZxNLyzb6JmR+kPiPjVnkYnqRwoSBgjkEIOvLsZF+n60xXkRSNmty0wuaU3tlyMCj8yX6zsdILeR/pUwT1TR0/M4uFGeL2CQXzUQhl+t5b0S8xziawea3Puqgkx2B3JCVUHKdL4nUqo0VvAt0FJvfA4orv7eYT9nNSiPxmifisuVQQmX84LbtUMKjzXowbJ3cgbwubZrgEyQAzd+u0IiIkLA8wSYtUb772KeHz6lFXp7rkacV/7xMdJ8SPoIKgYRDqZiAvTgnen4DTbX+ge6l3p+l9Rgn0rU/X6DnGX4LIEDAurS//vY+/Ir8zfNvmxQXVZ0cThLp+DknK9QC5EKkraThmXk5Q2W5Kek8skY1hhpZV/3sDPltC5bfFi7Wcwr+JydT9zsPKGoHPceIZ1Lk8r1+Dlk/8CE/DAWiKrrA4JTRg6uMNSMIr2H5QZu+P20x1/35tan+UmtKxKHP8iiQ/GsLoWbfU53j5hSoGThGCXu2fjka0wN4OdtRVTRpwXHkxJZHhQEa3Y80JaTu+HiA8N6Pe4tutiz47beXMrxNBPthMk+5L/CIHTyti9dj1vTdiAdNHKa0CnOuY7Z+fSK3Gci0FpS1eBpyPqJablpSGKCk7v4VGKarD9qw1ULNd2qJYylVU1UK9xrvTNEWWGO8um/dS5CoRidLrKx//15dtBmTzMaUBLgOsIe+MAH811+p4srlKVUOgVy6r/0vS4qdO4rMg8nY4adS2U2d2bHooHMprZ5+8G58t6rPydYXAEJfTMeE2fPojirf13yvBZBRlN2Lrl93sLjUPny/+zsRwldyVe/bZa9SY6RMDtBgpuZuSneTfY8Qvb1e+hc9WZMftnO10TpLoMFqPnkB8LsCPkff9OU2Ro4OPde92Tv8/5Z4d1mUwPIWMhbotgEo6/E1+zz6nd469HZ1BD4d3aNAAMTpWEkhqWkOgddNgarVoOCSKRU3uG1f0fRISsc4VpOfZAiCDM5o9L8yzgkObDzdALxeqXGIHq7xBfBEblWviUBUmrymE6lZEjDcRO6I3jglxXVDXyVF78+nVJdOIpmyrcXr8yH5e9xS49kRV2+3gUdlYRFHHK9Ua3YRweUrjAR6ClGyTw2KSk4fVz7T9jCZ1ASP3ZHFfv07xuIB9i4nD936MjbqajEtVUqDfaaZzPKn63O53NLBqwHHYrDGZ/V/ZaIOaT7ZgPK17Sb1IuMd3CsP6z6k3H3lIoJgwgAkZW4mwL7I59kBoWnxbROpPCcAS64PBjSorm2iD3+Ex6mgx8w7EnX8T2f2lLIb10e1vw1po9ZKUUczHnOAsKmZq4Xg/tp/jE4cXtjKul0NLlVyYslebpxGHWtGEtws1qfMFxIdyX2hMkdYvQu24WNNFp7sDBjUEWvOm4VVxQk/ztFna497KaUuD0VZyfx25sr0SR4kIZ17NXGFGEixavZRMKUaezzG3FWcA1xjGwu5N7tLwaNT19lGmWihYMi/Ib9gJb6u+eQlPTD1GjAFVRiWPYHvdyQU10LZUhDRYk9X+mi9mFpYSw8RH9eXaxCWcgxSNyi0uvq9yoor3njVMGJH4Ye/yKJMP5WgmVbjW+tbSMvei4fS9X56pd6VV/kAm8AlwGE/TbBNLhNQT/VhipLtJY6RVWLneWvl4F+xFi83BvgLG/NSIcxidwThJugb2l14IomniggXmamWgowjd8y6z4JtTseGT0PPlmrbWYlOiBxGZGFI5RjqahEMuHsCQoT3Y1mUPQu5HtidHn3iHZNVZf3rfPW/hQFC5tkiJDECRvjuTcj5EtOdUxZcqWJiohkO0i0xNfo9hByz6RtW00zvZ+c+pL98hJTwQu9aLXEVMG5Libaj2xTx212NdW5joFW3Swindal5ygGWAOOKdQX1UXmrz49b+Jw0sm6PEaan96k6QyWsDP5IkjJhNhIBc1/0j3mTPtkhRFpdddM9EO9nzZSMv9AkHZn/gHgHn7zrVB+y9Ux5+q/JG7hpj1fuUbzLWLN/JAfl7seMNWzHIIuavnsb5GERaB00eiCopRLJ1MBdkjuqfjLCzQ0wydFK0nVfovVF+D1IsdCiUsWH39xIRB0iA3obfGfokxqQXK/rdhAl2MBftyzcWIFrQcj2iNwMi2vJon08vJjbyJdQ4MA8fEaNB0K0KdyfadoA3j7anKszTmnSWFBtaoEYiPOIW3mELyIv8fJTQxcQDUWlglQUUT2wRoPRi+FnT48RCpAGZmmKZm0mEJWpUdW6NMCEBNYe0LbJ05Byel2uTLCvy7Gl+5ybwDkX7I2Yg5SfgUuYr4UF3dzMcsSNPHEpf3ZsjBhhLTChL6iYIQq+/y7TVRCrPogh3EFipXAJc7NfAjYiD2SH10fhORbDvqSTRyHUhcAgHb34TjkW0DTo+l+E+aceR9HkeLMNRoR7xMcqEpJW0h6DrNBAaK7PK/TF/6cDNyDDHtAMYn4JomY/tMKPKcWrcnLpzZFGwPmAshLLW1pwxL47P4uaPRNA6q+JT+wVKt+BAPDrzY8w5fAzEJxj6MBYgd/fZE5m6WvsqeD7ZyKKoGpzXimpk3Lnfm8Wamf5XaWe9wVpdWzmJdFAWhp6Noj2I6T1Ehj0DV8ZcUztkO+vtpg/ImUIkKVbxTtGb+/DNW/HfgTFXSaEacy1uUYjKafKbt+93LzFFW4vPbP8Qpmw0FKZUQHfsroi0fGdbI/1ZCtPPfMS0HoMb6nZiJ7aOkx57U6VL5LoaGEiD1s5Xc9lqXbNy/2OfjRXilotM3M9KXqyT9jOPdB+ugZvlxlDVidLRsHP7xjFdTTeiBV59+nNkh1jMEnnaZ9u13g+xKAWlpkOxyvVTfxprKu1YdX5zPdqBUCNN1Io3odm0uMi6C1H9b/5yOWtvDw0d3zkJ/irgLPT9R+UqiJpyGgx3XzgRClOH8BKJpRbolsP4/+Qj8R+bVii1HHsoCm1IVBkr17CFVJP0b+45XVazUExUEaKoIp54u0z1UmyzuBFiooxpdx0YdPFk//WQWB45XYJMuYmGgyjqcEStsPUlwOyazAJmy2G34iCMv2uRfoQb0/C77G84M5L0kJhU3ItmnUFM8zCSlrXv5qbnereCCBABOcCh0e01mKH7pm+EAEqPWCqAr/C7Tq2LcTS1xkuwWtwL8yDiN9OegePn8cXEopcmJDJccXw7kXPpTMg0g3J1CliAPGFQYqpE72PtkMLjPbPSC8NLC19ZPDXw3m7qDuFKogy57BsMSHtMC2B13cECv8tJ1gMsJVhiK84IkXk0lZ81FVFswGH7zv+R59nnyL6kyZksjC8h0uwf86LhKPhuUMXA8xQm+pqA/HuLtVTFaNqwPn97EKmeYQ+5K/xu0BltGTYw0c1iROmoQxIK3OX1NkyPVo03UnS6okGijRq7xPCGZ/31j5uzdW+MsjIQc1S7uBrorY+XUvzqzjrlwVE9SoEXllKveeI63gocJHa1gpb6LTx/1D+E3F/v8MlEJpBmGgrhqp3eDrr6KbbnScxkZyilAe/DLFAg4yTqODLD+6y5HOJPLnVCPASKmANgcLXPuKox3QS7hf02c+kL3hW803iMclogUdRwiFiZEcPxhOW8EK4Feo/ImYm9AlxRq3Cajk4ipayZ8w5Lkj/r7Dafu3nNPMZX/STc3OAxIQTbOxDlL6LtH6wKuPMvNNcJyVKEbdcYkNChPAob5DhtSwa77Sf74StEXLsurBf2gbaoq7hnuWBnCeZdduhEajEHQwuHY2gvD3xr8c2LvTWx/LZjSqFxXFK/AQm6JYY6X8h45lcP3eHdyQKqMxwHcL0tkR7Gql5k1BwTcdjvbcaFtyLxvSqLZRl+Hf4Dxr96fcD3j8rCFtPDLKzGgdoUXwZsVDbpVwRy4/BsNEuO17E/XGnuYmSeQy1zxEF/V6w+ywL8nbrIEo/j8jURzWxsxCpWNe8jzwPeYsTuJh1Z6i453nfNxX6ZNc7naWkxliqgJSpn56qYfh2Essn8jjp3TYY6BGBiZHMxf+RI8iyjATJc5xm1i/22ArE8OE1vYTYswa7wrkiaIHn3vu9ijg1SPYhvrECMITO/24vT4sRXYwwNusAw2ohIyBa77MwRSqefH53gVqXdAY/b/5t6lOkpha7WsIb/0eXhYb/VhrG4poreF5KmL5ZJouWN+ibmg1KftTUUARsjmynizkiLCCorc13ghVn3OyBVtghjLg1pId/GxJfhomGa8kQxpaSVXyqTAmrMQkhKNeiRQnXko1l+HK4sb8dgShIKewUD672omdlJA6cV10/Sk9uNQpp8xtatomobit7d9ZFau2V4gAuCw9dHRobO4nAuKrKhie1jKPcgHkF6BqNPVu2uMJV2ivP3lgHiy0StSisckgBkV0rk0TVHmQI1qsOCV/7vyvMn2MMmqxd25bd2oCz2rIOeHIg4T7CUrQ4OsLRcV6guQMf2hWmXawPgTkhXxc0A3W27P8JdwNdVjuFECbrDKkfrR4GeCT7Qpwx5RB9GIjar+iZAizympDdGI1h9ngYkUvoIytUyvhFJUC1Nh46TWb4dZJOK00Nh4O6XibjqtMzH50ldJNT5mj9oRTNFSlf/auAPlnbvDdRGExhun4ZstKacl4/g1utWhrh05bQIFuYUxvjD2VkPlV1TZA5HUT1YJIrwygDB3EK++YJppy9t1/zHQl+CWipEcdNiVGrEP6kg2Agsa2h6OYpTqARCbeqvmPjhyc7TI6wvtBMxtuXDNVOwa8q9AY9NbbN1UkRTfTcmkazPHV23k18qokSsfBcvq9LVOEcTUDdG/NpkDISddtQL3Ae5y+thUnqkQjJq6qvlzFs7SwypZEIdYZ7ZCpbMG7uidCjVWmfcCHt08ZMdWM4Ir0xQtXGVdAdo2yqq0obkys+729ywh30IsD67WBM56JZKMI7FSDqH4UGmyFDSFlVcORleka4PAS4MqtdURdf9394Kw1nR58DofwvwS+BWe4tMuLDo6c/4/cYeKY/hUzEPUfCxZRfLRFfV2YtbnxlryuZRJJDL5+FeCC3zqaaFfWeylms1RN75eZtIJv40JAcCfG8g9Rvb5Bj0ftw37NC+ZybG103EeuQvj2ZoyyG4WUD16e8KA6a1F5oXzbHlv97g7mOJixDrQLFVhRrhR5AVv8gEPznZ9m7AY64AGRSvwBoqMCQbra39A6kVGdkJ0/cuEYINEY3AO++lR91/5ZKCVdckM+6CJ4+oEVe8T3bqZtBjMa6X7+kNJXUHvRho2SmeqVOIl118/2+/H4RhQNhltQKcT2Qeu8oui/EqDuEeOAd+2sNQY0ki8U8Aq3gjlnjyVoRRvTV6LQRqGETHD6tVN0HBfdo4/1EqdoonFe3oUHgA2vTORVCkwA59ncQfBIqu9NJFEwWLAM/KmrG5OOWRCPLA+ZmxTLJ3af4+lfRawFsMqSw686QRDqAisJEWvf4sU1byEjY3NuhsMb0mXlZzQvc8ZeUfyaXQauxGamexndM2lM7mMpOomwJ2nZW6Hb2zsXYlsv8jGY9s/UjF6b0+Vylt5jefYtmJ870pc9UltTnpUmHBxKByPpE94ULiweYR5IH+w5CzXWPQQLEUuhBHloeDEdtCgUkyQM8g6/JSjm+6+63Rgf+F/6wWIAItyAASEr649jDD7ieUZu9gl3QVcMvWDJsTTCpS70QMX704C1W/m1VmZyh1+EsjZOgPPGqa6bx5vQy1LzDdWdE182DWWf+AWGNm7HUiAiF66Uvp3ZRpr7LuGKGjl3AidV9SLsTcqZmF3em5BRA0IK3svZBY3fQhFJRrx7/o/uXAsY+DAuIbW9UqJoPaaTLjvkrcsc4GokeZjFk3w2ThRDffLj9Rm7vgD7MA7ALAMtrXxS2KjD+Qow/AVk/CuYvbIgGHJmm3clitsNvby2KHy3dWXiJ2UQhUMEEhvVRN3PscUlhKOV1LLGQUwmcYM/LNVMQVJpiEPcNxqDrtSaXnJ70OvNDw37XvhjOF0apZ7I1mvy8Dkz6CuHoMiQRSD/zHbo2mk/GHezwaevkgHWnWx/GndnH1qBZjPPrYZnRsODA+WBNNr4vQvZqXbyOjmGl26vja60Kq/bmP4zr0dZloDsRib07kABgzTaYX2eG767xEQ8S67+fMxCaUDzc59hOVBIPbkRseH51Iua1QIs97eB5Tbi71eNeJYZ6jnXWvvNqpDi6h3l0Iwg00fZc5vd4W4NZZjjJEqFSUcL6VYNztKwF72XkcMhZ15loobp1QC4jKTzHG+auv9PueMqyo/D0OU4RcGOY0SJM5qlYHBe+2igXbeBqYG0aiW/5IJXcqRutSXdyiyyHZqXRTxtc1IO0/kd/0gBSolRWuffDFFlvQy6p3/s/sGOsLz2BShlmdgEwowBAWw6hbXTajHSyEY+PzeuIJ4hPmNwOzF20gWplYayxsBegHV8towXGco5VHTZvBQsDfGKG1KwG6VXLpLALWWUdoOo+oGH+vHTZ8/2h4Jys7kO75VK8GspEoYsSVD6du+EpEs0U28L3e5sX+QeWyZKYh/VrNPEUVAbTWKC9kLPjSmNPQNanIb2gQH+gkvzKQSAudoYMC29dxuu5bAH8O7CebdTHmB2KoVgLSdl4nwC9jJ7QaEeZy5YFMWfC4rHHPdSxgBZ6ygcvPgrfo2M3nC3gmIB4oXPeElMHLUNKiV1Prw3GFmya1IV35pUbEXzpz/DNeXvvPzP65UFjW+JmXSQhKenJCV7ZWDIJuRD/TKItdx3l4uT4aseXzAkGRaOHZgwKQpACY3W0ebIx66ywprRgjfQPJk88fsrhm9fZq8/LGp2N+WUpiwMa+dCi3CoOScGWZdswVQME8zLxwdvdW/D8GAAjETP1pIP6qyoTGQQrtRbs1BpaRQ1glUS0JcC26hFvF7QREKll6vWmdK+BKzs0J9TZvdjXPND0cn1La2lNRvAEFiE4Ed5+W8AIRt7yf5qWJ60NSD7b7WSMdr8TcE7caxffVAjpxaZWAk/xI9GPDwfVeQ+o1hK2r6lanp/wJ77MYS4rd8hZEyGZg0h1wrVYp5n6QNn7woCCeIZsjL7SBwAvZSZQTIRCJfpSJJQoGYZuDfDAapAmjzi4HMLW3Brq8vw60BV1myri88c5WZ8EbMzfhKYpTtXnep5Q9OE1gUP2dRB/gHXQNIXY+Gj/BHdDh0r10Gut/4wbqMYOvZ4zAdSWbjENB+M2w0tT93G7+wII8EvB401XQw5OkTgGLvUr8tHWKxcMu67b6gDdxTascVn7ejTcwj03nZcY4kssERxicvrArL/FkN5vqgqLlCTxFKIfZHacuWgKm7bQDs4F9chNZas4FcIXM6I0WJZou4Zea3tsmyP1YO3MyOmApuJfAVNEPpmQnFnMjwoYNoRVeUALvzoI+YDcNMsgmy5p9nXlVSn4emjoxBJvGW3qdPsWIF5OhlOC7t3ib4JYl5YjM+C7GkN9y6zq2gNV/QQpX3jpAsz15v/lC3iAKNWGitiymMBpTAfugE1/PH8v/Yn4Yrxya9+KwgD01xm7OuXreQ2pmPw7RrJln7lRkS4awUBg8sPdJCvqXH6NsZRe0++kLr/p2zfxma32pzCQzihRD7FNE+HmRtkN7nE/2AqJ0gLXr3ityb8t5SAXG4I2rL0FO3QRNDtmualxVfb0WDMLue3EFGyk2JZDb3XC8ehkYPBWqVz4XUqmNrJgiuCu9+B1lksXKgExgVqQNaqcgC1nxewk+mb29E+cy91sSU1lGnCb/yCtNg/+9t54Eu+Tz22PZ1Lt9+SXZOtg67gjnu4wY0UZd96j8vs2fvLYtWgu/A79REn5MEw8jM3zwUTeEksFCZOG3xXfmI2irROl0C+pV0zYLeiVdybQgsLEyWa1+gqgD9TTlWV1Gd2ys8rZh+pguOeAe7deDH/JG+ZUjUjROinV23kDvdTt0jNuQNaWdLRhLcEo3a5CakxYcpI4NpCyq8jx08QkYzqIezcDY9vTSRUFqTT4AsZrPRqponhjR+aOIAl9fwCJZkQA+dah7j7QZvQ+cad8p9IORG6Vl+0gJl56UOGw3vqn/87a8RlFb5w4/i9vQr5JXbK5Likm8Vjv6TtUmDKopVvTEk+ebvBFTI+v6MH0XtKDtFewUVi7un6LJLIl3JpSVmF308KmLjeIHcMGRNkO7bv972g1hG9IEk9ypoz8GSapR4WpJx2pGDbrMlg+XP4TYzAZy7x74K3z30dT/DqFIgHhXMQ3Tu0kDXE147crAVrHHkQb2DEAxqcKC/LPSDcTQZkLuMGQkYONMP772egr5ryIeQb6NPgivpcXMZclUu+4L+AuO5+6QVrDSSKBAn6eYsfFQmm/WtzKt9NEN05xVEUIwZn+pqqEu0bMcus6xlSCIhmQHGsIi2eSIBJ+kykou+Ag1kPqppZ8o76HYJ3D6uVuBEygWM1V9lLx6kukUR1tLcvLjmUPVLtGbR3VeWSQFxbjvSbKyPY8sPoeMHIyp/2h6v2xfm2hObup8+8KI0X/8/MRFHLeUr4K1EYSGWawsHAkkaS2Niu8Z91bs4Lv8pQ6fMSs3pZRtA99A/qZr7+NOOsSTJNzthmDPTnNv/uA+DzMDu1r4cI+8KSQT8y+AJfS8V/9gKYvaeRPVhxQyK/lbukL4pvEC76/z466HH0zEW66pGftM/r2XQnLcgjbmcHRFBrDsnpzCOyiN5TXiK1XcvIMLujgBRab7ImDwTv3V/pBu9dngfmnU9wWir9hY/MQkMZQPm3RjH2QgGgBp5smIN6hlr98AReAf9WKoyYzOhIaNKmszl0UrJx0w/CUoSJXNieLisnosZcQl1ohKd9c7faCnjCdhZVev0MBJy12mbN0FbJfXMUjq4my2WlPeeB20Gcqo4Y9umpurRx3EwJpITYp7qlDP23ElVn3p8tgLroX9diaJH2djjfgaMmpUo8UQFG/cgY+1SoLfsdQONQHsJgQ2Uvi1XFn+w5bwF6zhXiZ9uoWhQ97T3AqatVkwaJR/iDvXYDQx+0nk8U7YUBnvvjYGpuuTx/WfPLDK3UN3npJzvei2TpnXBnyr0hWojheDQR3keNXe0a3rAeV69aDGDYBZpDBNHq4v8IsjDkW+TDcuH+k1xgAgPqq6FWOptpZQAoMybvvsvvYadCMy/0K2Kr04ta+WnuEXK+4tl4v3U/7KPng81Q+7YXB1JNmw2J9nRpwUCv1IsNu8YMyBiz9ICdgBwhyZ5HGTAaJikJGvmgzXeZC95LfNcjp1d/tOiJsI1PL69njnGmBgqfTNcr4zH+2cuSH1D/pInLywQyeH1gEo2yZdSa4/MqT8W7QELFgOUL6P1E8JyFVlDkiuei0BLVxyophGlg8r/Xv3RinLXwHPasbQ1nmt17St9glEfy6nEhmMBZuHXA4MA4HbNSo4T0lqyMtQCxwN0herUtYZ3ZJTgqNk8JW6K643xa/JUH6050RT+BhZHaMUiCwT8l8priwgpOgkvDJ/dmbv7Hf+O3w3hMjEzWZjL+cNbuj/bZZ/bgpRfCrxNSXLBPdp8k0zZWIkCfFjlksVBfYzWLWkgiTYwmw8jv0Y0ZJB7X+P+nzuayqb7+qHq8BJkZsA1yhLeXxyayI3EVWoYswWB9gjHwXYcgoGOjNd+RI+AF+9pYZqZ8mPK7qgN4WFxa96suIW6+eP6ia6OVHkm7z8Dz437M1q0hE5uZ7VUM5gyekyKwJruj+YlxON26Yw7Xe5bp42H/IFzhDe+Ak9a4Cke0sPJPxaZd2JlqqtAX4XtMitMTHVTAtA24J4LsC35O4ChLi2u9YeZaGfxQWafput8kHzmMem+Yo+7aPWmz/cpx1wAiAd9vBSiEPSg3eW5Sb/GgOSujgTvEB+b2d8gg5sR7WTLqOdZWwNQ5r9BJaegJiqXsU1gEZGm/qGb84NZ8x9L8VeAI1Mvkh1dU/Qe0BSJ6NkYdBFfHQ+yy1E48/tIJEzcikdkqdnLTr1O+kVebxcrytPVuq2gXOyhuoB7PDj1biQ8v/+rPN8nSbyp8oECGrHR744VEWe5qX6Jmsm9T4LAtinfUU5g/jtYsVqEexYsmYdLfm1M8D4SNYKjUnOFxPHjQi7239aoWlBrmf9lOHWJBXJ22O79Ts/6czEI+Cy242vDSj5WRW6rXPUQtMoA5GvCMsq3pu6yoR5BTrcqan9VgotKOksb26ee2wrqsCKZGOjmKe/3ZS29U3nBKOHTiP/yFjAMk34Pp5Eaapxf7PkL0ywTemFyn6L++j0BYmwVIBanyRlAb3+izaX1/FwGHdQhYu5hLGJhs4zP4XeIeeML5kk2bWpj70aLm9iV9KcwQLKLDzkHDMPeJYK3RkH3brnF59QTVkv6ppNuB3qhRY7Iws5o1Cjub8ILkjvm44FC0UbWWk0njR+wKnsc/AIMVkmREiZsK0f2Cp4iWDvyCzwJ6+YrAe1PfTfq9+rSo8Cc9uBcH10LBnRSLQ3UJUESeBaDPC7By6N7BG/5/dHTrZa1jx4QrE9fVZGV/z6wa5soqPYxKpof5y7d9arAvsMsGdGBuv6U9TwKAfOEDJJtp+OVI6EXK2Th5iz3UeT8hh9sdIHehpOmtV0J2FEViyf1pGBzqdqhJrLSpnJ8obDehlR4AgiX/7/vztlHkaZxxoQcKJaGbwRxoCDSnlAizUuBaCJZMlH1J5qgar3/gysOKc29M+ai8TBXQF3pLnfT6kaRC/qoInAtQERUkdEhvzlxtY14HG8usOFnaDMK8NhGsqDQD1fP+UZNDp3yMNFZ7w31TOQkWrNKGKLo1MERHLoGBtLNCfk4kpLPA0ZOz6os8EPpSjXKKZ9ZOZTOOtro9cqZyso5+iiHoXM69j95u7EiVr3D3Xzem6P9F0ffDTPWYFTePvZ17Jolqu+hmA/f/Rase/zSn2/t9hprfvIsjvSz2/fHfu0vXRSDCbka3Tx5EImY5cm9+M7k5EMSsePEoAufPIVCgOPJJGyUNuB46nvQ+1cTlWpibO0TVTmlFNjBDWNNj0shocPr7vth+Kix+PIlkYiXObnvsOVJDLKvFM3ClwIhcKhDZttRhGojl3utPlZ3gXx+briR2tEvWS3mCQib7PEz+qTVFl1JlZmzQDx0DhQ8i1KlEkjn/4m+K1VLPIpDTmNJ9o36Esyh5r6SLuj//FOMs+9VPY1BcyOyWLiRJ0u8TTwZ20ZZhuGTpHwjB9B3Rgyi16y1W+CbZoUVF2D02ywUXsZfdi+se1KPMOUDLQN7sCssyzveSceW9aoZtZwyLErZ6L/ixBoZfb+cF3Yl5DzqcGn5F3z8+OLAJE6VX/mrEFlB9/Nltsw/Use1zYZKw1qNr4t94OeY7W+EqUNrdoQFI8wJYLVpzy4yOEopnz29/J2Xx/WMSuIzg3QPjIrgc9IFyVj8TXi8Tba15/aDkjPvXFi+tq4CTnXRQQ0Yj8PCvYcpEQuOknJwCKrfAE1912Mo341DRcMN/HHMbNisbzqXnSYctqz/4IUXYXBJxBKlWnWa9W5ujqZVPs6XYSKfdGiapBBGG2+WKfa8dYme3KPnG7n5rIMHH7r0wbiwWCBnWvugaApNfjiGNSv0WyuDVGmMVn3TW5iRYLsrZ2hO5OqEYpjC1qfWRZtaRlmSj6r4X2tzURIQFGx+DzW/27JaLkrxWOr0dfJcQ2swObbhyAbyJJxcer2d+2a8HpwsDUYJVVeXo4adc9Beu/h7olP/xQW+46KLwqXy+ybV6Ilv622GJxj31d/ecTvlch4Myf7/rKvLrctEAk8lCtObu5ywpCUKMnLiUsi96GASHfDLQ55pkgm1EcMZAlqYQZpLfxf/llQBPCEQf34JupWZYRQsJ6I2RgDDZE3tom9K6ar5Dioe81lkD8bt+nhDrJigD2yhb8EIDAwW5GtZxbHH2bBAopfN/zUg64wC58wsbhgL9cBzxj8lgPKgOaBPEg9GbxPJjp1rF1K6QCRSxadT3KHPHWU+OR+SXVaEeDuJlgeRbNT5ObZcfcum+9IRUUrbwTuMR2N21QbsEVmOYSmkMSv0e3VFThRQ0UQeaEY9M2HiHdesjxdB/bd0Eek+jbbuGqhmOlKqSU1E7nCAoPJREmt7OFkGL/FgrKPrfwg9JCvOzyfhTtNWxI/i2N8U0WXMN4JbPvu5//yWXZqhTgxhETp89qA13NBgcmBN7ZsUQUnwCB+leKRpDEWpKHW2i7YLlf++/SiW0KBCKHjRuRpuxDZLYjpbeNf7jTDFQjxwq1Cj5Es3u7eL/EibPpQZVtU1LrI4boUi08ZY4NN5fNt0ccd3PORXDefUzHkdhHW60MWi6WYCp9NYmsUx8o2MG2uS/2rn7LtW2RQVz0IT0A6f96J4jVaNZNu9lfpLAeBxP/lxhR75lWzUxV86SPVpogsXIL0zUh631kVZYKoU36qx0szruIpy1TXQP3HOyLR765Ehtfagc/Me1+Gktph9V99r2BHeqk9L9/SQxHNG1YwilwXpHsHjtjtOGxqPlAaxxK3osm/lmugRe76czvDAVUtmKoiGr6zZWxCES/B19npH+IinCf23QkR/XdXK52s1zvZcjQ4dM+JaJOYCjqvfGZjBN7FHO27Vtvbz+pXYH12zsHod+/WV7Byk/xEFyrh3bgGPrfAdkPWbP/NffQ80rTS630LQw8i+g3/ZRgC7QsgF5CkeH8Pu0RazzxgxT5BkAE5EfPMuAqqKlPq+CmpkXOrm/78O5aFjiSJvZZWGnn+JY1HxTbBq24lITLJ+b6QDz7WY/iFaDKXJ5TfpiU5J6Cwaw4A5BDN+inbA1CNwvStgCH3pWWbp4aWFP0og2/fGEc8TpNjM2nf7VRuY29z2uiFu42UhLqUhAzIRxYj5Ui+vZ5MvA/KyM3rESQ3TjgTi3dMEkCSU5VOaZ1+Yjg1MtX7q7Wod6PNfF8Sm+iMwZDeCsplLsCNGc+rfgkWfhx37oH+VQGa1PDDfoSJ0fuVvG/FvFp0mXxvc5NO/VgjwoFA6Dy+Y66ovMMPLeWckO30+evA2pBJSiREyXv/ra5cuq6CIpTubQSoWBOfOilfahh1Z2qVJPt1jDPPdJxV3m6ttncO5kzXQ5YsBvxrhuZM2mTMd77Z3es6Op5ydzU5Fatik4A7V7gITAzWkmjXfEB7h4IRjUkGybLpKuBq9+RI7tktV4BLdxt5PY/YKKEMv+XU/ER36L5SrMXXwru0cdhevs9lO7GBqiUBUWl2XVPAhKsZhE0teFxAw8cHvDCMBvtx81knRCRHGrRFbeH0EzGPTR1QyHLunWSHNNOpU3x8t69v2tHEp49B67Yl9hFTkp8MnQmrs10FWy7DeGQeKzTULLN6Ybz9MrNQ9RTL7sKGwcyaNf2/lH6rSABbpY3SKaxxx4mwXhtp3SJoWioBaJUhGKAbhx9XN4C2/qT9U22eB6t+CK5E8UCwJQgKecPSGVVoI3/P7ARWVlvzopvL/7FmUytoUKhCDlkzpe4SGSJ8Eb1SGNch2/dl0Rem8B1P6bHL97EntHn0CcnjirtKq0QOEM20fUShlWce8OTP1LVg3xM5Q49qjXgQmGbSwofHDk6wYafE/16QfwRPyBjmN+yHUyU1HHcYmehapURRo6Zfax5XWPL6aYcIsuRcYyaeU1g02BhMkdnEKGse4Ws+fPKrUfNCOthhXrrgAyoYds9duCGrqdp+6gCF/EqEFIdvzmfKfKTWVZRbanreL8o+89cKaP2Av/02fkIqzFJKAY8vW/gufBWRgO+oB1wAGa7pCMBo66IkTBx2RTr8xNZpMH5oeC/sw3erGRLzooxAhLHao0TrZqiHD5H3B4HPfHfLPuhOknT8aKD7b83IjvDOIgfPW0KwDFdcMQfYjIFiS7HMgmG+6iNLhdtB75L3ejkpvGzsNnYBg0akXO5SHmHMB8sScNUmSWFpNMMgB5OWfakdrSBoAGiABF7GhV7m6dFfnfg/L6KXUfsArQtv6La5hul0wkhjfi3btKhQN6S1146e9iEt2QgOEQRidhWIH5qIqNiS5Uo1tVTBbJLuFm4PrOUv+pTnSa9M45Hzno5W3nT3OmHuPmBdGCA0i6dH+EnFxRoMF4dyHyZdhjqiQ8ODlnyJ8M/lQxfL1of6jjUnGjsOR/ceT1jQZbc5wPsCCOhJp1A+Be4AYcup/Y7Dyaf9yiGTlQUvkqyPzKZZT8b7HP02zwJqmw7lQ9IUebP6mjSEt1xGqsX8pRXVREjkZmrda7qV/Jyp3wP3zNDMgfZ1ItXYwn7SADel97HhBrRQmuWLYZOH5JG1yZ+PFvNbfaVYr5w4vItO8g4Q5+d9rdNkg2sV9htX3jAln+8ts8JGJLg4E8gpfu3L1AMGQwLtbS9KcYrD+X6jnsbp9+b1HCV/hk7jbsqp/q3lB3VXzTWQ+ckO6usA/o7v3Ahq7X/6qyGeYEX7cYaZMc9dbtSY3iaF3COqVspm/bSwG68WG1KInM25Try79CMHY+Fhzy4FZ4Ma9ytWIQxTDeUmADOIxKNWI1ibDjAMYn1fnpAk46gJP1eSYF9kt9230B74ufM2agITJ844AeZmXrrdA0untPl3x1k2m0qXRYNnJ+539df4xO7MPt2VaU4yZ/MoAizyiI7GVt9nqqboIueYWaJB9wvsqZbawAar/N6iUSsH2+uaR8XNV5/Y2xptCKhYgbhXk/+a6NSCqlrcQNpNpS81BKsg+Nic2XaD9epwur2GmhDzWojOoweOp7szFjB4/t/xYpTMvWf9IFPqc6ex81UzEK8O4BozJtGcDyz0vaTx7sAeT7cjC0f57bkFlXJ3fEz82u0IhIKI86YPgGjDWhhBloJJQ6O3NvAcSwDVgqqupDERMO2Q46vBjSgWKxBxo5uIv7hkMoyVkbfIuPm5TXMSlxKz4sOhhL1/PL78RnHApycqvQ6WSYHv223dI7Q/7h+sdPzH7+1DJtyMSfoF5n9GCHFcQn65DIZLkGXySrR9NAqv1ZU6MA0SD0pQqAZoRD99z06IyRTtZ+WUbenJ</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      enter password to read.
    
    </summary>
    
    
      <category term="日记" scheme="http://yoursite.com/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode剑指Offer</title>
    <link href="http://yoursite.com/2021/02/25/LeetCode%E5%89%91%E6%8C%87Offer/"/>
    <id>http://yoursite.com/2021/02/25/LeetCode剑指Offer/</id>
    <published>2021-02-25T08:58:45.470Z</published>
    <updated>2022-08-09T16:37:35.448Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指Offer-09-用两个栈实现队列-https-leetcode-cn-com-problems-yong-liang-ge-zhan-shi-xian-dui-lie-lcof"><a href="#剑指Offer-09-用两个栈实现队列-https-leetcode-cn-com-problems-yong-liang-ge-zhan-shi-xian-dui-lie-lcof" class="headerlink" title="剑指Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/) )"></a><a href="[剑指 Offer 09. 用两个栈实现队列 - 力扣（LeetCode） (leetcode-cn.com">剑指Offer 09. 用两个栈实现队列</a>](<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/</a>) )</h4><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数<code>appendTail</code>和<code>deleteHead</code>，分别完成在队列尾部插入整数和在队列头部删除整数的功能。（若队列中没有元素，<code>deleteHead</code>操作返回-1）</p><a id="more"></a><p><strong>示例 1</strong>：</p><blockquote><p> 输入：</p><p> [“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]</p><p> [[],[3],[],[]]</p><p> 输出：[null,null,3,-1]</p></blockquote><p><strong>示例 2</strong>：</p><blockquote><p> 输入：</p><p> [“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br> [[],[],[5],[2],[],[]]<br> 输出：[null,-1,null,null,5,2]</p></blockquote><p><strong>解题思路：</strong></p><ul><li>栈无法实现队列功能：</li><li>双栈可实现列表倒序：将一个栈的出栈到另外一个栈的入栈，可以实现栈的倒序。</li><li>利用辅助栈可以删除队首的元素：倒序之后，辅助栈的出栈相当于删除了原栈底的元素，即对应的队首元素。</li></ul><blockquote><p>设计栈A用于加入队列尾部的操作，辅助栈B用于将元素倒序，从而实现删除队首元素。</p></blockquote><ul><li>加入队尾<code>appendTail()</code>函数：将数字<code>val</code>加入栈A即可。</li><li>删除队首<code>deleteHead</code>函数：有以下三种情况：<ol><li>当辅助栈B不为空时：直接返回栈B的栈顶元素。</li><li>当辅助栈B为空且A为空时：队列为空，返回-1</li><li>当辅助栈B为空且A不为空时：将栈A倒序到栈B中，然后返回栈B的栈顶元素。</li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.A, self.B = [], []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.A.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.B:</span><br><span class="line">            <span class="keyword">return</span> self.B.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.A:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> self.A:</span><br><span class="line">                    self.B.append(self.A.pop())</span><br><span class="line">                <span class="keyword">return</span> self.B.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = CQueue()</span></span><br><span class="line"><span class="comment"># obj.appendTail(value)</span></span><br><span class="line"><span class="comment"># param_2 = obj.deleteHead()</span></span><br></pre></td></tr></table></figure><h4 id="剑指Offer-30-包含min函数的栈-https-leetcode-cn-com-problems-bao-han-minhan-shu-de-zhan-lcof"><a href="#剑指Offer-30-包含min函数的栈-https-leetcode-cn-com-problems-bao-han-minhan-shu-de-zhan-lcof" class="headerlink" title="剑指Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/) )"></a><a href="[剑指 Offer 30. 包含min函数的栈 - 力扣（LeetCode） (leetcode-cn.com">剑指Offer 30. 包含min函数的栈</a>](<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/</a>) )</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数在该栈中，调用min、push及pop的时间复杂度都是O(1)</p><p><strong>示例</strong></p><blockquote><p>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.min();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.min();   –&gt; 返回 -2.</p></blockquote><p><strong>解题思路</strong></p><ul><li>本题难点：将<code>min()</code>函数复杂度降为O(1)，可以通过建立辅助栈实现：<ul><li>数据栈A：用于存储栈内元素，实现push、pop、获取栈顶元素函数。</li><li>辅助栈B：栈B中存储A中所有非严格降序的元素。则栈A中的最小元素始终对应栈B的栈顶元素。即<code>min()</code>函数只需要返回栈B的栈顶元素即可。</li></ul></li></ul><p>push(x) 函数： 重点为保持栈 BB 的元素是 非严格降序 的。</p><p>将 x 压入栈 A （即 A.add(x) ）；<br>若 ① 栈 B 为空 或 ② x 小于等于 栈 B 的栈顶元素，则将 x 压入栈 B （即 B.add(x) ）。<br>pop() 函数： 重点为保持栈 A, BA,B 的 元素一致性 。</p><p>执行栈 A 出栈（即 A.pop() ），将出栈元素记为 y ；<br>若 y 等于栈 B 的栈顶元素，则执行栈 B 出栈（即 B.pop() ）。</p><blockquote><p>会考虑到栈A一直pop的情况，注意：由于栈A中的最小值与栈B保持一致性，所以栈A实现pop的时候如果是最小值栈B一定会也会更新，除非栈A实现pop之后对栈A的最小值没有影响。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.A, self.B = [], []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.A.append(x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.B <span class="keyword">or</span> self.B[<span class="number">-1</span>] &gt;= x:</span><br><span class="line">            self.B.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.A.pop() == self.B[<span class="number">-1</span>]:</span><br><span class="line">            self.B.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.A[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.B[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop() </span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.min()</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-06-从尾到头打印链表-https-leetcode-cn-com-problems-cong-wei-dao-tou-da-yin-lian-biao-lcof"><a href="#剑指-Offer-06-从尾到头打印链表-https-leetcode-cn-com-problems-cong-wei-dao-tou-da-yin-lian-biao-lcof" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/) )"></a><a href="[剑指 Offer 06. 从尾到头打印链表 - 力扣（LeetCode） (leetcode-cn.com">剑指 Offer 06. 从尾到头打印链表</a>](<a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/</a>) )</h4><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 </p><p><strong>示例 1：</strong></p><blockquote><p>输入：head = [1,3,2]<br>输出：[2,3,1]</p></blockquote><p><strong>解题思路</strong></p><p><strong>方法一：递归法</strong></p><blockquote><p>利用递归：先走到链表末端，回溯时依次将节点值加入列表，这样就可以实现链表值的倒序输出。</p></blockquote><p>复杂度分析：</p><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head: ListNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">return</span> self.reversePrint(head.next) + [head.val] <span class="keyword">if</span> head <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure><p><strong>方法二：辅助栈法</strong></p><blockquote><p>链表特点：只能从前到后访问每个节点</p><p>这种先入后出的需求可以借助栈来实现</p></blockquote><p>复杂度分析：</p><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head: ListNode)</span> -&gt; List[int]:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            stack.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> stack[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="剑指Offer24-反转链表"><a href="#剑指Offer24-反转链表" class="headerlink" title="剑指Offer24. 反转链表 )"></a><a href="[剑指 Offer 24. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/">剑指Offer24. 反转链表</a> )</h4><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><p><strong>思路</strong></p><p>双指针：定义pre指向None，cur指向当前节点head，依次向后遍历，只要当前不为None，则把当前的next先存在temp中，然后pre和cur反转。</p><p>递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        cur, pre = head, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.next <span class="comment"># 暂存后继节点 cur.next</span></span><br><span class="line">            cur.next = pre <span class="comment"># 修改 next 引用指向</span></span><br><span class="line">            pre = cur      <span class="comment"># pre 暂存 cur</span></span><br><span class="line">            cur = tmp      <span class="comment"># cur 访问下一节点</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h4 id="剑指Offer35-复杂链表的复制"><a href="#剑指Offer35-复杂链表的复制" class="headerlink" title="剑指Offer35. 复杂链表的复制 )"></a><a href="[剑指 Offer 35. 复杂链表的复制 - 力扣（LeetCode）](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指Offer35. 复杂链表的复制</a> )</h4><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><p>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p><p><strong>思路</strong></p><p>先遍历一遍链表，建立“原节点 - 新节点”的一个dict，然后在遍历一遍原链表，将新节点的next和random通过dict指向对应的新节点。</p><p>时间复杂度和空间复杂度：O(N)</p><p>方法二：拼接 + 拆分</p><p>考虑构建 原节点 1 -&gt; 新节点 1 -&gt; 原节点 2 -&gt; 新节点 2 -&gt; …… 的拼接链表，如此便可在访问原节点的 random 指向节点的同时找到新对应新节点的 random 指向节点。</p><p><a href="[剑指 Offer 35. 复杂链表的复制（哈希表 / 拼接与拆分，清晰图解） - 复杂链表的复制 - 力扣（LeetCode）](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/jian-zhi-offer-35-fu-za-lian-biao-de-fu-zhi-ha-xi-/">算法流程</a> )：</p><ul><li>复制各节点，构建拼接链表:</li><li>构建新链表各节点的 random 指向：<ul><li>当访问原节点 cur 的随机指向节点 cur.random 时，对应新节点 cur.next 的随机指向节点为 cur.random.next </li></ul></li><li>拆分原/新链表<ul><li>设置 pre / cur 分别指向原 / 新链表头节点，遍历执行 pre.next = pre.next.next 和 cur.next = cur.next.next 将两链表拆分开。</li></ul></li><li>返回新链表的头节点res。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):</span></span><br><span class="line"><span class="string">        self.val = int(x)</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.random = random</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> head</span><br><span class="line">        oldTonew = &#123;&#125;</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            oldTonew[cur] = Node(cur.val)</span><br><span class="line">            cur = cur.next</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            oldTonew[cur].next = oldTonew.get(cur.next)</span><br><span class="line">            oldTonew[cur].random = oldTonew.get(cur.random)</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> oldTonew[head]</span><br></pre></td></tr></table></figure><h4 id="剑指Offer05-替换空格"><a href="#剑指Offer05-替换空格" class="headerlink" title="剑指Offer05 替换空格 )"></a><a href="[剑指 Offer 05. 替换空格 - 力扣（LeetCode）](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指Offer05 替换空格</a> )</h4><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：</p><p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)</span><br></pre></td></tr></table></figure><h4 id="剑指Offer58-左旋转字符串"><a href="#剑指Offer58-左旋转字符串" class="headerlink" title="剑指Offer58 左旋转字符串 )"></a><a href="[剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指Offer58 左旋转字符串</a> )</h4><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p>示例 1：</p><p>输入: s = “abcdefg”, k = 2<br>输出: “cdefgab”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseLeftWords</span><span class="params">(self, s: str, n: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> s[n:] + s[<span class="number">0</span>:n]</span><br></pre></td></tr></table></figure><h4 id="剑指Offer03-数组中重复的数字"><a href="#剑指Offer03-数组中重复的数字" class="headerlink" title="剑指Offer03 数组中重复的数字 )"></a><a href="[剑指 Offer 03. 数组中重复的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指Offer03 数组中重复的数字</a> )</h4><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p><p><strong>思路</strong></p><p>用python里面自带的set或者dict数据类型自动排除重复的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        s = set()</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">return</span> n</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.add(n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="剑指Offer53-在排序数组中查找数字"><a href="#剑指Offer53-在排序数组中查找数字" class="headerlink" title="剑指Offer53 在排序数组中查找数字 )"></a><a href="[剑指 Offer 53 - I. 在排序数组中查找数字 I - 力扣（LeetCode）](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指Offer53 在排序数组中查找数字</a> )</h4><p>统计一个数字在排序数组中出现的次数。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: nums = [5,7,7,8,8,10], target = 8</span></span><br><span class="line"><span class="section">输出: 2</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>数组左右两个指针同时向中间移动，遇到target就停下，最后个数为right-left+1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> len(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        pre, post = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> pre &lt;= post <span class="keyword">and</span> <span class="keyword">not</span> (nums[pre] == nums[post] == target):</span><br><span class="line">            pre = pre + (nums[pre] &lt; target)</span><br><span class="line">            post = post - (nums[post] &gt; target)</span><br><span class="line">        <span class="keyword">return</span> post-pre+<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>二分</strong></p><p>两次二分分别查找target的左右边界。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> len(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        pre, post = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="comment"># 查找有边界</span></span><br><span class="line">        <span class="keyword">while</span> pre &lt;= post:</span><br><span class="line">            mid = (pre+post) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt;= target: pre = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: post = mid<span class="number">-1</span></span><br><span class="line">        right = pre</span><br><span class="line">        <span class="comment"># 若数组中没有target，则提前返回</span></span><br><span class="line">        <span class="keyword">if</span> post &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[post] != target: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 查找左边界</span></span><br><span class="line">        pre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pre &lt;= post:</span><br><span class="line">            mid = (pre+post) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target: pre = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: post = mid<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right - post - <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="剑指Offer53-0-n-1中缺失的数字"><a href="#剑指Offer53-0-n-1中缺失的数字" class="headerlink" title="剑指Offer53 0~n-1中缺失的数字 )"></a><a href="[剑指 Offer 53 - II. 0～n-1中缺失的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/">剑指Offer53 0~n-1中缺失的数字</a> )</h4><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [0,1,3]</span></span><br><span class="line"><span class="section">输出: 2</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">0,1,2,3</span>,<span class="number">4,5,6,7</span>,<span class="number">9</span>]</span><br><span class="line">输出: <span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>二分：用数字0和len(nums)-1做下标，判断条件为mid与nums[mid]的差值是否为1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> len(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        pre, post = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> pre &lt;= post:</span><br><span class="line">            mid = (pre + post) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]-mid:</span><br><span class="line">                post = post - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = pre + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> post+<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="剑指Offer04-二维数组中的查找"><a href="#剑指Offer04-二维数组中的查找" class="headerlink" title="剑指Offer04 二维数组中的查找 )"></a><a href="[剑指 Offer 04. 二维数组中的查找 - 力扣（LeetCode）](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指Offer04 二维数组中的查找</a> )</h4><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>示例:</p><p>现有矩阵 matrix 如下：</p><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。</p><p>给定 target = 20，返回 false。</p><p><strong>思路</strong></p><p>从左下角向右上角查找，如果当前值比target大，则向上，筛除一行的数据，如果当前值比target小，则向右，筛除一列的数据。</p><p>为什么不从右下角开始是因为，当当前值比target大时，既可能向左又可能向上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        rows, cols = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        i, j = rows<span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; cols:</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] &lt; target:</span><br><span class="line">                    j = j + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="剑指Offer11-旋转数组的最小数字"><a href="#剑指Offer11-旋转数组的最小数字" class="headerlink" title="剑指Offer11 旋转数组的最小数字 )"></a><a href="[剑指 Offer 11. 旋转数组的最小数字 - 力扣（LeetCode）](https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指Offer11 旋转数组的最小数字</a> )</h4><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  </p><p>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numbers = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numbers = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>二分：</p><ul><li>当mid比right大时，说明最小值一定在mid的右边，left=mid+1</li><li>当mid比right小时，说明最小值一定在mid的左边且有可能是mid，所以right = mid</li><li>当mid与right相等时，此时可能在mid左边，也可能在mid右边。缩小区间：right=right-1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minArray</span><span class="params">(self, numbers: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(numbers) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> numbers[<span class="number">0</span>]</span><br><span class="line">        pre, post = <span class="number">0</span>, len(numbers) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> pre &lt;= post:</span><br><span class="line">            mid = (pre + post) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> numbers[mid] &gt; numbers[post]:</span><br><span class="line">                pre = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> numbers[mid] &lt; numbers[post]:</span><br><span class="line">                post = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                post = post - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> numbers[pre]</span><br></pre></td></tr></table></figure><p>当数组元素全相等时，时间复杂度会退化到O(N)。</p><h4 id="剑指Offer50-第一个只出现一次的字符"><a href="#剑指Offer50-第一个只出现一次的字符" class="headerlink" title="剑指Offer50 第一个只出现一次的字符 )"></a><a href="[剑指 Offer 50. 第一个只出现一次的字符 - 力扣（LeetCode）](https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指Offer50 第一个只出现一次的字符</a> )</h4><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。 </p><p><strong>示例 1:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abaccdeff"</span></span><br><span class="line">输出：<span class="string">'b'</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>有序哈希表，遍历字符串，第一次出现v为True，否则False，然后依次遍历有序哈希表(python3之后默认哈希表是有序的)，遇到第一个True返回k。或者可以再重现遍历一遍字符串，遇到第一个k为True的字符时返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            dic[c] = <span class="keyword">not</span> c <span class="keyword">in</span> dic</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> dic.items():</span><br><span class="line">            <span class="keyword">if</span> v:</span><br><span class="line">                <span class="keyword">return</span> k</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span></span><br></pre></td></tr></table></figure><h4 id="剑指Offer32-从上到下打印二叉树-1"><a href="#剑指Offer32-从上到下打印二叉树-1" class="headerlink" title="剑指Offer32 从上到下打印二叉树-1 )"></a><a href="[剑指 Offer 32 - I. 从上到下打印二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指Offer32 从上到下打印二叉树-1</a> )</h4><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><p> <strong>思路</strong></p><p>用一个列表存下当前层的所有树节点，然后依次遍历，输出val，并把其左右节点继续插入到列表中。</p><p>优化：可以借助队列或者双向队列的数据结构。则每次只需要从队首出队，然后新的节点从后面入队就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        node = [root]</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> index &lt; len(node):</span><br><span class="line">                temp = node.pop(index)</span><br><span class="line">                ans.append(temp.val)</span><br><span class="line">                <span class="keyword">if</span> temp.left:</span><br><span class="line">                    node.insert(index, temp.left)</span><br><span class="line">                    index = index+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> temp.right:</span><br><span class="line">                    node.insert(index, temp.right)</span><br><span class="line">                    index = index+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res, queue = [], collections.deque()  <span class="comment"># 双向队列</span></span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">作者：jyd</span><br><span class="line">链接：https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solution/mian-shi-ti<span class="number">-32</span>-ii-cong-shang-dao-xia-da-yin-er-c<span class="number">-5</span>/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="剑指Offer32-从上到下打印二叉树-2"><a href="#剑指Offer32-从上到下打印二叉树-2" class="headerlink" title="剑指Offer32 从上到下打印二叉树-2 )"></a><a href="[剑指 Offer 32 - II. 从上到下打印二叉树 II - 力扣（LeetCode）](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指Offer32 从上到下打印二叉树-2</a> )</h4><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 </p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>上面的思路中，在每一层遍历树节点的时候用一个临时列表先存下来当前层的值，当这层全部遍历完之后插入到ans中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        node = [root]</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            ans_le = []</span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> index &lt; len(node):</span><br><span class="line">                temp = node.pop(index)</span><br><span class="line">                ans_le.append(temp.val)</span><br><span class="line">                <span class="keyword">if</span> temp.left:</span><br><span class="line">                    node.insert(index, temp.left)</span><br><span class="line">                    index = index+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> temp.right:</span><br><span class="line">                    node.insert(index, temp.right)</span><br><span class="line">                    index = index+<span class="number">1</span></span><br><span class="line">            ans.append(ans_le)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res, queue = [], collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solution/mian-shi-ti<span class="number">-32</span>-ii-cong-shang-dao-xia-da-yin-er-c<span class="number">-5</span>/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="剑指Offer-32-从上到下打印儿二叉树"><a href="#剑指Offer-32-从上到下打印儿二叉树" class="headerlink" title="剑指Offer 32 从上到下打印儿二叉树 )"></a><a href="[剑指 Offer 32 - III. 从上到下打印二叉树 III - 力扣（LeetCode）](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指Offer 32 从上到下打印儿二叉树</a> )</h4><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 </p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">20</span>,<span class="number">9</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>增加一个判断当前层是从左出队列还是从右出队列，此时用列表就比较麻烦。</p><p>另外一种方法：也可以用上面的方法，在最后面插入res_level的时候加一个判断，如果是奇数层则顺序插入，否则倒序插入。</p><p><code>res.append(res_level(::-1) if len(res) % 2 else res_level)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res, queue = [], collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            res_level = []</span><br><span class="line">            flag = <span class="keyword">not</span> flag</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    temp = queue.popleft()</span><br><span class="line">                    res_level.append(temp.val)</span><br><span class="line">                    <span class="keyword">if</span> temp.left: queue.append(temp.left)</span><br><span class="line">                    <span class="keyword">if</span> temp.right: queue.append(temp.right)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp = queue.pop()</span><br><span class="line">                    res_level.append(temp.val)</span><br><span class="line">                    <span class="keyword">if</span> temp.right: queue.appendleft(temp.right)</span><br><span class="line">                    <span class="keyword">if</span> temp.left: queue.appendleft(temp.left)</span><br><span class="line">            res.append(res_level)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指Offer26-树的子结构"><a href="#剑指Offer26-树的子结构" class="headerlink" title="剑指Offer26 树的子结构 )"></a><a href="[剑指 Offer 26. 树的子结构 - 力扣（LeetCode）](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">剑指Offer26 树的子结构</a> )</h4><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><pre><code> 3/ \</code></pre><p>   4   5<br>  / \<br> 1   2<br>给定的树 B：</p><p>   4<br>  /<br> 1<br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], B = [<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>], B = [<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>两步：</p><ul><li>先序遍历树A的每个节点：</li><li>判断树A中以当前节点作为根节点的子树是否包含树B。对应函数<code>recur(a, b)</code></li></ul><p><a href="[面试题26. 树的子结构（先序遍历 + 包含判断，清晰图解） - 树的子结构 - 力扣（LeetCode）](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/">算法流程</a> )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span><span class="params">(self, A: TreeNode, B: TreeNode)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(a, b)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> b: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> a <span class="keyword">or</span> a.val != b.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> recur(a.left, b.left) <span class="keyword">and</span> recur(a.right, b.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bool(A <span class="keyword">and</span> B) <span class="keyword">and</span> (recur(A, B) <span class="keyword">or</span> self.isSubStructure(A.left, B) <span class="keyword">or</span> self.isSubStructure(A.right, B))</span><br></pre></td></tr></table></figure><h4 id="剑指Offer-27-二叉树的镜像"><a href="#剑指Offer-27-二叉树的镜像" class="headerlink" title="剑指Offer 27 二叉树的镜像 )"></a><a href="[剑指 Offer 27. 二叉树的镜像 - 力扣（LeetCode）](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/">剑指Offer 27 二叉树的镜像</a> )</h4><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><pre><code>4</code></pre><p>   /   \<br>  2     7<br> / \   / \<br>1   3 6   9<br>镜像输出：</p><pre><code>4</code></pre><p>   /   \<br>  7     2<br> / \   / \<br>9   6 3   1</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>交换当前父节点的左右子树并继续递归调用当前的左右子树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment"># root.left, root.right = root.right, root.left</span></span><br><span class="line">        <span class="comment"># self.mirrorTree(root.left)</span></span><br><span class="line">        <span class="comment"># self.mirrorTree(root.right)</span></span><br><span class="line">        root.left, root.right = self.mirrorTree(root.right), self.mirrorTree(root.left)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h4 id="剑指Offer28-对称的二叉树"><a href="#剑指Offer28-对称的二叉树" class="headerlink" title="剑指Offer28 对称的二叉树 )"></a><a href="[剑指 Offer 28. 对称的二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/">剑指Offer28 对称的二叉树</a> )</h4><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><pre><code>1</code></pre><p>   / \<br>  2   2<br> / \ / \<br>3  4 4  3<br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><pre><code>1</code></pre><p>   / \<br>  2   2<br>   \   \<br>   3    3</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,null,<span class="number">3</span>,null,<span class="number">3</span>]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>递归根节点的左右子树：</p><ul><li>结束条件：<ul><li>当A和B都为空时，True</li><li>当A和B中有一个为空，或者A的值不等于B的值，False</li></ul></li><li>递归公式：继续调用左子树中的左子节点与右子树的右子节点。</li></ul><p>判断根节点是否为空然后调用调用递归函数传入根节点的左子树和右子树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(a, b)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> a == b: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> a <span class="keyword">or</span> <span class="keyword">not</span> b <span class="keyword">or</span> a.val != b.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> recur(a.left, b.right) <span class="keyword">and</span> recur(a.right, b.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bool(<span class="keyword">not</span> root) <span class="keyword">or</span> recur(root.left, root.right)</span><br></pre></td></tr></table></figure><h4 id="剑指Offer10-斐波那契数列"><a href="#剑指Offer10-斐波那契数列" class="headerlink" title="剑指Offer10 斐波那契数列 )"></a><a href="[剑指 Offer 10- I. 斐波那契数列 - 力扣（LeetCode）](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">剑指Offer10 斐波那契数列</a> )</h4><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p><p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>注意</strong></p><p>python对于整数没有限制，可以理解为无限大。所以不需要考虑整数越界的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            ans = (a + b) % <span class="number">1000000007</span></span><br><span class="line">            a, b = b, ans</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="剑指Offer-10-青蛙跳台阶的问题"><a href="#剑指Offer-10-青蛙跳台阶的问题" class="headerlink" title="剑指Offer 10 青蛙跳台阶的问题 )"></a><a href="[剑指 Offer 10- II. 青蛙跳台阶问题 - 力扣（LeetCode）](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指Offer 10 青蛙跳台阶的问题</a> )</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span></span><br><span class="line">输出：<span class="number">21</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">0</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>起始值不同的斐波那契数列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">            b, a = (a+b) % <span class="number">1000000007</span>, b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><h4 id="剑指Offer-63-股票的最大利润"><a href="#剑指Offer-63-股票的最大利润" class="headerlink" title="剑指Offer 63 股票的最大利润 )"></a><a href="[剑指 Offer 63. 股票的最大利润 - 力扣（LeetCode）](https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/">剑指Offer 63 股票的最大利润</a> )</h4><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [7,1,5,3,6,4]</span></span><br><span class="line"><span class="section">输出: 5</span></span><br><span class="line"><span class="section">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span></span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [7,6,4,3,1]</span></span><br><span class="line"><span class="section">输出: 0</span></span><br><span class="line"><span class="section">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>dp[0]=0，表示首日利润为0，因此前i日最大利润dp[i]等于前i-1日的最大利润dp[i-1]和第i日卖出的最大利润中的最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max(dp[i<span class="number">-1</span>], prices[i]-min(prices[<span class="number">0</span>:i]))</span><br></pre></td></tr></table></figure><p>其中可以借助一个cost每日更新最低价格。并且dp[i]只与dp[i-1]有关，所以可以借助profit来更新保存dp[i-1]。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span> -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            ans = (max(ans, prices[i]-prices[i<span class="number">-1</span>]))</span><br><span class="line">            prices[i] = min(prices[i], prices[i<span class="number">-1</span>])  <span class="comment"># 将cost存在当前的prices[i]中</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="剑指Offer-42-连续子数组的最大和"><a href="#剑指Offer-42-连续子数组的最大和" class="headerlink" title="剑指Offer 42 连续子数组的最大和 )"></a><a href="[剑指 Offer 42. 连续子数组的最大和 - 力扣（LeetCode）](https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指Offer 42 连续子数组的最大和</a> )</h4><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p><strong>示例1:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="string">-2</span>,1,<span class="string">-3</span>,4,<span class="string">-1</span>,2,1,<span class="string">-5</span>,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,<span class="string">-1</span>,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>状态定义：当前节点时的连续子数组的最大和。</p><p>状态转移：<code>dp[i] = max(nums[i] , dp[i-1] + nums[i])</code>表示当前最大子数组的最大和是从该点开始还是包含该点。</p><p>返回：max(dp)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        dp = [nums[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            dp.append(max(nums[i], dp[i<span class="number">-1</span>]+nums[i]))</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><h4 id="剑指Offer47-礼物的最大价值"><a href="#剑指Offer47-礼物的最大价值" class="headerlink" title="剑指Offer47 礼物的最大价值 )"></a><a href="[剑指 Offer 47. 礼物的最大价值 - 力扣（LeetCode）](https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指Offer47 礼物的最大价值</a> )</h4><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p>示例 1:</p><p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</p><p><strong>思路</strong></p><p>状态矩阵定义：到当前点时能取得的最大价值。</p><p>状态矩阵：<code>grid[i][j] += max(grid[i-1][j], grid[i][j-1])</code></p><p>初始化第一行和第一列，然后依次遍历所有点。返回最右下角的点的值即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxValue</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(grid)):</span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(grid[<span class="number">0</span>])):</span><br><span class="line">            grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(grid[<span class="number">0</span>])):</span><br><span class="line">                grid[i][j] += max(grid[i<span class="number">-1</span>][j], grid[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> grid[len(grid)<span class="number">-1</span>][len(grid[<span class="number">0</span>])<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="剑指Offer46-把数字翻译成字符串"><a href="#剑指Offer46-把数字翻译成字符串" class="headerlink" title="剑指Offer46 把数字翻译成字符串 )"></a><a href="[剑指 Offer 46. 把数字翻译成字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指Offer46 把数字翻译成字符串</a> )</h4><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p>示例 1:</p><p>输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”</p><p><strong>思路</strong>：</p><p>针对当前的数字，只可能有两种情况：一种是当前数字作为一个字符，还有一种可能是联合前面一个数字，组成一个不大于25且不小于10(前面一个数字不为0)的数字作为一个字符。</p><p>所以状态转移方程为：<br>$$<br>d p[i]= \begin{cases}d p[i-1]+d p[i-2] &amp; , 10 x_{i-1}+x_{i} \in[10,25] \ d p[i-1] &amp; , 10 x_{i-1}+x_{i} \in[0,10) \cup(25,99]\end{cases}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">translateNum</span><span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">        num = [<span class="number">0</span>] + [int(s) <span class="keyword">for</span> s <span class="keyword">in</span> str(num)]</span><br><span class="line">        <span class="keyword">if</span> len(num) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(num)):</span><br><span class="line">            dp.append(dp[i<span class="number">-1</span>] + (<span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> num[i<span class="number">-1</span>] <span class="keyword">or</span> num[i<span class="number">-1</span>]*<span class="number">10</span>+num[i] &gt; <span class="number">25</span> <span class="keyword">else</span> dp[i<span class="number">-2</span>]))</span><br><span class="line">        <span class="keyword">return</span> dp[len(num)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><strong>优化写法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">translateNum</span><span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">        s = str(num)</span><br><span class="line">        a = b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(s) + <span class="number">1</span>):</span><br><span class="line">            a, b = (a + b <span class="keyword">if</span> <span class="string">"10"</span> &lt;= s[i - <span class="number">2</span>:i] &lt;= <span class="string">"25"</span> <span class="keyword">else</span> a), a</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><h4 id="剑指Offer-48-最长不含重复字符的子字符串"><a href="#剑指Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指Offer 48 最长不含重复字符的子字符串 )"></a><a href="[剑指 Offer 48. 最长不含重复字符的子字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指Offer 48 最长不含重复字符的子字符串</a> )</h4><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 </p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: "abcabcbb"</span></span><br><span class="line"><span class="section">输出: 3 </span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: "pwwkew"</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。</span></span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">"pwke"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>状态定义：dp[j]代表以字符s[j]为结尾的“最长不重复子字符串”的长度。</p><p>转移方程：固定右边界j，设字符s[j]左边距离最近的相同字符为s[i]，即s[j]=s[i]</p><ol><li>当i&lt;0时，即s[j]左边无相同字符，则<code>dp[j]=dp[j-1]+1</code></li><li>当<code>dp[j-1] &lt; j-i</code>，说明字符s[i]在子字符串dp[j-1]区间之外，则<code>dp[j] = dp[j-1] + 1</code>。</li><li>当<code>dp[j-1] &gt;= j-i</code>，说明字符s[i]在子字符串dp[j-1]区间之中，则dp[j]的左边界由s[i]决定，即<code>dp[j] = j - i</code>。</li></ol><p>$$<br>d p[j]= \begin{cases}d p[j-1]+1 &amp; , d p[j-1]&lt;j-i \ j-i &amp; , d p[j-1] \geq j-i\end{cases}<br>$$</p><p>动态规划+哈希表：</p><p>哈希表统计：可以用哈希表来存s[j]最后一次出现的索引位置，即上面的i。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        res, temp = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            i = d.get(s[j], <span class="number">-1</span>)</span><br><span class="line">            d[s[j]] = j</span><br><span class="line">            temp = temp + <span class="number">1</span> <span class="keyword">if</span> temp &lt; j - i <span class="keyword">else</span> (j - i)</span><br><span class="line">            res = max(res, temp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指Offer-18-删除链表的节点"><a href="#剑指Offer-18-删除链表的节点" class="headerlink" title="剑指Offer 18 删除链表的节点 )"></a><a href="[剑指 Offer 18. 删除链表的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指Offer 18 删除链表的节点</a> )</h4><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p><strong>注意：</strong>此题对比原题有改动</p><p>示例 1:</p><p>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p><p><strong>思路</strong></p><p>双指针，用一个指针指向当前链表的前一个节点，然后当当前节点的值为val时，将当前节点跳过就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, head: ListNode, val: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> head.val == val: <span class="keyword">return</span> head.next</span><br><span class="line">        pre, cur = head, head.next</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                pre.next = cur.next <span class="keyword">if</span> cur.next <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            pre, cur = pre.next, cur.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h4 id="剑指Offer-22-链表中倒数第k个节点"><a href="#剑指Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指Offer 22. 链表中倒数第k个节点 )"></a><a href="[剑指 Offer 22. 链表中倒数第k个节点 - 力扣（LeetCode）](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指Offer 22. 链表中倒数第k个节点</a> )</h4><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p><p><strong>示例：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 和 k = <span class="number">2.</span></span><br><span class="line"></span><br><span class="line">返回链表 <span class="number">4</span>-&gt;<span class="number">5.</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>双指针：左右指针，先把右指针从头节点向后移动k个，然后左右指针同时向右移动，当右指针到结尾的时候，左指针就为倒数的第k个节点，返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        left, right = head, head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> right.next:</span><br><span class="line">                right = right.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">while</span> right:</span><br><span class="line">            left, right = left.next, right.next</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h4 id="剑指Offer-25-合并两个排序的链表"><a href="#剑指Offer-25-合并两个排序的链表" class="headerlink" title="剑指Offer 25. 合并两个排序的链表 )"></a><a href="[剑指 Offer 25. 合并两个排序的链表 - 力扣（LeetCode）](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指Offer 25. 合并两个排序的链表</a> )</h4><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 </p><p><strong>示例1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>先根据头节点的值的大小确定一条主链表和一个待插入的链表。在主链表上用双指针指向两个相邻的节点，在待插入的链表上用一个指针指向要插入到主链表的那个节点，当该节点的值在主链的双指针中间时，插入进去，或者双指针同时向后移动一个节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1 <span class="keyword">and</span> <span class="keyword">not</span> l2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">            head, pre, cur, ptemp = l1, l1, l1.next, l2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            head, pre, cur, ptemp = l2, l2, l2.next, l1</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> ptemp:</span><br><span class="line">            <span class="keyword">if</span> pre.val &lt;= ptemp.val &lt;= cur.val:</span><br><span class="line">                temp = ptemp.next</span><br><span class="line">                pre.next, ptemp.next = ptemp, cur</span><br><span class="line">                ptemp, pre = temp, ptemp</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre, cur = cur, cur.next</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">            pre.next = ptemp</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p>或者：</p><p>用一个伪头节点，在用一个当前节点cur指向当前的节点，然后分别用两个指针指向两个链表，依次判断大小值然后插入到前面当前节点的后面，然后当前节点后移一位，最后判断两个链表是否还有多余的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        cur = dum = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                cur.next, l1 = l1, l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next, l2 = l2, l2.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        cur.next = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">        <span class="keyword">return</span> dum.next</span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/solution/mian-shi-ti<span class="number">-25</span>-he-bing-liang-ge-pai-xu-de-lian-b<span class="number">-2</span>/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="剑指Offer-52-两个链表的第一个公共节点"><a href="#剑指Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指Offer 52. 两个链表的第一个公共节点 )"></a><a href="[剑指 Offer 52. 两个链表的第一个公共节点 - 力扣（LeetCode）](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指Offer 52. 两个链表的第一个公共节点</a> )</h4><p>输入两个链表，找出它们的第一个公共节点。 </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = <span class="number">8</span>, listA = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], listB = [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], skipA = <span class="number">2</span>, skipB = <span class="number">3</span></span><br><span class="line">输出：Reference of the node with value = <span class="number">8</span></span><br><span class="line">输入解释：相交节点的值为 <span class="number">8</span> （注意，如果两个列表相交则不能为 <span class="number">0</span>）。从各自的表头开始算起，链表 A 为 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]，链表 B 为 [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]。在 A 中，相交节点前有 <span class="number">2</span> 个节点；在 B 中，相交节点前有 <span class="number">3</span> 个节点。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>双指针：设A链表的长度为a，B链表的长度为b，后面公共的子节点的长度为c，</p><p>分别用两个指针从两个链表的头开始向后遍历，当遍历到链表结尾时从另外一个链表的头继续开始遍历。因为两个链表的长度是固定的a+b，后面相同的节点长度为c，所以如果有公共节点，当两个指针都运动a+b-c个长度的时候一定会相遇。</p><p>所以当两个指针相遇的时候一定就是第一个相同节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA: ListNode, headB: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        ha, hb = headA, headB</span><br><span class="line">        <span class="keyword">while</span> ha != hb:</span><br><span class="line">            ha = ha.next <span class="keyword">if</span> ha <span class="keyword">else</span> headB</span><br><span class="line">            hb = hb.next <span class="keyword">if</span> hb <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> ha</span><br></pre></td></tr></table></figure><h4 id="剑指Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指Offer 21. 调整数组顺序使奇数位于偶数前面 )"></a><a href="[剑指 Offer 21. 调整数组顺序使奇数位于偶数前面 - 力扣（LeetCode）](https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指Offer 21. 调整数组顺序使奇数位于偶数前面</a> )</h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。 </p><p><strong>示例：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>] </span><br><span class="line">注：[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>] 也是正确的答案之一。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>一、遍历一遍数组，分别找出奇数和偶数两个数组，最后返回的时候加起来。</p><p>二、定义两个指针，左右指针，左指针从头到尾找指针，右指针从尾到头找奇数，然后交换，然后继续查找直到左指针在右指针后面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> nums[left] &amp; <span class="number">1</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> <span class="keyword">not</span> nums[right] &amp; <span class="number">1</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:</span><br><span class="line">                nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h4 id="剑指Offer-57-和为s的两个数字"><a href="#剑指Offer-57-和为s的两个数字" class="headerlink" title="剑指Offer 57. 和为s的两个数字 )"></a><a href="[剑指 Offer 57. 和为s的两个数字 - 力扣（LeetCode）](https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/">剑指Offer 57. 和为s的两个数字</a> )</h4><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。 </p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">7</span>] 或者 [<span class="number">7</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">26</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">47</span>,<span class="number">60</span>], target = <span class="number">40</span></span><br><span class="line">输出：[<span class="number">10</span>,<span class="number">30</span>] 或者 [<span class="number">30</span>,<span class="number">10</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>一、用字典dict存下所有nums，然后遍历数组依次判断是不是在dict中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            d[i] = i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> target-i <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">return</span> [i, target-i]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p>二、双指针，一个头一个尾，当相加的数比target大则尾指针减一，当相加的数比target小则头指针加一。</p><p>最大的数加上最小数都比target大，所以右指针减一，最小的数加上最大的数都比target小，则左指针加一。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            s = nums[left] + nums[right]</span><br><span class="line">            <span class="keyword">if</span> s &gt; target: right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s &lt; target: left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> [nums[left], nums[right]]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h4 id="剑指Offer-58-1-翻转单词顺序"><a href="#剑指Offer-58-1-翻转单词顺序" class="headerlink" title="剑指Offer 58. -1 翻转单词顺序 )"></a><a href="[剑指 Offer 58 - I. 翻转单词顺序 - 力扣（LeetCode）](https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指Offer 58. -1 翻转单词顺序</a> )</h4><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p><p><strong>示例 1：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="comment">"the sky is blue"</span></span><br><span class="line">输出: <span class="comment">"blue is sky the"</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: "  hello world!  "</span></span><br><span class="line"><span class="section">输出: "world! hello"</span></span><br><span class="line"><span class="section">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="comment">"a good   example"</span></span><br><span class="line">输出: <span class="comment">"example good a"</span></span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        word = [i <span class="keyword">for</span> i <span class="keyword">in</span> s.split(<span class="string">' '</span>) <span class="keyword">if</span> i != <span class="string">''</span>][::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x+<span class="string">" "</span>+y, word) <span class="keyword">if</span> word <span class="keyword">else</span> <span class="string">""</span></span><br><span class="line">        <span class="comment"># return ' '.join(s.strip().split()[::-1])</span></span><br></pre></td></tr></table></figure><p><strong>双指针思路</strong></p><p>倒序遍历字符串，记录单词左右索引边界，然后将其添加到单词列表，最后输出即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        s = s.strip() <span class="comment"># 删除首尾空格</span></span><br><span class="line">        i = j = len(s) - <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i] != <span class="string">' '</span>: i -= <span class="number">1</span> <span class="comment"># 搜索首个空格</span></span><br><span class="line">            res.append(s[i + <span class="number">1</span>: j + <span class="number">1</span>]) <span class="comment"># 添加单词</span></span><br><span class="line">            <span class="keyword">while</span> s[i] == <span class="string">' '</span>: i -= <span class="number">1</span> <span class="comment"># 跳过单词间空格</span></span><br><span class="line">            j = i <span class="comment"># j 指向下个单词的尾字符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(res) <span class="comment"># 拼接并返回</span></span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/solution/mian-shi-ti<span class="number">-58</span>-i-fan-zhuan-dan-ci-shun-xu-shuang-z/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><blockquote><p>split()与split(‘ ‘)的区别就是，split()方法将单词间的多个空格看作是一个空格，因此不会出现多余的空单词。</p></blockquote><h4 id="剑指Offer-12-矩阵中的路径"><a href="#剑指Offer-12-矩阵中的路径" class="headerlink" title="剑指Offer 12. 矩阵中的路径 )"></a><a href="[剑指 Offer 12. 矩阵中的路径 - 力扣（LeetCode）](https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指Offer 12. 矩阵中的路径</a> )</h4><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"E"</span>],[<span class="string">"S"</span>,<span class="string">"F"</span>,<span class="string">"C"</span>,<span class="string">"S"</span>],[<span class="string">"A"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>,<span class="string">"E"</span>]], word = <span class="string">"ABCCED"</span></span><br><span class="line"></span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">board</span> = [[<span class="string">"a"</span>,<span class="string">"b"</span>],[<span class="string">"c"</span>,<span class="string">"d"</span>]], <span class="attr">word</span> = <span class="string">"abcd"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>dfs：确定递归参数，递归结束条件就行。</p><p>递归参数：当前的i和j以及剩下的word字符串。</p><p>递归结束条件：当剩下的word为空时，返回True，当下标越界或者当前点以及标记走过或者当前点不等于剩下的word中的第一个，返回False。</p><p><strong>注意将标记已经走过的点清除标记</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j, w)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> w: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= len(board) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= len(board[<span class="number">0</span>]) <span class="keyword">or</span> board[i][j] == <span class="string">'0'</span> <span class="keyword">or</span> board[i][j] != w[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            board[i][j] = <span class="string">'0'</span></span><br><span class="line">            ans = dfs(i<span class="number">-1</span>, j, w[<span class="number">1</span>:]) <span class="keyword">or</span> dfs(i+<span class="number">1</span>, j, w[<span class="number">1</span>:]) <span class="keyword">or</span> dfs(i, j<span class="number">-1</span>, w[<span class="number">1</span>:]) <span class="keyword">or</span> dfs(i, j+<span class="number">1</span>, w[<span class="number">1</span>:])</span><br><span class="line">            board[i][j] = w[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> dfs(i, j, word): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j, k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= i &lt; len(board) <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= j &lt; len(board[<span class="number">0</span>]) <span class="keyword">or</span> board[i][j] != word[k]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> k == len(word) - <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            board[i][j] = <span class="string">''</span></span><br><span class="line">            res = dfs(i + <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i - <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i, j + <span class="number">1</span>, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i, j - <span class="number">1</span>, k + <span class="number">1</span>)</span><br><span class="line">            board[i][j] = word[k]</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> dfs(i, j, <span class="number">0</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/solution/mian-shi-ti<span class="number">-12</span>-ju-zhen-zhong-de-lu-jing-shen-du-yo/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="剑指Offer-13-机器人的运行范围"><a href="#剑指Offer-13-机器人的运行范围" class="headerlink" title="剑指Offer 13. 机器人的运行范围 )"></a><a href="[剑指 Offer 13. 机器人的运动范围 - 力扣（LeetCode）](https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指Offer 13. 机器人的运行范围</a> )</h4><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">2</span>, n = <span class="number">3</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, n = <span class="number">1</span>, k = <span class="number">0</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>用一个set去存已经走可以走过的点，然后注意此时的dfs只需要向下或者下右查找，因为是从起点出发的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m: int, n: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        visit = set()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> (i, j) <span class="keyword">in</span> visit <span class="keyword">or</span> judge(i, j): <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            visit.add((i, j))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + dfs(i+<span class="number">1</span>, j) + dfs(i, j+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">judge</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> bool(sum([int(c) <span class="keyword">for</span> c <span class="keyword">in</span> str(i)+str(j)]) &gt; k)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-34-二叉树中和为某一值的路径-力扣（LeetCode）"><a href="#剑指-Offer-34-二叉树中和为某一值的路径-力扣（LeetCode）" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指 Offer 34. 二叉树中和为某一值的路径 - 力扣（LeetCode）</a></h4><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p>输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22<br>输出：[[5,4,11,2],[5,8,4,5]]</p><p><strong>思路</strong></p><p>先序遍历二叉树，记录每个节点的值，判断到叶子节点时每个节点的和是否为target。</p><p>需要一个先序遍历的子函数，递归函数。</p><p>递归参数：当前节点以及前面已经记录的路径。</p><p>递归结束条件：当前节点为空时直接返回。</p><p>递归公式：若不为空，将当前节点的值加进路径矩阵，然后判断路径矩阵是否等于target以及当前节点是否为叶子节点，如果满足，将当前路径加进res中，再遍历其左右子树，最后遍历完之后记得将当前节点的值退出去。</p><p><strong>注意：res.append(p)，是将p对象加入到res中，后续p变化时，res中的p对象也会随之变化。正确的做法是：<code>res.append(list(p))</code>，相当于复制一个p加入到res中。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">path</span><span class="params">(r, p)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> r: <span class="keyword">return</span> </span><br><span class="line">            p.append(r.val)</span><br><span class="line">            <span class="keyword">if</span> sum(p) == target <span class="keyword">and</span> <span class="keyword">not</span> r.left <span class="keyword">and</span> <span class="keyword">not</span> r.right: </span><br><span class="line">                res.append(list(p))</span><br><span class="line">            path(r.left, p)</span><br><span class="line">            path(r.right, p)</span><br><span class="line">            p.pop()</span><br><span class="line"></span><br><span class="line">        path(root, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-36-二叉搜索树与双向链表-力扣（LeetCode）"><a href="#剑指-Offer-36-二叉搜索树与双向链表-力扣（LeetCode）" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 36. 二叉搜索树与双向链表 - 力扣（LeetCode）</a></h4><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 </p><p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png" alt="img"></p><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png" alt="img"></p><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><p><strong>[思路](</strong><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5/" target="_blank" rel="noopener">剑指 Offer 36. 二叉搜索树与双向链表（中序遍历，清晰图解） - 二叉搜索树与双向链表 - 力扣（LeetCode）</a> <strong>)</strong></p><p>解法基于性质：二叉搜索树的中序遍历为递增序列。</p><p>考虑使用中序遍历访问树的各节点cur；并在访问每个节点时构建cur和前驱节点pre的引用指向；中序遍历完成后，最后构建头节点和尾节点的引用指向即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val, left=None, right=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span></span><br><span class="line">            dfs(cur.left)  <span class="comment"># 递归左子树</span></span><br><span class="line">            <span class="keyword">if</span> self.pre:  <span class="comment"># 修改节点引用</span></span><br><span class="line">                self.pre.right, cur.left = cur, self.pre</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 记录头节点</span></span><br><span class="line">                self.head = cur</span><br><span class="line">            self.pre = cur  <span class="comment"># 保存cur</span></span><br><span class="line">            dfs(cur.right)  <span class="comment"># 递归右子树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.pre, self.head = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        self.head.left, self.pre.right = self.pre, self.head</span><br><span class="line">        <span class="keyword">return</span> self.head</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-54-二叉搜索树的第k大节点-力扣（LeetCode）"><a href="#剑指-Offer-54-二叉搜索树的第k大节点-力扣（LeetCode）" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 54. 二叉搜索树的第k大节点 - 力扣（LeetCode）</a></h4><p>给定一棵二叉搜索树，请找出其中第 <code>k</code> 大的节点的值。 </p><p><strong>示例 1:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">2</span>], k = <span class="number">1</span></span><br><span class="line">   <span class="number">3</span></span><br><span class="line">  / <span class="string">\</span></span><br><span class="line"> <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">  <span class="string">\</span></span><br><span class="line">   <span class="number">2</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>示例 2</strong>:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>], k = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">       <span class="number">5</span></span><br><span class="line"></span><br><span class="line">      / <span class="string">\</span></span><br><span class="line"></span><br><span class="line">     <span class="number">3</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line">    / <span class="string">\</span></span><br><span class="line"></span><br><span class="line">   <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"></span><br><span class="line">  /</span><br><span class="line"></span><br><span class="line"> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>二叉搜索树的中序遍历为递增序列，第k大的节点可转化为：求此树的中序遍历倒序的第k个节点。</p><p>递归：</p><ul><li>终止条件：当前节点为空时直接返回。</li><li>递归右子树</li><li>统计序号，当前k减1，判断k是够为0，为0则表示已经统计完成，<code>self.res = cur.val</code>。</li><li>递归左子树</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur <span class="keyword">or</span> <span class="keyword">not</span> self.k: <span class="keyword">return</span></span><br><span class="line">            dfs(cur.right)</span><br><span class="line">            <span class="comment"># if self.k == 0: return</span></span><br><span class="line">            self.k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>: self.res = cur.val</span><br><span class="line">            dfs(cur.left)</span><br><span class="line"></span><br><span class="line">        self.k = k</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-29-顺时针打印矩阵-力扣（LeetCode）"><a href="#剑指-Offer-29-顺时针打印矩阵-力扣（LeetCode）" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">剑指 Offer 29. 顺时针打印矩阵 - 力扣（LeetCode）</a></h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 </p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong>：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>定义四个指针，上下左右四个指针，分别指向当前需要输出的四个坐标，然后依次访问每个元素输出就行，当上指针在下指针下面或者左指针在右指针右边的时候跳出循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> []</span><br><span class="line">        left, right, top, bottom = <span class="number">0</span>, len(matrix[<span class="number">0</span>])<span class="number">-1</span>, <span class="number">0</span>, len(matrix)<span class="number">-1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(left, right+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[top][i])</span><br><span class="line">            top += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> top &gt; bottom: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(top, bottom+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][right])</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right &lt; left: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(right, left<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                res.append(matrix[bottom][i])</span><br><span class="line">            bottom -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> bottom &lt; top: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(bottom, top<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                res.append(matrix[i][left])</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>每次取矩阵第一行的元素输出，然后将矩阵向左旋转90度，继续取第一行得元素，直到矩阵为空。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> matrix:</span><br><span class="line">            res.extend(matrix.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">break</span></span><br><span class="line">            matrix = [[row[j] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)]  <span class="comment"># 矩阵向左旋转90度</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-45-把数组排成最小的数-力扣（LeetCode）"><a href="#剑指-Offer-45-把数组排成最小的数-力扣（LeetCode）" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 45. 把数组排成最小的数 - 力扣（LeetCode）</a></h4><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p><strong>示例 1:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">[10,2]</span></span><br><span class="line">输出: <span class="string">"102"</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">[3,30,34,5,9]</span></span><br><span class="line">输出: <span class="string">"3033459"</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>排序问题：将大数往后排，小数往前排，这里大数小数的定义是，当前的数与前面的一个数组和起来比前面的数与当前的数组和起来大，则当前的数为大数，前面的就为小数。通过冒泡排序排一下</p><p>即<code>x+y &gt; y+x</code>则x为大数，y为小数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(self, nums: List[int])</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> str(nums[j]) + str(nums[j+<span class="number">1</span>]) &gt; str(nums[j+<span class="number">1</span>]) + str(nums[j]):</span><br><span class="line">                    nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(str(c) <span class="keyword">for</span> c <span class="keyword">in</span> nums)</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-61-扑克牌中的顺子-力扣（LeetCode）"><a href="#剑指-Offer-61-扑克牌中的顺子-力扣（LeetCode）" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 61. 扑克牌中的顺子 - 力扣（LeetCode）</a></h4><p>从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [1,2,3,4,5]</span></span><br><span class="line"><span class="section">输出: True</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [0,0,1,2,5]</span></span><br><span class="line"><span class="section">输出: True</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>先将数组从小到大排序，然后将前面0的个数记下来，从第一个非零的开始，只有后面一个数减前面一个数不为1，则判断是否相等，相等直接false，否则用零的个数来补两个数的差，接着判断零的个数是不是小于0，如果小于，说明0不够补。最后，只要0的个数大于等于0，就为true，因为0可以任意插在顺子的前后。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isStraight</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nums[i]: count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[i+<span class="number">1</span>]-nums[i] != <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> nums[i+<span class="number">1</span>] == nums[i]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    count = count - (nums[i+<span class="number">1</span>]-nums[i]<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> count &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-40-最小的k个数-力扣（LeetCode）"><a href="#剑指-Offer-40-最小的k个数-力扣（LeetCode）" class="headerlink" title="剑指 Offer 40. 最小的k个数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 40. 最小的k个数 - 力扣（LeetCode）</a></h4><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 </p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>] 或者 [<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>从小到大排序，然后输出前k个最小的数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        arr = sorted(arr)</span><br><span class="line">        <span class="keyword">return</span> arr[:k]</span><br></pre></td></tr></table></figure><p>手写快排</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        arr = self.quick_sort(arr, <span class="number">0</span>, len(arr)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> arr[:k]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(self, arr, first, last)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> first &gt;= last: <span class="keyword">return</span></span><br><span class="line">        left, right = first, last</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[right] &gt;= arr[first]: right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[left] &lt;= arr[first]: left += <span class="number">1</span></span><br><span class="line">            arr[left], arr[right] = arr[right], arr[left]</span><br><span class="line">        arr[first], arr[left] = arr[left], arr[first]</span><br><span class="line">        self.quick_sort(arr, first, left<span class="number">-1</span>)</span><br><span class="line">        self.quick_sort(arr, right+<span class="number">1</span>, last)</span><br><span class="line">        <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-41-数据流中的中位数-力扣（LeetCode）"><a href="#剑指-Offer-41-数据流中的中位数-力扣（LeetCode）" class="headerlink" title="剑指 Offer 41. 数据流中的中位数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 41. 数据流中的中位数 - 力扣（LeetCode）</a></h4><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。</p><p><strong>示例 1：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"></span><br><span class="line">[<span class="string">"MedianFinder"</span>,<span class="string">"addNum"</span>,<span class="string">"addNum"</span>,<span class="string">"findMedian"</span>,<span class="string">"addNum"</span>,<span class="string">"findMedian"</span>]</span><br><span class="line"></span><br><span class="line">[[],[<span class="number">1</span>],[<span class="number">2</span>],[],[<span class="number">3</span>],[]]</span><br><span class="line"></span><br><span class="line">输出：[null,null,null,<span class="number">1.50000</span>,null,<span class="number">2.00000</span>]</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"MedianFinder"</span>,<span class="string">"addNum"</span>,<span class="string">"findMedian"</span>,<span class="string">"addNum"</span>,<span class="string">"findMedian"</span>]</span><br><span class="line">[[],[<span class="number">2</span>],[],[<span class="number">3</span>],[]]</span><br><span class="line">输出：[null,null,<span class="number">2.00000</span>,null,<span class="number">2.50000</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>当插入一个值时，先用二分找出当前这个值插入到哪里，即始终保持这个数据流是排好序的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.arr = []</span><br><span class="line">        self.length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># self.arr.append(num)</span></span><br><span class="line">        <span class="comment"># self.arr = sorted(self.arr)</span></span><br><span class="line">        <span class="comment"># self.length += 1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.length: self.arr.append(num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            index = self.binarySearch(num)</span><br><span class="line">            self.arr.insert(index, num)</span><br><span class="line">        self.length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.length: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(self.arr) &amp; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.arr[self.length &gt;&gt; <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.arr[self.length &gt;&gt; <span class="number">1</span>] + self.arr[(self.length &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>]) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(self.arr)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> self.arr[mid] &gt;= num: right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MedianFinder()</span></span><br><span class="line"><span class="comment"># obj.addNum(num)</span></span><br><span class="line"><span class="comment"># param_2 = obj.findMedian()</span></span><br></pre></td></tr></table></figure><p><strong>思路2</strong></p><p>通过两个堆，一个堆保存较小的一部分，一个堆保存较大的一部分，各保存列表的一半元素，然后中位数只需要根据两个堆的堆顶元素计算得到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.A = [] <span class="comment"># 小顶堆，保存较大的一半</span></span><br><span class="line">        self.B = [] <span class="comment"># 大顶堆，保存较小的一半</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.A) != len(self.B):</span><br><span class="line">            heappush(self.B, -heappushpop(self.A, num))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heappush(self.A, -heappushpop(self.B, -num))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">return</span> self.A[<span class="number">0</span>] <span class="keyword">if</span> len(self.A) != len(self.B) <span class="keyword">else</span> (self.A[<span class="number">0</span>] - self.B[<span class="number">0</span>]) / <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/solution/mian-shi-ti<span class="number">-41</span>-shu-ju-liu-zhong-de-zhong-wei-shu-y/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-55-I-二叉树的深度-力扣（LeetCode）"><a href="#剑指-Offer-55-I-二叉树的深度-力扣（LeetCode）" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">剑指 Offer 55 - I. 二叉树的深度 - 力扣（LeetCode）</a></h4><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 </p><p>例如：</p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。 </p><p><strong>思路</strong></p><p>先判断当前根节点是否为空，为空返回0，否则深度加1然后加上左右子树的最大深度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(self.maxDepth(root.left), self.maxDepth(root.right))</span><br></pre></td></tr></table></figure><p><strong>思路2：树的层序遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue, res = [root], <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">                <span class="keyword">if</span> node.left: tmp.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: tmp.append(node.right)</span><br><span class="line">            queue = tmp</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/solution/mian-shi-ti<span class="number">-55</span>-i-er-cha-shu-de-shen-du-xian-xu-bia/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-55-II-平衡二叉树-力扣（LeetCode）"><a href="#剑指-Offer-55-II-平衡二叉树-力扣（LeetCode）" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 55 - II. 平衡二叉树 - 力扣（LeetCode）</a></h4><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 </p><p><strong>示例 1:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code> </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">1</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">2</span>   <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">3</span>   <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">4</span>   <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>用一个函数判断当前子树的深度，主函数里面先判断当前节点是否为空，若为空则返回True，然后判断当前节点的左右子树深度是否大于1，若是，则返回False，否则继续判断左右子树是否平衡。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> abs(self.recur(root.right) - self.recur(root.left)) &gt; <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(self, cur)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(self.recur(cur.left), self.recur(cur.right))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># if abs(self.recur(root.right) - self.recur(root.left)) &gt; 1: return False</span></span><br><span class="line">        <span class="comment"># else: return self.isBalanced(root.left) and self.isBalanced(root.right)</span></span><br><span class="line">        <span class="keyword">return</span> abs(self.recur(root.right) - self.recur(root.left)) &lt;= <span class="number">1</span> <span class="keyword">and</span> \</span><br><span class="line">               self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(self, cur)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(self.recur(cur.left), self.recur(cur.right))</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先-力扣（LeetCode）"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先-力扣（LeetCode）" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）</a></h4><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt="img"> </p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">root</span> = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">5</span>], <span class="attr">p</span> = <span class="number">2</span>, <span class="attr">q</span> = <span class="number">8</span></span><br><span class="line">输出: <span class="number">6</span> </span><br><span class="line">解释: 节点 <span class="number">2</span> 和节点 <span class="number">8</span> 的最近公共祖先是 <span class="number">6</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">root</span> = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">5</span>], <span class="attr">p</span> = <span class="number">2</span>, <span class="attr">q</span> = <span class="number">4</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 节点 <span class="number">2</span> 和节点 <span class="number">4</span> 的最近公共祖先是 <span class="number">2</span>, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>最近公共祖先：即找到p和q的一个最近的节点使得p和q分别在该节点的左右子树。或者说，p为该节点，然后q为其左右子树中的一个，或者是，q为该节点，然后p为其左右子树中的一个。</p><p>二叉搜索树：每个节点的值都不一样并且对于任意节点左子树所有节点的数都比根节点小，右子树所有节点的值都比根节点大。</p><p>所以可以通过节点的值与根节点的值判断是不是在同一子树。如果是，继续查该子树，直到找到第一个节点使得p和q为该节点的左右子树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">elif</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>递归方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti<span class="number">-68</span>-i-er-cha-sou-suo-shu-de-zui-jin-g<span class="number">-7</span>/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-68-II-二叉树的最近公共祖先-力扣（LeetCode）"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先-力扣（LeetCode）" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">剑指 Offer 68 - II. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">root</span> = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="number">4</span>], <span class="attr">p</span> = <span class="number">5</span>, <span class="attr">q</span> = <span class="number">1</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 节点 <span class="number">5</span> 和节点 <span class="number">1</span> 的最近公共祖先是节点 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">root</span> = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="number">4</span>], <span class="attr">p</span> = <span class="number">5</span>, <span class="attr">q</span> = <span class="number">4</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 节点 <span class="number">5</span> 和节点 <span class="number">4</span> 的最近公共祖先是节点 <span class="number">5</span>。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>[思路](</strong><a href="https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/" target="_blank" rel="noopener">剑指 Offer 68 - II. 二叉树的最近公共祖先（DFS ，清晰图解） - 二叉树的最近公共祖先 - 力扣（LeetCode）</a> <strong>)</strong></p><p>二叉树没有特性了，没有通过节点的值判断是左右子树了。</p><p>dfs递推：</p><p>找出一个节点的左右子树的返回值，如果左右子树都为空，则返回空，如果左子树的返回值不为空返回左子树返回值，如果右子树的返回值不为空返回右子树的返回值，如果左右子树的返回值都不为空，则返回当前根节点。</p><p>结束条件： 若当前节点为空返回空，若当前节点为p则返回p，若当前节点为q则返回q。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(cur)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur <span class="keyword">or</span> cur == p <span class="keyword">or</span> cur == q: <span class="keyword">return</span> cur</span><br><span class="line">            left = recur(cur.left)</span><br><span class="line">            right = recur(cur.right)</span><br><span class="line">            <span class="keyword">if</span> left <span class="keyword">and</span> right: <span class="keyword">return</span> cur</span><br><span class="line">            <span class="keyword">if</span> left: <span class="keyword">return</span> left</span><br><span class="line">            <span class="keyword">if</span> right: <span class="keyword">return</span> right</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur(root)</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-07-重建二叉树-力扣（LeetCode）"><a href="#剑指-Offer-07-重建二叉树-力扣（LeetCode）" class="headerlink" title="剑指 Offer 07. 重建二叉树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 07. 重建二叉树 - 力扣（LeetCode）</a></h4><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"> </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Input:</span> preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>], inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line"><span class="string">Output:</span> [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = <span class="string">[-1]</span>, inorder = <span class="string">[-1]</span></span><br><span class="line">Output: <span class="string">[-1]</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>如果当前序和后序遍历数组为空，则返回None。</p><p>因为前序一定是根节点，所以新建一个根节点的值为前序的第一个值，然后在中序数组中找出前序第一个值的下标。</p><p>继续构建该节点的左右子树，左子树为中序遍历中根节点前面的所有，为前序遍历中的根节点后面的一部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> inorder: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        index = inorder.index(preorder[<span class="number">0</span>])</span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span>:index+<span class="number">1</span>], inorder[:index])</span><br><span class="line">        root.right = self.buildTree(preorder[(index+<span class="number">1</span>):], inorder[(index+<span class="number">1</span>):])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-16-数值的整数次方-力扣（LeetCode）"><a href="#剑指-Offer-16-数值的整数次方-力扣（LeetCode）" class="headerlink" title="剑指 Offer 16. 数值的整数次方 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">剑指 Offer 16. 数值的整数次方 - 力扣（LeetCode）</a></h4><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。 </p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">2.00000</span>, n = <span class="number">10</span></span><br><span class="line">输出：<span class="number">1024.00000</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">2.00000</span>, n = <span class="number">-2</span></span><br><span class="line">输出：<span class="number">0.25000</span></span><br><span class="line">解释：<span class="number">2</span><span class="number">-2</span> = <span class="number">1</span>/<span class="number">22</span> = <span class="number">1</span>/<span class="number">4</span> = <span class="number">0.25</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>快速幂取模：</p><p>$x^{n}=\left(x^{2}\right)^{\frac{n}{2}}$ 每次可以将n进行除2，这里就需要考虑到n为奇数和偶数的情况的。</p><ul><li>根据二分推导，可通过循环$x=x^{2}$操作，每次把幂从n降至n//2，直到幂降为0。</li><li>设res = 1，则初始状态$x^{n}=x^{n}<em>res$。在循环二分的时候，每当n为奇数时，将多出的一项x乘入res，则最终可化至$x^{n}=x^{0}</em>res=res$，返回res即可。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        is_fushu = <span class="literal">True</span> <span class="keyword">if</span> n &lt; <span class="number">0</span> <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">        n = abs(n)</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                res *= x</span><br><span class="line">            x = x * x</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / res <span class="keyword">if</span> is_fushu <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-33-二叉搜索树的后序遍历序列-力扣（LeetCode）"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列-力扣（LeetCode）" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 33. 二叉搜索树的后序遍历序列 - 力扣（LeetCode）</a></h4><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。 </p><p>参考以下这颗二叉搜索树：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">6</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [1,6,3,2,5]</span></span><br><span class="line"><span class="section">输出: false</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [1,3,2,6,5]</span></span><br><span class="line"><span class="section">输出: true</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>二叉搜索树：树中的每个节点的值都不同并且任意节点的左子树所有节点的值都比根节点小，右子树所有节点的值都比根节点大。</p><p>先根据左子树的所有节点都比根节点的值小找出左子树的数组范围，然后判断右子树的所有节点的值是不是比根节点的大，如果都满足在递归访问其左右子树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span><span class="params">(self, postorder: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        temp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> postorder[temp] &lt; postorder[<span class="number">-1</span>]:</span><br><span class="line">            temp += <span class="number">1</span></span><br><span class="line">        mid = temp</span><br><span class="line">        <span class="keyword">while</span> postorder[temp] &gt; postorder[<span class="number">-1</span>]:</span><br><span class="line">            temp += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> postorder[temp] == postorder[<span class="number">-1</span>] <span class="keyword">and</span> \</span><br><span class="line">               self.verifyPostorder(postorder[<span class="number">0</span>:mid]) <span class="keyword">and</span> self.verifyPostorder(postorder[mid:<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span><span class="params">(self, postorder: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= j: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            temp = i</span><br><span class="line">            <span class="keyword">while</span> postorder[temp] &lt; postorder[j]:</span><br><span class="line">                temp += <span class="number">1</span></span><br><span class="line">            mid = temp</span><br><span class="line">            <span class="keyword">while</span> postorder[temp] &gt; postorder[j]:</span><br><span class="line">                temp += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> temp == j <span class="keyword">and</span> recur(i, mid<span class="number">-1</span>) <span class="keyword">and</span> recur(mid, j<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, len(postorder)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-15-二进制中1的个数-力扣（LeetCode）"><a href="#剑指-Offer-15-二进制中1的个数-力扣（LeetCode）" class="headerlink" title="剑指 Offer 15. 二进制中1的个数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 15. 二进制中1的个数 - 力扣（LeetCode）</a></h4><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <a href="http://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="noopener">汉明重量</a>).）。 </p><p>提示：</p><p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">11</span> (控制台输入 <span class="number">00000000000000000000000000001011</span>)</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：输入的二进制串 <span class="number">00000000000000000000000000001011</span> 中，共有三位为 '<span class="number">1</span>'。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4294967293</span> (控制台输入 <span class="number">11111111111111111111111111111101</span>，部分语言中 n = <span class="number">-3</span>）</span><br><span class="line">输出：<span class="number">31</span></span><br><span class="line">解释：输入的二进制串 <span class="number">11111111111111111111111111111101</span> 中，共有 <span class="number">31</span> 位为 '<span class="number">1</span>'。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>位运算，每次去掉n二进制最左边的1，然后ans加1，直到n为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            n &amp;= (n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-65-不用加减乘除做加法-力扣（LeetCode）"><a href="#剑指-Offer-65-不用加减乘除做加法-力扣（LeetCode）" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">剑指 Offer 65. 不用加减乘除做加法 - 力扣（LeetCode）</a></h4><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。 </p><p><strong>示例:</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="selector-tag">a</span> = <span class="number">1</span>, <span class="selector-tag">b</span> = <span class="number">1</span></span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>位运算：</p><p>二进制每位相加，需要考虑加之后的本位和，以及进位数。本位和的结果为相加的两位的异或，进位数只有当都为1时才会进位1，所以为与的运算。</p><p>求a+b， 本和为则为 n = a ^ b，a异或b，进位和则为 c = a &amp; b &lt;&lt; 1，a与b的结果左移一位。</p><p>所以a+b可以等价于n+c，然后继续进行上面的操作，直到进位和都为0，即c = 0。</p><p><strong>注意</strong></p><p>python中负数的存储规则</p><p>python中的负数也是以补码的形式存储，因此负数的高位无限补1，正数的高位无限补0。不能直接用原始的负数进行位运算，因为负数的高位是无数个1，与高位是无穷个0的正数做运算可能会出错。</p><p>所以需要手动获取负数的补码，并把高位置为0，将负数变为一个正数，即把原数字与0xffffffff做位与运算，</p><p>最后的结果怎么判断是负数呢？</p><p>因为对于32位的整数，最前面的一位是符号位，因此最大的正整数只可能是0x7fffffff。大于0x7fffffff的都为负数，因为负数的第一位符号位为1。</p><p>所以需要将负数的补码还原成原码，将以补码形式表示的负数转换成十进制输出，只需要将负数的补码的高位全部还原为1，因为前面我们将高位全置为0了。所以只需要将负数高于32位的数位取反就行，但是直接取反会将后面的32也取反，所以我们先将后面32位取反，然后再全部取反，即可以实现只对前面的32位取反。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, a: int, b: int)</span> -&gt; int:</span></span><br><span class="line">        x = <span class="number">0xffffffff</span></span><br><span class="line">        a, b = a &amp; x, b &amp; x</span><br><span class="line">        <span class="keyword">while</span> b:</span><br><span class="line">            a, b = a ^ b, (a &amp; b) &lt;&lt; <span class="number">1</span> &amp; x</span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt;= <span class="number">0x7fffffff</span> <span class="keyword">else</span> ~(a ^ x)</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-56-I-数组中数字出现的次数-力扣（LeetCode）"><a href="#剑指-Offer-56-I-数组中数字出现的次数-力扣（LeetCode）" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 56 - I. 数组中数字出现的次数 - 力扣（LeetCode）</a></h4><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 </p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">6</span>] 或 [<span class="number">6</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">10</span>] 或 [<span class="number">10</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>异或运算：任何数与0异或运算都等于他本身，两个相同的数异或运算为0，而且异或运算满足交换律，所以如果只有一个出现一次的数，可以依次将数组中的元素与0进行异或运算，最后的结果一定是那个出现一次的数。</p><p>但是这个题有两个只出现一次的数。</p><p>所以需要通过一个数将这两个只出现一次的数分隔开，然后形成两个子数组，每个数组里面包含一个只出现一次的数。</p><p>假设那两个只出现一次的数分别为x，y，将数组的所有元素异或运算一次之后，最后的结果肯定是x与y异或的结果，如果其中某一位为1，则说明x和y在这位上的值肯定不同，一个为0一个为1，所以找出这一位出来，而其他相同的两个数在这位肯定都是相同的，所以就依据这一位x和y的值不同就可以把x和y分隔开来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumbers</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        x, y, n, m = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            n = n ^ i</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span>(n &amp; m):  <span class="comment"># 从右向左找出第一个为1的那一位。</span></span><br><span class="line">            m &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i &amp; m:</span><br><span class="line">                x ^= i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y ^= i</span><br><span class="line">        <span class="keyword">return</span> x, y</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-56-II-数组中数字出现的次数-II-力扣（LeetCode）"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II-力扣（LeetCode）" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">剑指 Offer 56 - II. 数组中数字出现的次数 II - 力扣（LeetCode）</a></h4><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 </p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p><a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/mian-shi-ti-56-ii-shu-zu-zhong-shu-zi-chu-xian-d-4/" target="_blank" rel="noopener">面试题56 - II. 数组中数字出现的次数 II（位运算 + 有限状态自动机，清晰图解） - 数组中数字出现的次数 II - 力扣（LeetCode）</a> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        ones, twos = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            ones = ones ^ n &amp; ~twos</span><br><span class="line">            twos = twos ^ n &amp; ~ones</span><br><span class="line">        <span class="keyword">return</span> ones</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-39-数组中出现次数超过一半的数字-力扣（LeetCode）"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字-力扣（LeetCode）" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 39. 数组中出现次数超过一半的数字 - 力扣（LeetCode）</a></h4><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 </p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。 </p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span></span><br><span class="line"><span class="section">输出: 2</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p><strong>题目保证有解</strong></p><ol><li>排序，排完序之后最中间的一定是次数超过一半的数字。</li><li>找出众数，该众数一定是次数超过一半的数字，找出众数的方法：先初始化存众数和次数的两个变量pre和count。遍历数组，当count为0时，说明目前还没有众数，把该数存进pre中并将count置为1,。如果不为0，说明已经有众数了，判断当前数是否与众数相等，如果是，数量加1，不是就数量减1。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> sorted(nums)[len(nums) &gt;&gt; <span class="number">1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        pre, count = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> count:</span><br><span class="line">                count += <span class="number">1</span> <span class="keyword">if</span> n == pre <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre, count = n, <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-66-构建乘积数组-力扣（LeetCode）"><a href="#剑指-Offer-66-构建乘积数组-力扣（LeetCode）" class="headerlink" title="剑指 Offer 66. 构建乘积数组 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/" target="_blank" rel="noopener">剑指 Offer 66. 构建乘积数组 - 力扣（LeetCode）</a></h4><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p><p><strong>示例:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">[1,2,3,4,5]</span></span><br><span class="line">输出: <span class="string">[120,60,40,30,24]</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>每个数等于它右边所有的乘积乘上左边所有的乘积。所以先用一个数组存下来从左到右依次的乘积，然后从右到左遍历，用一个变量存下来从右到左的乘积，依次得到结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructArr</span><span class="params">(self, a: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> a: <span class="keyword">return</span> []</span><br><span class="line">        arr = [a[<span class="number">0</span>]] + [<span class="number">1</span>] * (len(a)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):</span><br><span class="line">            arr[i] = arr[i<span class="number">-1</span>] * a[i]</span><br><span class="line">        b = [<span class="number">1</span>] * len(a)</span><br><span class="line">        temp = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            b[i] = arr[i<span class="number">-1</span>] * temp</span><br><span class="line">            temp *= a[i]</span><br><span class="line">        b[<span class="number">0</span>] = temp</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><p>其实上面还可以优化，直接将结果b存到arr中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructArr</span><span class="params">(self, a: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> a: <span class="keyword">return</span> []</span><br><span class="line">        arr = [a[<span class="number">0</span>]] + [<span class="number">1</span>] * (len(a)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):</span><br><span class="line">            arr[i] = arr[i<span class="number">-1</span>] * a[i]</span><br><span class="line">        temp = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            arr[i] = arr[i<span class="number">-1</span>] * temp</span><br><span class="line">            temp *= a[i]</span><br><span class="line">        arr[<span class="number">0</span>] = temp</span><br><span class="line">        <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-14-I-剪绳子-力扣（LeetCode）"><a href="#剑指-Offer-14-I-剪绳子-力扣（LeetCode）" class="headerlink" title="剑指 Offer 14- I. 剪绳子 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 14- I. 剪绳子 - 力扣（LeetCode）</a></h4><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释:<span class="number"> 2 </span>=<span class="number"> 1 </span>+ 1,<span class="number"> 1 </span>×<span class="number"> 1 </span>= 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释:<span class="number"> 10 </span>=<span class="number"> 3 </span>+<span class="number"> 3 </span>+ 4,<span class="number"> 3 </span>×<span class="number"> 3 </span>×<span class="number"> 4 </span>= 36</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>根据数据推导可以发现当分成若干个长度为3的绳子的时候乘积最大，而最后一个长度为3的绳子需要拿出来，与最后的余数进行特殊的判断。</p><ul><li>余1：与前面的3，分成两个长度为2，乘积为4</li><li>余2：不变，还是与前面的3相乘</li><li>余3：直接乘上前面的数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span>  reduce(<span class="keyword">lambda</span> x, y: x * y, [<span class="number">3</span>] * ((n // <span class="number">3</span>) - <span class="number">1</span>) + [<span class="number">4</span> + <span class="number">2</span> * (n % <span class="number">3</span> - <span class="number">1</span>) <span class="keyword">if</span> n % <span class="number">3</span> <span class="keyword">else</span> <span class="number">3</span>]) <span class="keyword">if</span> n &gt; <span class="number">3</span> <span class="keyword">else</span> n<span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="number">3</span> ** (n // <span class="number">3</span> - <span class="number">1</span>) * (<span class="number">4</span> + <span class="number">2</span> * (n % <span class="number">3</span> - <span class="number">1</span>) <span class="keyword">if</span> n % <span class="number">3</span> <span class="keyword">else</span> <span class="number">3</span>) <span class="keyword">if</span> n &gt; <span class="number">3</span> <span class="keyword">else</span> n - <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-57-II-和为s的连续正数序列-力扣（LeetCode）"><a href="#剑指-Offer-57-II-和为s的连续正数序列-力扣（LeetCode）" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 57 - II. 和为s的连续正数序列 - 力扣（LeetCode）</a></h4><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="number">9</span></span><br><span class="line">输出：[[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="number">15</span></span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p><strong>题目要求的是连续的正数序列</strong></p><p><em>方法一： 数学方法</em></p><p>假设一个左边界为i，右边界为j的序列满足和为target，则该序列满足等差数列求和：$S_{n}=target=\frac{(i+j)(j-i+1)}{2}$。化简为：$target=\frac{j^{2}+j+i-i^{2}}{2}$。</p><p>化简为：$j^{2}+j+\left(i-2 \times target-i^{2}\right)=0$。用求根公式可得：$j=\frac{-1 \pm \sqrt{1-4 \times\left(i-2 \times target-i^{2}\right)}}{2}$。又因为j肯定是比i大的。所以负号排除，则<br>$$<br>j=\frac{-1+\sqrt{1-4 \times\left(i-2 \times target-i^{2}\right)}}{2}<br>$$<br>则只需要列举出i，便可以通过公式求出j，然后判断j是否为整数，若为整数则该序列为target。又因为序列至少包含两个数，所以只需要枚举到target/2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContinuousSequence</span><span class="params">(self, target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, target // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">            j = (<span class="number">-1</span> + (<span class="number">1</span> - <span class="number">4</span> * (i - <span class="number">2</span> * target - i ** <span class="number">2</span>)) ** <span class="number">0.5</span>) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; j <span class="keyword">and</span> j == int(j):</span><br><span class="line">                res.append(list(range(i, int(j) + <span class="number">1</span>)))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><em>方法二：滑动窗口法</em></p><p>定义一个左右窗口数组的左右边界，left 和 right。每次继续这个滑动窗口的和：</p><ul><li>若和为target，则为结果保存，然后将左边界left加1，因为以left开头的序列的结果已经找到了</li><li>若和小于target，则说明和小了，将right加1，扩大滑动窗口。</li><li>若和大于target，则说明和大了，将left减1，减小滑动窗口。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContinuousSequence</span><span class="params">(self, target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        left, right, res = <span class="number">1</span>, <span class="number">2</span>, []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= target // <span class="number">2</span>:</span><br><span class="line">            temp = sum(range(left, right))</span><br><span class="line">            <span class="keyword">if</span> temp == target:</span><br><span class="line">                res.append(list(range(left, right)))</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> temp &lt; target:</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-62-圆圈中最后剩下的数字-力扣（LeetCode）"><a href="#剑指-Offer-62-圆圈中最后剩下的数字-力扣（LeetCode）" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener"><strong>剑指 Offer 62. 圆圈中最后剩下的数字 - 力扣（LeetCode）</strong></a></h4><p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: n = 5, m = 3</span></span><br><span class="line"><span class="section">输出: 3</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: n = 10, m = 17</span></span><br><span class="line"><span class="section">输出: 2</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>约瑟夫环问题：</p><p>动态规划解析：</p><ul><li>状态定义：设[i, m] 的解为 dp[i]；</li><li>转移方程：通过以下方式可从 dp[i-1]递推得到dp[i]；<ul><li><code>dp[i] = (dp[i - 1] + m) % i</code></li></ul></li><li>初始状态：[1, m]问题的解恒为0，即dp[i] = 0</li><li>返回值：返回[n, m]问题的解dp[n]；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastRemaining</span><span class="params">(self, n: int, m: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        f = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            f = (f + m) % i</span><br><span class="line">        <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-29-顺时针打印矩阵-力扣（LeetCode）-1"><a href="#剑指-Offer-29-顺时针打印矩阵-力扣（LeetCode）-1" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">剑指 Offer 29. 顺时针打印矩阵 - 力扣（LeetCode）</a></h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 </p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p><em>方法一：</em></p><p>每次取矩阵的最上面一行，然后再逆时针旋转矩阵90度。直到矩阵为空。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> matrix:</span><br><span class="line">            res.extend(matrix.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">break</span></span><br><span class="line">            matrix = [[row[j] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><em>方法二</em></p><p>定义上下左右四个边界指针，然后依次遍历，保存结果，循环结束条件：当左指针大于右指针，上指针大于下指针时退出循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        left, right, top, bottom = <span class="number">0</span>, len(matrix[<span class="number">0</span>])<span class="number">-1</span>, <span class="number">0</span>, len(matrix)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(left, right + <span class="number">1</span>):</span><br><span class="line">                res.append(matrix[top][i])</span><br><span class="line">            top += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> top &gt; bottom: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(top, bottom+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][right])</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right &lt; left: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(right, left<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                res.append(matrix[bottom][i])</span><br><span class="line">            bottom -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> bottom &lt; top: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(bottom, top<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                res.append(matrix[i][left])</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-31-栈的压入、弹出序列-力扣（LeetCode）"><a href="#剑指-Offer-31-栈的压入、弹出序列-力扣（LeetCode）" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 31. 栈的压入、弹出序列 - 力扣（LeetCode）</a></h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p><strong>示例 1：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], popped = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push<span class="function"><span class="params">(<span class="number">1</span>)</span>, <span class="title">push</span><span class="params">(<span class="number">2</span>)</span>, <span class="title">push</span><span class="params">(<span class="number">3</span>)</span>, <span class="title">push</span><span class="params">(<span class="number">4</span>)</span>, <span class="title">pop</span><span class="params">()</span> -&gt;</span> <span class="number">4</span>,</span><br><span class="line">push<span class="function"><span class="params">(<span class="number">5</span>)</span>, <span class="title">pop</span><span class="params">()</span> -&gt;</span> <span class="number">5</span>, pop<span class="function"><span class="params">()</span> -&gt;</span> <span class="number">3</span>, pop<span class="function"><span class="params">()</span> -&gt;</span> <span class="number">2</span>, pop<span class="function"><span class="params">()</span> -&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], popped = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：false</span><br><span class="line">解释：<span class="number">1</span> 不能在 <span class="number">2</span> 之前弹出。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>定义一个数组arr来模拟栈的压入和弹出。然后用一个poped的下标指针index指向当前出栈了哪些元素，最后若该index指针等于len(poped)则说明全部可以出栈。</p><p>遍历pushed数组，并将遍历到的数压入arr中，判断当前的数是否与poped数组的下标为index的数相同，若相同则说明要出栈，此时将相同的全部出栈，arr执行pop()操作，poped数组执行index+1的操作，然后继续遍历pushed数组，指导遍历结束判断index是否为len(poped)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span><span class="params">(self, pushed: List[int], popped: List[int])</span> -&gt; bool:</span></span><br><span class="line">        arr = []</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(pushed)):</span><br><span class="line">            arr.append(pushed[i])</span><br><span class="line">            <span class="keyword">if</span> pushed[i] == popped[index]:</span><br><span class="line">                <span class="keyword">while</span> <span class="number">0</span> &lt;= index &lt; len(popped) <span class="keyword">and</span> arr <span class="keyword">and</span> arr[<span class="number">-1</span>] == popped[index]:</span><br><span class="line">                    arr.pop()</span><br><span class="line">                    index += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> bool( index == len(popped) )</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-67-把字符串转换成整数-力扣（LeetCode）"><a href="#剑指-Offer-67-把字符串转换成整数-力扣（LeetCode）" class="headerlink" title="剑指 Offer 67. 把字符串转换成整数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 67. 把字符串转换成整数 - 力扣（LeetCode）</a></h4><p> 写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: "42"</span></span><br><span class="line"><span class="section">输出: 42</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: "   -42"</span></span><br><span class="line"><span class="section">输出: -42</span></span><br><span class="line"><span class="section">解释: 第一个非空白字符为 '-', 它是一个负号。</span></span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: "4193 with words"</span></span><br><span class="line"><span class="section">输出: 4193</span></span><br><span class="line"><span class="section">解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。</span></span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: "words and 987"</span></span><br><span class="line"><span class="section">输出: 0</span></span><br><span class="line"><span class="section">解释: 第一个非空字符是 'w', 但它不是数字或正、负号。</span></span><br><span class="line">     因此无法执行有效的转换。</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: "-<span class="number">91283472332</span>"</span><br><span class="line">输出: -<span class="number">2147483648</span></span><br><span class="line">解释: 数字 "-<span class="number">91283472332</span>" 超过 <span class="number">32</span> 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−<span class="number">231</span>) 。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><ol><li>去掉字符串的前后空格</li><li>用一个符号变量sign保存数字的符号</li><li>从字符串的头往后面遍历，遇到非数字字符立即退出</li><li>若遇到数字字符：执行res = res * 10 + ord(c) - ord(‘0’)，在执行这句话之前，需要先判断是否越界：<ol><li>先判断res * 10 是否大于int_max</li><li>在判断res * 10 + ord(c) - ord(‘0’)是否越上界或者下界。</li></ol></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strToInt</span><span class="params">(self, str: str)</span> -&gt; int:</span></span><br><span class="line">        str = str.strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> str: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res, i, sign = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        int_max, int_min, buary = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>, <span class="number">-2</span> ** <span class="number">31</span>, <span class="number">2</span> ** <span class="number">31</span> // <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> str[<span class="number">0</span>] == <span class="string">'-'</span>: sign = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> str[<span class="number">0</span>] <span class="keyword">in</span> <span class="string">"+-"</span>: i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> str[i:]:</span><br><span class="line">            <span class="keyword">if</span> c &lt; <span class="string">'0'</span> <span class="keyword">or</span> c &gt; <span class="string">'9'</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> res &gt; buary <span class="keyword">or</span> res == buary <span class="keyword">and</span> c &gt; <span class="string">'7'</span>: </span><br><span class="line">                <span class="keyword">return</span> int_max <span class="keyword">if</span> sign == <span class="number">1</span> <span class="keyword">else</span> int_min</span><br><span class="line">            res = res * <span class="number">10</span> + ord(c) - ord(<span class="string">'0'</span>)</span><br><span class="line">        <span class="keyword">return</span> res * sign</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-20-表示数值的字符串-力扣（LeetCode）"><a href="#剑指-Offer-20-表示数值的字符串-力扣（LeetCode）" class="headerlink" title="剑指 Offer 20. 表示数值的字符串 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 20. 表示数值的字符串 - 力扣（LeetCode）</a></h4><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</p><p>数值（按顺序）可以分成以下几个部分：</p><p>若干空格<br>一个 小数 或者 整数<br>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数<br>若干空格<br>小数（按顺序）可以分成以下几个部分：</p><p>（可选）一个符号字符（’+’ 或 ‘-‘）<br>下述格式之一：<br>至少一位数字，后面跟着一个点 ‘.’<br>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字<br>一个点 ‘.’ ，后面跟着至少一位数字<br>整数（按顺序）可以分成以下几个部分：</p><p>（可选）一个符号字符（’+’ 或 ‘-‘）<br>至少一位数字<br>部分数值列举如下：</p><p>[“+100”, “5e2”, “-123”, “3.1416”, “-1E-16”, “0123”]<br>部分非数值列举如下：</p><p>[“12e”, “1a3.14”, “1.2.3”, “+-5”, “12e+5.4”]</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"0"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"e"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"."</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"    .1  "</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>自动状态机。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        s = s.strip()  <span class="comment"># 去掉首尾空格</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> len(s) == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 判断是否为空</span></span><br><span class="line">        <span class="comment"># 标记是否遇到数字， 小数点，e或者E</span></span><br><span class="line">        isNum, isDot, iseorE = <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'0'</span> &lt;= c &lt;= <span class="string">'9'</span>: isNum = <span class="literal">True</span>  <span class="comment"># 遇到数字，标记遇到数字</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'.'</span>:</span><br><span class="line">                <span class="keyword">if</span> isDot <span class="keyword">or</span> iseorE: <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 判断是否已经遇到小数点，或者是小数点是在e和E之后</span></span><br><span class="line">                isDot = <span class="literal">True</span>  <span class="comment"># 标记已经遇到小数点</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'e'</span> <span class="keyword">or</span> c == <span class="string">'E'</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> isNum <span class="keyword">or</span> iseorE: <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 判断在e和E之前是否遇到了数字或者已经遇到了e和E</span></span><br><span class="line">                iseorE = <span class="literal">True</span>  <span class="comment"># 标记已经遇到了数字</span></span><br><span class="line">                isNum = <span class="literal">False</span>  <span class="comment"># 将数字置为False表示e和E后面要再次遇到数字</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'-'</span> <span class="keyword">or</span> c == <span class="string">'+'</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> (i == <span class="number">0</span> <span class="keyword">or</span> s[i<span class="number">-1</span>] == <span class="string">'e'</span> <span class="keyword">or</span> s[i<span class="number">-1</span>] == <span class="string">'E'</span>): <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 判断正负号是否出现在最前面或者e和E的后面一位</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 遇到非法字符返回False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isNum  <span class="comment"># 最后返回e和E后面是否出现数字。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        states = [</span><br><span class="line">            &#123; <span class="string">' '</span>: <span class="number">0</span>, <span class="string">'s'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">2</span>, <span class="string">'.'</span>: <span class="number">4</span> &#125;, <span class="comment"># 0. start with 'blank'</span></span><br><span class="line">            &#123; <span class="string">'d'</span>: <span class="number">2</span>, <span class="string">'.'</span>: <span class="number">4</span> &#125; ,                <span class="comment"># 1. 'sign' before 'e'</span></span><br><span class="line">            &#123; <span class="string">'d'</span>: <span class="number">2</span>, <span class="string">'.'</span>: <span class="number">3</span>, <span class="string">'e'</span>: <span class="number">5</span>, <span class="string">' '</span>: <span class="number">8</span> &#125;, <span class="comment"># 2. 'digit' before 'dot'</span></span><br><span class="line">            &#123; <span class="string">'d'</span>: <span class="number">3</span>, <span class="string">'e'</span>: <span class="number">5</span>, <span class="string">' '</span>: <span class="number">8</span> &#125;,         <span class="comment"># 3. 'digit' after 'dot'</span></span><br><span class="line">            &#123; <span class="string">'d'</span>: <span class="number">3</span> &#125;,                         <span class="comment"># 4. 'digit' after 'dot' (‘blank’ before 'dot')</span></span><br><span class="line">            &#123; <span class="string">'s'</span>: <span class="number">6</span>, <span class="string">'d'</span>: <span class="number">7</span> &#125;,                 <span class="comment"># 5. 'e'</span></span><br><span class="line">            &#123; <span class="string">'d'</span>: <span class="number">7</span> &#125;,                         <span class="comment"># 6. 'sign' after 'e'</span></span><br><span class="line">            &#123; <span class="string">'d'</span>: <span class="number">7</span>, <span class="string">' '</span>: <span class="number">8</span> &#125;,                 <span class="comment"># 7. 'digit' after 'e'</span></span><br><span class="line">            &#123; <span class="string">' '</span>: <span class="number">8</span> &#125;                          <span class="comment"># 8. end with 'blank'</span></span><br><span class="line">        ]</span><br><span class="line">        p = <span class="number">0</span>                           <span class="comment"># start with state 0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'0'</span> &lt;= c &lt;= <span class="string">'9'</span>: t = <span class="string">'d'</span> <span class="comment"># digit</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">"+-"</span>: t = <span class="string">'s'</span>     <span class="comment"># sign</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">"eE"</span>: t = <span class="string">'e'</span>     <span class="comment"># e or E</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">". "</span>: t = c       <span class="comment"># dot, blank</span></span><br><span class="line">            <span class="keyword">else</span>: t = <span class="string">'?'</span>               <span class="comment"># unknown</span></span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">not</span> <span class="keyword">in</span> states[p]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            p = states[p][t]</span><br><span class="line">        <span class="keyword">return</span> p <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/mian-shi-ti<span class="number">-20</span>-biao-shi-shu-zhi-de-zi-fu-chuan-y<span class="number">-2</span>/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-59-I-滑动窗口的最大值-力扣（LeetCode）"><a href="#剑指-Offer-59-I-滑动窗口的最大值-力扣（LeetCode）" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - I. 滑动窗口的最大值 - 力扣（LeetCode）</a></h4><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。 </p><p><strong>示例</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,<span class="string">-1</span>,<span class="string">-3</span>,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  <span class="string">-1</span>] <span class="string">-3</span>  5  3  6  7       3</span><br><span class="line"> 1 [3  <span class="string">-1</span>  <span class="string">-3</span>] 5  3  6  7       3</span><br><span class="line"> 1  3 [<span class="string">-1</span>  <span class="string">-3</span>  5] 3  6  7       5</span><br><span class="line"> 1  3  <span class="string">-1</span> [<span class="string">-3</span>  5  3] 6  7       5</span><br><span class="line"> 1  3  <span class="string">-1</span>  <span class="string">-3</span> [5  3  6] 7       6</span><br><span class="line"> 1  3  <span class="string">-1</span>  <span class="string">-3</span>  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p><em>方法一</em></p><p>直接遍历0到i-k，然后每次取最大值，时间复杂度较大O(nk)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - k + <span class="number">1</span>):</span><br><span class="line">            res.append(max(nums[i:(i + k)]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><em>方法二</em></p><p>维护一个双向队列，里面从0开始往后，是一个非递增的数列，即0处保存的肯定是当前窗口最大数列，后面的每个数都比这个数小或者相等。然后每次向后面滑的过程中，先判断队首0处的最大值是不是等于左边滑出去的那个值，如果是，应该去掉。然后在从队列的尾部往前遍历，如果是小于当前要插入进来的值时，就应该去掉，因为待插进来的这个值比这些值大，去掉之后再把当前的值插入到队尾，保持双向队列的非递增特性。最后再把队首0位置处的值插入到res中。注意前面i&lt;k部分的时候还没有形成窗口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> []</span><br><span class="line">        deque = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> deque[<span class="number">-1</span>] &lt; nums[i]:</span><br><span class="line">                deque.pop()</span><br><span class="line">            deque.append(nums[i])</span><br><span class="line">        res.append(deque[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> deque[<span class="number">0</span>] == nums[i - k]:</span><br><span class="line">                deque.popleft()</span><br><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> deque[<span class="number">-1</span>] &lt; nums[i]:</span><br><span class="line">                deque.pop()</span><br><span class="line">            deque.append(nums[i])</span><br><span class="line">            res.append(deque[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-59-II-队列的最大值-力扣（LeetCode）"><a href="#剑指-Offer-59-II-队列的最大值-力扣（LeetCode）" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - II. 队列的最大值 - 力扣（LeetCode）</a></h4><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[<span class="string">"MaxQueue"</span>,<span class="string">"push_back"</span>,<span class="string">"push_back"</span>,<span class="string">"max_value"</span>,<span class="string">"pop_front"</span>,<span class="string">"max_value"</span>]</span><br><span class="line">[[],[<span class="number">1</span>],[<span class="number">2</span>],[],[],[]]</span><br><span class="line">输出: [null,null,null,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[<span class="string">"MaxQueue"</span>,<span class="string">"pop_front"</span>,<span class="string">"max_value"</span>]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,<span class="number">-1</span>,<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>定义一个双向队列，队首用来保存队列的最大值，并且从队首到队尾为一个非递增数列（可以递减也可以相等），则每次pop的时候需要判断pop掉的是不是最大值，如果是，则需要将最大值的双向队列也pop掉，push的时候，则需要判断双向队列的队尾是不是比当前待插入的值小，如果小，则可以直接将这些值pop掉，即保持双向队列的非递增数列，然后最大值则只需要返回这个双向队列的队首就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.deque_max = collections.deque()</span><br><span class="line">        self.deque = collections.deque()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_value</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.deque_max: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self.deque_max[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push_back</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.deque.append(value)</span><br><span class="line">        <span class="keyword">while</span> self.deque_max <span class="keyword">and</span> self.deque_max[<span class="number">-1</span>] &lt; value:</span><br><span class="line">            self.deque_max.pop()</span><br><span class="line">        self.deque_max.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_front</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.deque: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        temp = self.deque.popleft()</span><br><span class="line">        <span class="keyword">if</span> self.deque_max[<span class="number">0</span>] == temp:</span><br><span class="line">            self.deque_max.popleft()</span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MaxQueue()</span></span><br><span class="line"><span class="comment"># param_1 = obj.max_value()</span></span><br><span class="line"><span class="comment"># obj.push_back(value)</span></span><br><span class="line"><span class="comment"># param_3 = obj.pop_front()</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-38-字符串的排列-力扣（LeetCode）"><a href="#剑指-Offer-38-字符串的排列-力扣（LeetCode）" class="headerlink" title="剑指 Offer 38. 字符串的排列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 38. 字符串的排列 - 力扣（LeetCode）</a></h4><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p> <strong>示例:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"abc"</span></span><br><span class="line">输出：[<span class="string">"abc"</span>,<span class="string">"acb"</span>,<span class="string">"bac"</span>,<span class="string">"bca"</span>,<span class="string">"cab"</span>,<span class="string">"cba"</span>]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>1 &lt;= s 的长度 &lt;= 8</code></p><p><strong>思路</strong></p><p>回溯法：</p><ol><li>终止条件：当<code>x = len(c) - 1</code>时，代表所有位已固定，则将当前组合转化为字符串并加入到res中，并返回。</li><li>递推参数：当前固定位的下标x；</li><li>递推工作：初始化一个set，用于排除重复的字符；将第x位字符与i属于[x, len(c)]字符分别交换，并进入下一层递归。<ol><li>剪枝： 若c[i]在Set中，代表其是重复字符，因此剪枝。</li><li>将c[i]加入set中，以便之后遇到重复字符时剪枝。</li><li>固定字符：将字符c[i]和c[x]交换，即固定c[i]为当前位字符。</li><li>开启下层递归：调用<code>dfs(x+1)</code>,即开始固定第x+1个字符；</li><li>还原交换：将字符c[i]和c[x]交换（还原之前的交换）</li></ol></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        c, res = list(s), []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x == len(c) - <span class="number">1</span>:</span><br><span class="line">                res.append(<span class="string">""</span>.join(c))</span><br><span class="line">            d = set()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(x, len(c)):</span><br><span class="line">                <span class="keyword">if</span> c[i] <span class="keyword">in</span> d: <span class="keyword">continue</span></span><br><span class="line">                d.add(c[i])</span><br><span class="line">                c[x], c[i] = c[i], c[x]</span><br><span class="line">                dfs(x + <span class="number">1</span>)</span><br><span class="line">                c[x], c[i] = c[i], c[x]</span><br><span class="line">            </span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-37-序列化二叉树-力扣（LeetCode）"><a href="#剑指-Offer-37-序列化二叉树-力扣（LeetCode）" class="headerlink" title="剑指 Offer 37. 序列化二叉树 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 37. 序列化二叉树 - 力扣（LeetCode）</a></h4><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p>提示：输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>示例：</strong> </p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg" alt="img"> </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,null,null,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,null,null,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>序列化：用一个双向队列保存每一层的所有节点，如果节点不为null，则将当前节点的值加入到res中，并且把他的左右子节点插入到双向队列的末尾，如果节点为null，则说明当前层的这个节点已经为null，所以直接把null加入到res中就行。</p><p>反序列化：同样用一个双向队列保存每一层的所有节点，并把当前的根节点插入到双向队列中，并且定义一个指针指向当前要处理data中的哪一个值，然后进入循环，只有双向队列不为空，就每次popleft出来一个，此时第一个data[i]表示的当前节点的左节点，然后i加1，表示当前节点的右节点，如果data[i]有值，说明当前节点有左右子节点，插入到双向队列中并且，构建左右子节点的关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""Encodes a tree to a single string.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        deque = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line">        deque.append(root)</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            node = deque.popleft()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                res.append(str(node.val))</span><br><span class="line">                deque.append(node.left)</span><br><span class="line">                deque.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="string">"null"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'['</span> + <span class="string">","</span>.join(res) + <span class="string">']'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        deque = collections.deque()</span><br><span class="line">        data, i = data[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">','</span>), <span class="number">1</span></span><br><span class="line">        root = TreeNode(int(data[<span class="number">0</span>]))</span><br><span class="line">        deque.append(root)</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            node = deque.popleft()</span><br><span class="line">            <span class="keyword">if</span> data[i] != <span class="string">"null"</span>:</span><br><span class="line">                node.left = TreeNode(int(data[i]))</span><br><span class="line">                deque.append(node.left)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> data[i] != <span class="string">"null"</span>:</span><br><span class="line">                node.right = TreeNode(int(data[i]))</span><br><span class="line">                deque.append(node.right)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># codec = Codec()</span></span><br><span class="line"><span class="comment"># codec.deserialize(codec.serialize(root))</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-19-正则表达式匹配-力扣（LeetCode）"><a href="#剑指-Offer-19-正则表达式匹配-力扣（LeetCode）" class="headerlink" title="剑指 Offer 19. 正则表达式匹配 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">剑指 Offer 19. 正则表达式匹配 - 力扣（LeetCode）</a></h4><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入:</span></span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"a"</span></span><br><span class="line"><span class="section">输出: false</span></span><br><span class="line"><span class="section">解释: "a" 无法匹配 "aa" 整个字符串。</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入:</span></span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"a*"</span></span><br><span class="line"><span class="section">输出: true</span></span><br><span class="line"><span class="section">解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。</span></span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入:</span></span><br><span class="line">s = <span class="string">"ab"</span></span><br><span class="line">p = <span class="string">".*"</span></span><br><span class="line"><span class="section">输出: true</span></span><br><span class="line"><span class="section">解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。</span></span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入:</span></span><br><span class="line">s = <span class="string">"aab"</span></span><br><span class="line">p = <span class="string">"cab"</span></span><br><span class="line"><span class="section">输出: true</span></span><br><span class="line"><span class="section">解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。</span></span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入:</span></span><br><span class="line">s = <span class="string">"mississippi"</span></span><br><span class="line">p = <span class="string">"mis*is*p*."</span></span><br><span class="line"><span class="section">输出: false</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>设dp数组dp(i, j)表示的含义是s的前i个字符与p的前j个字符是否匹配。</p><p>关注正则表达式p，对于每个字符，可能出现三种情况，分别是正常字符，’.’或者’*’。</p><ol><li>当为正常字符，那就看s[n - 1]是否等于p[m - 1]，相等则看前面的是否匹配，这就是子问题。</li><li>当为’.’时，它能匹配任意字符，直接看前面的字符。</li><li>当为’*’时，代表p[m - 2] = c 可以重复0次或者多次，他们是一个整体。<ol><li>当s[n - 1] 是0 个c，p的最后两个字符就废了，能够匹配取决于s的0到n-1与p的0到m-3是否匹配。</li><li>当s[n - 1] 是多个c中的最后一个（这种情况必须s[n - 1] = c 或者 c=’.’），所以匹配完往前面挪一个，p继续匹配，因为可以匹配多个，继续看s的0到n-2和p的0到m-1是否匹配。</li></ol></li></ol><p>转移方程：</p><ul><li>对于前面两个情况，可以合并成一种情况<code>dp[i][j] =dp[i-1][j-1]</code>。</li><li>对于第三种情况，对于<code>c*</code>分为看和不看两种情况：<ul><li>不看：直接去掉p后面的两个。<code>dp[i][j] = dp[i][j-2]</code></li><li>看：正则串不动，主串s前移一个，<code>dp[i][j] = dp[i-1][j]</code>。</li></ul></li></ul><p>初始条件：</p><p>特判：需要考虑空串和空正则。</p><ol><li>空串和空正则是匹配的，<code>dp[0][0] = True</code>。</li><li>空串和非空正则，不能直接定义True或者False， 需要计算出来，如(s = “”, p = “a <em> b </em> c *”)</li><li>非空串和空正则是不匹配的，<code>dp[1][0] = ... = dp[n][0] = False</code>。</li><li>非空串和非空正则，计算。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        s, p = list(s), list(p)</span><br><span class="line">        dp = [[<span class="literal">False</span>] * (len(p) + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s) + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(p) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = bool(i == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> p[j - <span class="number">1</span>] != <span class="string">'*'</span>:</span><br><span class="line">                        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> (p[j - <span class="number">1</span>] == s[i - <span class="number">1</span>] <span class="keyword">or</span> p[j - <span class="number">1</span>] == <span class="string">'.'</span>):</span><br><span class="line">                            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> j &gt;= <span class="number">2</span>:</span><br><span class="line">                            dp[i][j] = dp[i][j] <span class="keyword">or</span> dp[i][j - <span class="number">2</span>]</span><br><span class="line">                        <span class="keyword">if</span> i &gt;= <span class="number">1</span> <span class="keyword">and</span> j &gt;= <span class="number">2</span> <span class="keyword">and</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] <span class="keyword">or</span> p[j - <span class="number">2</span>] == <span class="string">'.'</span>):</span><br><span class="line">                            dp[i][j] = dp[i][j] <span class="keyword">or</span> dp[i - <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[len(s)][len(p)]</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-49-丑数-力扣（LeetCode）"><a href="#剑指-Offer-49-丑数-力扣（LeetCode）" class="headerlink" title="剑指 Offer 49. 丑数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/chou-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 49. 丑数 - 力扣（LeetCode）</a></h4><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。 </p><p><strong>示例1</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: n = 10</span></span><br><span class="line"><span class="section">输出: 12</span></span><br><span class="line"><span class="section">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span></span><br></pre></td></tr></table></figure><p><strong>思路: (</strong><a href="https://leetcode.cn/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/" target="_blank" rel="noopener">剑指 Offer 49. 丑数（动态规划，清晰图解） - 丑数 - 力扣（LeetCode）</a> <strong>)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp, a, b, c = [<span class="number">0</span>] * n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[i] = min(dp[a] * <span class="number">2</span>, dp[b] * <span class="number">3</span>, dp[c] * <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">if</span> dp[i] == dp[a] * <span class="number">2</span>: a += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] == dp[b] * <span class="number">3</span>: b += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] == dp[c] * <span class="number">5</span>: c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-60-n个骰子的点数-力扣（LeetCode）"><a href="#剑指-Offer-60-n个骰子的点数-力扣（LeetCode）" class="headerlink" title="剑指 Offer 60. n个骰子的点数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 60. n个骰子的点数 - 力扣（LeetCode）</a></h4><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p><p><strong>示例 1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span></span><br><span class="line">输出: [<span class="number">0.16667,0</span>.<span class="number">16667,0</span>.<span class="number">16667,0</span>.<span class="number">16667,0</span>.<span class="number">16667,0</span>.<span class="number">16667</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">2</span></span><br><span class="line">输出: [<span class="number">0.02778,0</span>.<span class="number">05556,0</span>.<span class="number">08333,0</span>.<span class="number">11111,0</span>.<span class="number">13889,0</span>.<span class="number">16667,0</span>.<span class="number">13889,0</span>.<span class="number">11111,0</span>.<span class="number">08333,0</span>.<span class="number">05556,0</span>.<span class="number">02778</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>设输入n个骰子的解为f(n)，其中[点数和]x的概率为f(n, x)</p><p>假设已知n-1个骰子的解f(n-1)，此时添加一枚骰子，求n个骰子的点数和为x的概率为f(n, x)。</p><p>当添加骰子的点数为1时，前n-1个骰子的点数和应为x-1，同理后面的，以此类推直到此骰子点数和为6，将这6种情况的概率相加，即可得到概率为f(n, x)。递推公式如下：<br>$$<br>f(n,x) = \sum_{i=1}^{6} f(n-1,x-i) \times \frac{1}{6}<br>$$<br>所以可以根据f(1)递推出f(n)，但是会出现x-i，会出现负的下标，这样考虑较为复杂，所以可以反过来考虑</p><p>即f(n-1)中的每个x的值可能会影响f(n)中的x+1到x+6这六个值，所以把这六个值都再乘以1/6。</p><p>具体题解：<a href="https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/solution/jian-zhi-offer-60-n-ge-tou-zi-de-dian-sh-z36d/" target="_blank" rel="noopener">剑指 Offer 60. n 个骰子的点数（动态规划，清晰图解） - n个骰子的点数 - 力扣（LeetCode）</a> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dicesProbability</span><span class="params">(self, n: int)</span> -&gt; List[float]:</span></span><br><span class="line">        dp = [<span class="number">1</span>/<span class="number">6</span>] * <span class="number">6</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            temp = [<span class="number">0</span>] * (<span class="number">5</span> * i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(dp)):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">                    temp[j + k] += dp[j] / <span class="number">6</span></span><br><span class="line">            dp = temp</span><br><span class="line">        <span class="keyword">return</span> dp</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-17-打印从1到最大的n位数-力扣（LeetCode）"><a href="#剑指-Offer-17-打印从1到最大的n位数-力扣（LeetCode）" class="headerlink" title="剑指 Offer 17. 打印从1到最大的n位数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 17. 打印从1到最大的n位数 - 力扣（LeetCode）</a></h4><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 </p><p><strong>示例 1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = <span class="number">1</span></span><br><span class="line">输出: [<span class="number">1,2,3,4</span>,<span class="number">5,6,7,8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>正常情况下需要考虑大数越界的情况，所以应该转换为字符串来处理。</p><p>题解：<a href="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution/mian-shi-ti-17-da-yin-cong-1-dao-zui-da-de-n-wei-2/" target="_blank" rel="noopener">面试题17. 打印从 1 到最大的 n 位数（分治算法 / 全排列，清晰图解） - 打印从1到最大的n位数 - 力扣（LeetCode）</a> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">return</span> list(range(<span class="number">1</span>, <span class="number">10</span>**n))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span><span class="params">(self, n: int)</span> -&gt; [int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x == n:</span><br><span class="line">                s = <span class="string">''</span>.join(num[self.start:])</span><br><span class="line">                <span class="keyword">if</span> s != <span class="string">'0'</span>: res.append(int(s))</span><br><span class="line">                <span class="keyword">if</span> n - self.start == self.nine: self.start -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">9</span>: self.nine += <span class="number">1</span></span><br><span class="line">                num[x] = str(i)</span><br><span class="line">                dfs(x + <span class="number">1</span>)</span><br><span class="line">            self.nine -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        num, res = [<span class="string">'0'</span>] * n, []</span><br><span class="line">        self.nine = <span class="number">0</span></span><br><span class="line">        self.start = n - <span class="number">1</span></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https://leetcode.cn/problems/da-yin-cong<span class="number">-1</span>dao-zui-da-de-nwei-shu-lcof/solution/mian-shi-ti<span class="number">-17</span>-da-yin-cong<span class="number">-1</span>-dao-zui-da-de-n-wei<span class="number">-2</span>/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-51-数组中的逆序对-力扣（LeetCode）"><a href="#剑指-Offer-51-数组中的逆序对-力扣（LeetCode）" class="headerlink" title="剑指 Offer 51. 数组中的逆序对 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">剑指 Offer 51. 数组中的逆序对 - 力扣（LeetCode）</a></h4><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [7,5,6,4]</span></span><br><span class="line"><span class="section">输出: 5</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>逆序对都与归并排序有关，归并排序与逆序对统计：</p><ol><li>终止条件： 当l &gt;= r时，代表子数组长度为1，终止划分；</li><li>递归划分：计算数组中点m，递归划分左子数组merge_sort(l, m)和右子数组merge_sort(m+1，r)；</li><li>合并与逆序对统计：<ol><li>暂存数组nums闭区间[i, r]内的元素至辅助数组temp；</li><li>循环合并：设置双指针i，j分别指向左/右子数组的首元素；<ul><li>当i = m + 1时，说明左子数组已经全部合并完成。</li><li>否则，当j = r + 1时，说明右子数组已经全部合并完成。</li><li>否则，当temp[i] &lt;= temp[j]时，说明左子数组的i元素比右子数组的j元素小，把左子数组的i元素加到nums中。</li><li>否则，当temp[i] &gt; temp[j]时，说明左子数组的i元素比右子数组的j元素大，此时除了把右子数组的j元素加到nums中之外，还要统计逆序对，因为左子数组是有序的，所以左子数组的i后面的元素都比右子数组的j元素大，所以逆序对为m - i + 1个。</li></ul></li></ol></li><li>返回值：返回直到目前的逆序对总数res。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">marge_sort</span><span class="params">(l, r)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> l &gt;= r: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            m = (l + r) // <span class="number">2</span></span><br><span class="line">            res = marge_sort(l, m) + marge_sort(m + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line">            i, j = l, m + <span class="number">1</span></span><br><span class="line">            temp[l:(r + <span class="number">1</span>)] = nums[l:(r + <span class="number">1</span>)]</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(l, r + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == m + <span class="number">1</span>:</span><br><span class="line">                    nums[k] = temp[j]</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> j == r + <span class="number">1</span> <span class="keyword">or</span> temp[i] &lt;= temp[j]:</span><br><span class="line">                    nums[k] = temp[i]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nums[k] = temp[j]</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    res += m - i + <span class="number">1</span>  <span class="comment"># i后面的都比当前的这个j大，因为l到m是有序的。</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        temp = [<span class="number">0</span>] * len(nums)</span><br><span class="line">        <span class="keyword">return</span> marge_sort(<span class="number">0</span>, len(nums)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-14-II-剪绳子-II-力扣（LeetCode）"><a href="#剑指-Offer-14-II-剪绳子-II-力扣（LeetCode）" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/" target="_blank" rel="noopener">剑指 Offer 14- II. 剪绳子 II - 力扣（LeetCode）</a></h4><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释:<span class="number"> 2 </span>=<span class="number"> 1 </span>+ 1,<span class="number"> 1 </span>×<span class="number"> 1 </span>= 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释:<span class="number"> 10 </span>=<span class="number"> 3 </span>+<span class="number"> 3 </span>+ 4,<span class="number"> 3 </span>×<span class="number"> 3 </span>×<span class="number"> 4 </span>= 36</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>思路不变，还是分成3时乘积最大。只不过增加了测试数据，3的多少次幂需要用到快速幂求余。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">3</span>: <span class="keyword">return</span> n<span class="number">-1</span></span><br><span class="line">        a, b, p, res = <span class="number">3</span>, n // <span class="number">3</span> - <span class="number">1</span>, <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> b:</span><br><span class="line">            <span class="keyword">if</span> b &amp; <span class="number">1</span>: res = (res * a) % p</span><br><span class="line">            a = a ** <span class="number">2</span> % p</span><br><span class="line">            b //= <span class="number">2</span></span><br><span class="line">        res = res * (<span class="number">3</span> <span class="keyword">if</span> n % <span class="number">3</span> == <span class="number">0</span> <span class="keyword">else</span> (n % <span class="number">3</span> + <span class="number">1</span>) * <span class="number">2</span>) % p</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-43-1～n-整数中-1-出现的次数-力扣（LeetCode）"><a href="#剑指-Offer-43-1～n-整数中-1-出现的次数-力扣（LeetCode）" class="headerlink" title="剑指 Offer 43. 1～n 整数中 1 出现的次数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 43. 1～n 整数中 1 出现的次数 - 力扣（LeetCode）</a></h4><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">12</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">13</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>设$1 \sim n$的个位、十位、百位、…的1出现次数相加，即为1出现的总次数。</p><p>设数字$n$是个$x$位数，记$n$的第$i$位为$n_{i}$，则可将$n$写为$n_{x}n_{x-1} \dots n_{2}n_{1}$:</p><ul><li>称$n_{i}$为当前位，记为cur</li><li>将$n_{i-1}n_{n-2} \dots n_{2}n_{1}$称为低位，记为low。</li><li>将$n_{x}n_{x-1} \dots x_{i+2}x_{i+1}$称为高位，记为high。</li><li>将$10^{i}$称为 位因子，记为digit。</li></ul><p>根据当前cur值的不同，分为以下三种情况：</p><ol><li>当cur = 0时，此位1的出现次数情况只由高位high决定，计算公式为：$high \times digit$</li><li>当cur = 1时，此位1的出现次数由高位$high$和低位$low$决定，计算公式为：$high \times digit + low + 1$</li><li>当cur = 2…9时，此位1的出现次数只由高位high决定，计算公式为：$(high + 1) \times digit$</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countDigitOne</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        high, low, cur, dig = n // <span class="number">10</span>, <span class="number">0</span>, n % <span class="number">10</span>, <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> high != <span class="number">0</span> <span class="keyword">or</span> cur != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> cur == <span class="number">0</span>: res += high * dig</span><br><span class="line">            <span class="keyword">elif</span> cur == <span class="number">1</span>: res += high * dig + low + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: res += (high + <span class="number">1</span>) * dig</span><br><span class="line">            low += cur * dig</span><br><span class="line">            cur = high % <span class="number">10</span></span><br><span class="line">            high = high // <span class="number">10</span></span><br><span class="line">            dig *= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-44-数字序列中某一位的数字-力扣（LeetCode）"><a href="#剑指-Offer-44-数字序列中某一位的数字-力扣（LeetCode）" class="headerlink" title="剑指 Offer 44. 数字序列中某一位的数字 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 44. 数字序列中某一位的数字 - 力扣（LeetCode）</a></h4><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">11</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>题解：<a href="https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/mian-shi-ti-44-shu-zi-xu-lie-zhong-mou-yi-wei-de-6/" target="_blank" rel="noopener">面试题44. 数字序列中某一位的数字（迭代 + 求整 / 求余，清晰图解） - 数字序列中某一位的数字 - 力扣（LeetCode）</a> </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNthDigit</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        digit, start, count = <span class="number">1</span>, <span class="number">1</span>, <span class="number">9</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; count: <span class="comment"># 1.</span></span><br><span class="line">            n -= count</span><br><span class="line">            start *= <span class="number">10</span></span><br><span class="line">            digit += <span class="number">1</span></span><br><span class="line">            count = <span class="number">9</span> * start * digit</span><br><span class="line">        num = start + (n - <span class="number">1</span>) // digit <span class="comment"># 2.</span></span><br><span class="line">        <span class="keyword">return</span> int(str(num)[(n - <span class="number">1</span>) % digit]) <span class="comment"># 3.</span></span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/mian-shi-ti<span class="number">-44</span>-shu-zi-xu-lie-zhong-mou-yi-wei-de<span class="number">-6</span>/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;剑指Offer-09-用两个栈实现队列-https-leetcode-cn-com-problems-yong-liang-ge-zhan-shi-xian-dui-lie-lcof&quot;&gt;&lt;a href=&quot;#剑指Offer-09-用两个栈实现队列-https-leetcode-cn-com-problems-yong-liang-ge-zhan-shi-xian-dui-lie-lcof&quot; class=&quot;headerlink&quot; title=&quot;剑指Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/) )&quot;&gt;&lt;/a&gt;&lt;a href=&quot;[剑指 Offer 09. 用两个栈实现队列 - 力扣（LeetCode） (leetcode-cn.com&quot;&gt;剑指Offer 09. 用两个栈实现队列&lt;/a&gt;](&lt;a href=&quot;https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/&lt;/a&gt;) )&lt;/h4&gt;&lt;p&gt;用两个栈实现一个队列。队列的声明如下，请实现它的两个函数&lt;code&gt;appendTail&lt;/code&gt;和&lt;code&gt;deleteHead&lt;/code&gt;，分别完成在队列尾部插入整数和在队列头部删除整数的功能。（若队列中没有元素，&lt;code&gt;deleteHead&lt;/code&gt;操作返回-1）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>U盘安装linux、远程桌面、显卡驱动及conda安装</title>
    <link href="http://yoursite.com/2021/01/30/U%E7%9B%98%E5%AE%89%E8%A3%85linux%E3%80%81%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E3%80%81%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E5%8F%8Aconda%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2021/01/30/U盘安装linux、远程桌面、显卡驱动及conda安装/</id>
    <published>2021-01-30T08:53:43.480Z</published>
    <updated>2021-03-02T08:22:05.625Z</updated>
    
    <content type="html"><![CDATA[<h3 id="服务器U盘安装linux系统"><a href="#服务器U盘安装linux系统" class="headerlink" title="服务器U盘安装linux系统"></a>服务器U盘安装linux系统</h3><p><strong>一、安装环境</strong></p><p>Window 10 系统</p><p>准备工具：</p><p>1、ubuntu系统安装包</p><p>2、一个格式化的16GU盘</p><p><strong>二、安装步骤</strong></p><a id="more"></a><p>1、重启系统，在开机的时候按F12，不同的电脑可能不一样，可自行百度不同型号的电脑如何进入boot界面，按F12之后会进入一下界面。</p><p><div align="center"><img src="/2021/01/30/U盘安装linux、远程桌面、显卡驱动及conda安装/1.JPG" alt></div></p><p>选择自己U盘的名称，然后回车确认。会进入ubuntu的安装界面，选择<code>install ubuntu</code>，这个界面可以会没有，如果没有就直接进入下面这个界面。</p><p><div align="center"><img src="/2021/01/30/U盘安装linux、远程桌面、显卡驱动及conda安装/2.JPG" alt></div></p><p>2、选择右边，拖到最下面，会有   简体中文   ，选择，如图</p><p><div align="center"><img src="/2021/01/30/U盘安装linux、远程桌面、显卡驱动及conda安装/3.JPG" alt></div></p><p>然后确认，会提示准备暗转Ubuntu，这里选择   <code>最小安装</code>（最快安装），也可以选择其他的，然后继续，得到如下界面。</p><p>3、这一步<strong>很重要</strong>，一定选择<code>其他选项</code>，</p><p><div align="center"><img src="/2021/01/30/U盘安装linux、远程桌面、显卡驱动及conda安装/4.JPG" alt></div></p><p>然后就会进入如下界面。</p><p><div align="center"><img src="/2021/01/30/U盘安装linux、远程桌面、显卡驱动及conda安装/5.JPG" alt></div></p><p>这里选择<code>新建分区表</code>，可能在下面，或者在右下方，然后选择空闲，会默认将之前的分区表格式化掉，然后点击左下方的<code>+</code>，表示新建分区。</p><ol><li>首先创建根目录，大小再25G左右，用于EXT4文件系统，挂载点下拉菜单，选择<code>/</code>，其他默认，然后确定，然后继续选择空间分区，点击添加。</li><li>新建交换区分区，大小一般为电脑内存的两倍，如若本机运行内存为8G，则交换区大小选择16G大小，用于下拉菜单选择<code>交换空间</code>，即SWAP，然后点击确定。</li><li>新建/Boot分区，大小为400M，文件系统为EXT4，挂载点选择<code>/boot</code>，然后点击确定。</li><li>/home分区的确定，剩余大小全部为/home分区，挂载点选择<code>/home</code>，点击确定，分区完成。</li><li><strong>很重要</strong>，然后在安装启动引导器的设备中，选择<code>sda</code>全部（一般情况下是默认的），如果装的是双系统，则这里需要选择刚才新建的/boot分区前面对应的编号。</li></ol><p>4、然后接下来就是选择开始安装，会出现选择地区，随便选一个，然后设置语言，键盘布局默认。</p><p>5、然后设置系统用户，用户自己设置输入就可以了</p><p><div align="center"><img src="/2021/01/30/U盘安装linux、远程桌面、显卡驱动及conda安装/7.JPG" alt></div></p><p>6、点击继续，系统就开始安装了，安装完成之后会提示重启电脑，重启之后就系统就安装完成了！</p><p>进入系统后，需要安装net-tools才能查看本地ip地址</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt <span class="keyword">install</span> net-tools</span><br></pre></td></tr></table></figure><p>若出现错误：E：软件包 net-tools 没有可安装候选，则需要在线更新数据包，指令：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>然后再执行：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt <span class="keyword">install</span> net-tools</span><br></pre></td></tr></table></figure><p>就可以安装完成了。</p><p>输入<code>ifconfig</code>就可以查看到本地ip地址了。需要远程连接设备还需要安装ssh。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt <span class="keyword">install</span> ssh</span><br></pre></td></tr></table></figure><h3 id="配置Win10远程连接Ubuntu18-04桌面"><a href="#配置Win10远程连接Ubuntu18-04桌面" class="headerlink" title="配置Win10远程连接Ubuntu18.04桌面"></a>配置Win10远程连接Ubuntu18.04桌面</h3><h4 id="一、原生桌面"><a href="#一、原生桌面" class="headerlink" title="一、原生桌面"></a>一、原生桌面</h4><p> 1、ubuntu18.04安装各种包：</p><ol><li><code>sudo apt install xrdp xorgxrdp</code></li><li><code>sudo apt install tightvncserver</code></li><li><code>sudo apt install xserver-xorg-core</code></li></ol><p>2、win 10 搜索栏搜索mstsc，打开远程桌面，输入ip地址，端口：3389，再输入用户密码登陆。</p><h4 id="二、xfce桌面"><a href="#二、xfce桌面" class="headerlink" title="二、xfce桌面"></a>二、xfce桌面</h4><p>采用windows自带远程桌面连接远程电脑，远程端ubuntu18.04，安装xrdp + xfce4</p><p>1、 ubuntu18.04 安装各种包</p><ol><li><code>sudo apt install tightvncserver xrdp</code></li><li><code>sudo apt install xserver-xorg-core</code></li><li><code>sudo apt -y install xserver-xorg-input-all</code></li><li><code>sudo apt install xorgxrdp</code></li><li><code>sudo apt install xfce4</code></li><li><code>sudo echo xfce4-session &gt;~/.xseesion</code></li><li><code>sudo service xrdp restart</code></li><li>重启，<code>sudo reboot</code></li></ol><p>2、win10 搜索栏搜索mstsc，打开远程桌面，输入ip地址，端口3389，再输入用户名和密码。</p><h3 id="Ubuntu-18-04安装显卡驱动"><a href="#Ubuntu-18-04安装显卡驱动" class="headerlink" title="Ubuntu 18.04安装显卡驱动"></a>Ubuntu 18.04安装显卡驱动</h3><p>1、先查看显卡硬件型号，在终端输入：<code>ubuntu-drivers devices</code>，可以看到如下界面：</p><p><div align="center"><img src="/2021/01/30/U盘安装linux、远程桌面、显卡驱动及conda安装/8.png" alt></div></p><p>从上图可以看出，我的显卡是：<code>GeForce GTX 1060 6GB</code>，推荐安装的版本是：<code>driver   : nvidia-driver-460 - distro non-free recommended</code>。</p><p>2、如果同意安装推荐版本，只需要在终端输入：<code>sudo ubuntu-drivers autoinstall</code>，就可以自动安装了。</p><p>也可以使用apt命令来安装自己想要安装的版本，比如想安装390版本号的版本，终端输入：<code>sudo apt install nvidia-driver-390</code>。</p><p>然后等待一会就完成安装了，安装完成之后需要重启设备。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo reboot</span><br></pre></td></tr></table></figure><p>重启之后输入：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>nvidia-smi</span><br></pre></td></tr></table></figure><p>如果可以出现如下界面表示显卡驱动安装完成。</p><p><div align="center"><img src="/2021/01/30/U盘安装linux、远程桌面、显卡驱动及conda安装/9.png" alt></div></p><h3 id="Ubuntu18-04-安装Anaconda3"><a href="#Ubuntu18-04-安装Anaconda3" class="headerlink" title="Ubuntu18.04 安装Anaconda3"></a>Ubuntu18.04 安装Anaconda3</h3><p>1、下载Anaconda3-5.3.0-Linux-x86_64.sh（Ubuntu18.04的对应的Anaconda版本）</p><p>推荐去<a href="!https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">清华大学开源软件镜像站</a>下载对应的版本，然后cd到下载的文件夹路径。</p><p>2、运行.sh文件：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash Anaconda3<span class="number">-5.3</span><span class="number">.0</span>-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><p>输入<code>yes</code>出现如下界面：</p><p><div align="center"><img src="/2021/01/30/U盘安装linux、远程桌面、显卡驱动及conda安装/10.png" alt></div></p><p>然后继续<code>yes</code>完成注册信息界面。</p><p><div align="center"><img src="/2021/01/30/U盘安装linux、远程桌面、显卡驱动及conda安装/11.png" alt></div></p><p>这里可以存在安装的文件路径，我这里就直接默认了，回车就可以了，然后就开始安装。</p><p><div align="center"><img src="/2021/01/30/U盘安装linux、远程桌面、显卡驱动及conda安装/12.png" alt></div></p><p>到这里提示是否将路径加入到环境变量里面，默认是no，这里我们选择输入yes。为了后续不用多余的添加环境变量。</p><p><div align="center"><img src="/2021/01/30/U盘安装linux、远程桌面、显卡驱动及conda安装/13.png" alt></div></p><p>到这里提示是否哦暗转VSCode，这里我输入no。</p><p>控制台输入<code>python</code>，可以看出还是使用的Ubuntu自带的python。输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ~/.bashrc</span></span><br></pre></td></tr></table></figure><p>让<code>.bashrc</code>中添加的路径生效。运行python可以看到已经安装好了，执行<code>$ which python</code>命令可以查看python路径。</p><p>然后就安装好了，重启系统。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo reboot</span><br></pre></td></tr></table></figure><p>输入<code>$ conda env list</code>可以查看当前创建的环境。</p><p>这里附上我个人的conda指令的部分笔记。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="keyword">update</span> conda <span class="comment"># 更新conda到最新的版本</span></span><br><span class="line">conda <span class="keyword">update</span> <span class="comment">--all # 更新所有包</span></span><br><span class="line"></span><br><span class="line">conda <span class="keyword">create</span> -n learn python=<span class="number">3</span>  <span class="comment"># 创建一个名为learn的环境并指定python版本为3</span></span><br><span class="line">conda <span class="keyword">create</span> -n python3 python=<span class="number">3.5</span> numpy pandas <span class="comment"># 创建一个名为python3的环境并同时安装numpy和pandas包</span></span><br><span class="line"><span class="keyword">activate</span> learn <span class="comment"># 创建好之后，切换到learn环境 activate &lt;env_name&gt;</span></span><br><span class="line">conda env <span class="keyword">list</span> <span class="comment"># 查看conda管理的所有环境</span></span><br><span class="line"></span><br><span class="line">deactivate env_name  <span class="comment"># 退出创建的虚拟环境</span></span><br><span class="line"><span class="keyword">activate</span> root  <span class="comment"># 退出创建的虚拟环境</span></span><br><span class="line"></span><br><span class="line">conda remove -n learn <span class="comment">--all  # 删除learn环境及下属所有包</span></span><br><span class="line">conda <span class="keyword">list</span> <span class="comment"># 列出当前环境下的所有包</span></span><br><span class="line">conda <span class="keyword">install</span> requests <span class="comment"># 安装requests包</span></span><br><span class="line">conda <span class="keyword">update</span> requests <span class="comment"># 更新包</span></span><br><span class="line"></span><br><span class="line">conda config <span class="comment">--show channels # 查看channels</span></span><br><span class="line">conda env <span class="keyword">export</span> &gt; environment.yaml</span><br><span class="line"><span class="comment"># 导出当前环境的包信息，环境会被保存在environment.yaml文件中，该文件路径一般在C盘用户文件夹里面</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据别人提供的.yaml配置文件创建新的虚拟环境，</span></span><br><span class="line">conda env <span class="keyword">create</span> -f environment.yaml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">linux下anaconda 的使用</span><br><span class="line"><span class="keyword">source</span> <span class="keyword">activate</span> env_name  <span class="comment"># 激活名为env_name 的环境</span></span><br><span class="line"><span class="keyword">source</span> deactivate env_name <span class="comment"># 退出env_name的环境</span></span><br><span class="line">conda remove -<span class="keyword">name</span> env_name <span class="comment"># 删除环境</span></span><br><span class="line"></span><br><span class="line">解压zip文件：</span><br><span class="line">jar xvf filename.zip</span><br></pre></td></tr></table></figure><p>参考博客：<a href="!https://www.cnblogs.com/msq2000/p/13056177.html">https://www.cnblogs.com/msq2000/p/13056177.html</a></p><h3 id="ubuntu18-04-安装jupyter-notebook并配置"><a href="#ubuntu18-04-安装jupyter-notebook并配置" class="headerlink" title="ubuntu18.04 安装jupyter-notebook并配置"></a>ubuntu18.04 安装jupyter-notebook并配置</h3><p>1、<code>sudo apt-get update</code></p><p>2、<code>sudo apt-get install jupyter-notebook</code></p><p>3、配置jupter-notebook</p><ol><li><p>运行<code>sudo jupyter-notebook --generate-config --allow-root</code>，会自动生成~/.jupyter/jupyter-notebook-config.py。可以得到自动生成config的路径。</p><p><div align="center"><img src="/2021/01/30/U盘安装linux、远程桌面、显卡驱动及conda安装/14.png" alt></div></p></li><li><p>更改jupyter-notebook配置文件。</p></li><li><p>运行<code>sudo vim &lt;刚才生成的路径&gt;</code>，如</p><p><div align="center"><img src="/2021/01/30/U盘安装linux、远程桌面、显卡驱动及conda安装/15.png" alt></div></p><p>进入到编辑jupyter-notebook配置文件的界面</p></li><li><p>可以根据自己的需求自行的配置该jupyter-notebook配置文件，将需要配置的前面的<code>#</code>号删掉就可以了，</p></li><li><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.notebook_dir = <span class="string">'/home/&lt;当前用户&gt;/work'</span></span><br><span class="line">设置默认路径：（建议使用绝对路径，~在配置中代表默认工作区，如果不是第一次设置容易出错）</span><br><span class="line">c.NotebookApp.token=<span class="string">'登陆密码'</span>  如果设置为空<span class="string">''</span>,则运行则不需要密码</span><br><span class="line">c.NotebookApp.ip = <span class="string">'*'</span>   这个‘*<span class="string">'就表示任何IP可以访问该jupyter服务’</span></span><br><span class="line"><span class="string">c.NotebookApp.port=8888 .默认为8888</span></span><br></pre></td></tr></table></figure><p>可以通过删掉<code>#</code>来配置，也可以自己写配置文件，如下：</p><p><div align="center"><img src="/2021/01/30/U盘安装linux、远程桌面、显卡驱动及conda安装/16.png" alt></div></p></li><li><p>配置默认的根目录，</p><p><div align="center"><img src="/2021/01/30/U盘安装linux、远程桌面、显卡驱动及conda安装/17.png" alt></div></p></li><li><p>配置文件改好之后，按Esc然后输入<code>:wq</code>表示保存并退出，具体的vim语法可以百度。</p></li><li><p>保存了改好之后的配置文件，输入<code>sudo jupter-notebook --allow-root</code>开启jupyter-notebook服务。</p></li><li><p>用户就可以在本地的浏览器上面输入服务器ip地址和设置的port端口号来正常访问jupyter-notebook操作python。如在浏览器中输入<code>http://&lt;服务器ip地址&gt;:端口号</code>，然后输入设置的密码就可以访问了。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;服务器U盘安装linux系统&quot;&gt;&lt;a href=&quot;#服务器U盘安装linux系统&quot; class=&quot;headerlink&quot; title=&quot;服务器U盘安装linux系统&quot;&gt;&lt;/a&gt;服务器U盘安装linux系统&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;一、安装环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Window 10 系统&lt;/p&gt;
&lt;p&gt;准备工具：&lt;/p&gt;
&lt;p&gt;1、ubuntu系统安装包&lt;/p&gt;
&lt;p&gt;2、一个格式化的16GU盘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、安装步骤&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>构建乘积数组</title>
    <link href="http://yoursite.com/2020/12/23/%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/12/23/构建乘积数组/</id>
    <published>2020-12-23T02:14:07.395Z</published>
    <updated>2020-12-23T02:49:51.472Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&amp;&amp;tqId=11204&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></h4><p>[给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。（注意：规定B[0] = A[1] <em> A[2] </em> … <em> A[n-1]，B[n-1] = A[0] </em> A[1] <em> … </em> A[n-2];）</p><p>对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。]</p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><blockquote><p>1 2 3 4 5</p></blockquote><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><blockquote><p>120 60 40 30 24</p></blockquote><a id="more"></a><h4 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h4><p>不能使用除法</p><p>两重循环， 将ans数组初始化为1，分别乘其他元素即可，时间复杂度O(N^2^)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">//键盘扫描类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        Arrays.fill(ans,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                    ans[j] *= A[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h4><p>假设：</p><p><code>left[i] = A[0]* ... *A[i-1]</code></p><p><code>right[i] = A[i+1]* ... * A[n-1]</code></p><p>所以：</p><p><code>B[i] = left[i] * right[i]</code></p><p>于是：</p><p><code>left[i+1] = left[i] * A[i]</code></p><p><code>right[i] = right[i+1] + A[i+1]</code></p><p>所以，可以先把所有的left[i]，right[i]求出来。</p><p><strong>时间复杂度：</strong>O(N)</p><p><strong>空间复杂度：</strong>O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">//键盘扫描类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        Arrays.fill(ans,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            ans[i] = ans[i-<span class="number">1</span>] * A[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.length-<span class="number">2</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            temp *= A[i+<span class="number">1</span>];</span><br><span class="line">            ans[i] *= temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&amp;amp;&amp;amp;tqId=11204&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目描述&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;[给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]&lt;em&gt;A[1]&lt;/em&gt;…&lt;em&gt;A[i-1]&lt;/em&gt;A[i+1]&lt;em&gt;…&lt;/em&gt;A[n-1]。不能使用除法。（注意：规定B[0] = A[1] &lt;em&gt; A[2] &lt;/em&gt; … &lt;em&gt; A[n-1]，B[n-1] = A[0] &lt;/em&gt; A[1] &lt;em&gt; … &lt;/em&gt; A[n-2];）&lt;/p&gt;
&lt;p&gt;对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。]&lt;/p&gt;
&lt;h4 id=&quot;输入描述&quot;&gt;&lt;a href=&quot;#输入描述&quot; class=&quot;headerlink&quot; title=&quot;输入描述&quot;&gt;&lt;/a&gt;输入描述&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;1 2 3 4 5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;输出描述&quot;&gt;&lt;a href=&quot;#输出描述&quot; class=&quot;headerlink&quot; title=&quot;输出描述&quot;&gt;&lt;/a&gt;输出描述&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;120 60 40 30 24&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>把字符串转换成整数</title>
    <link href="http://yoursite.com/2020/12/22/%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/"/>
    <id>http://yoursite.com/2020/12/22/把字符串转换成整数/</id>
    <published>2020-12-22T02:32:34.332Z</published>
    <updated>2020-12-22T02:41:07.014Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p><a href="https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&amp;&amp;tqId=11202&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</a></p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><p>输入一个字符串，包括数字字母符号，可以为空。</p><blockquote><p>“+2147483647”</p><p>“1a33”</p></blockquote><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><p>如果是合法的数值则返回该数字，否则返回0</p><blockquote><p>2147483647</p><p>0</p></blockquote><a id="more"></a><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>把第一个字符单独拿出来考虑， 其他字符判断为非法字符的时候可以直接返回<code>false</code>，注意最后输出的整数是否超过整数界限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length()-<span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) &lt; <span class="string">'0'</span> || str.charAt(i) &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res += index*(str.charAt(i)-<span class="string">'0'</span>);</span><br><span class="line">            index *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) == <span class="string">'-'</span> || str.charAt(<span class="number">0</span>) == <span class="string">'+'</span>) &#123;</span><br><span class="line">            res = str.charAt(<span class="number">0</span>) == <span class="string">'-'</span> ? res*(-<span class="number">1</span>) : res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str.charAt(<span class="number">0</span>) &gt;= <span class="string">'0'</span> || str.charAt(<span class="number">0</span>) &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            res += index*(str.charAt(<span class="number">0</span>)-<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&amp;amp;&amp;amp;tqId=11202&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;输入描述&quot;&gt;&lt;a href=&quot;#输入描述&quot; class=&quot;headerlink&quot; title=&quot;输入描述&quot;&gt;&lt;/a&gt;输入描述&lt;/h4&gt;&lt;p&gt;输入一个字符串，包括数字字母符号，可以为空。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“+2147483647”&lt;/p&gt;
&lt;p&gt;“1a33”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;输出描述&quot;&gt;&lt;a href=&quot;#输出描述&quot; class=&quot;headerlink&quot; title=&quot;输出描述&quot;&gt;&lt;/a&gt;输出描述&lt;/h4&gt;&lt;p&gt;如果是合法的数值则返回该数字，否则返回0&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2147483647&lt;/p&gt;
&lt;p&gt;0&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>扑克牌顺子</title>
    <link href="http://yoursite.com/2020/12/20/%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/"/>
    <id>http://yoursite.com/2020/12/20/扑克牌顺子/</id>
    <published>2020-12-20T09:11:49.326Z</published>
    <updated>2020-12-21T08:21:09.471Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><p>输入5个整数、保证每个数不大于13。</p><blockquote><p>0 3 2 6 4</p></blockquote><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><p>一个布尔值，True 或者False</p><blockquote><p>true</p></blockquote><a id="more"></a><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p> 定义一个<code>arr</code>数组记录0到13数字是否出现，出现则标记为1，否则为0，</p><p>定义min和max记录输入的最小值和最大值。count记录输入0的个数</p><p>只要有重复的输入则一定不行，直接输出<code>false</code>，</p><p>在<code>arr</code>中从min遍历到max，判断这之间数字没有出现的个数即arr[i]为0的个数，若个数小于等于0的个数则说明0可以添加在里面，则<code>ture</code>，否则<code>false</code>。</p><p>若 3 4 6 0 0，则从3 到 6 没有出现5 ，个数为1小于0的个数2，则可以添加一个0为5，其余的在两端。</p><p><strong>时间复杂度：</strong>O(n)</p><p><strong>空间复杂度：</strong>O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.length &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> [] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">13</span>];</span><br><span class="line">        <span class="keyword">int</span> max = -<span class="number">999999</span>;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">9999999</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                arr[num]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[num] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[num] = <span class="number">1</span>;</span><br><span class="line">                max = max &gt; num ? max : num;</span><br><span class="line">                min = min &lt; num ? min : num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min+<span class="number">1</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                count0++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count0 &lt;= arr[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h4><p>先对输入的5个数字的字符排序。</p><p>从第一个非零的数开始，后面的数应该与前面的数相差为1，若不为1，说明多余的差则需要0来补齐，若5个数遍历完，还有多余的0的个数，则说明<code>true</code>，否则<code>false</code>。</p><p>若2 4 6 0 0，排序之后为 0 0 2 4 6，第一个非零的为2，后面的一个数减前面的一个数，4 - 2 - 1 = 1，说明需要补一个0，0的个数减1，同理6 - 4 -1 = 1，遍历结束0的个数大于等于0则<code>true</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">//键盘扫描类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.length &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count0 = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length-<span class="number">1</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                count0++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count0 -= (numbers[i+<span class="number">1</span>]-numbers[i]-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (count0 &lt; <span class="number">0</span> || numbers[i+<span class="number">1</span>] == numbers[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。&lt;/p&gt;
&lt;h4 id=&quot;输入描述&quot;&gt;&lt;a href=&quot;#输入描述&quot; class=&quot;headerlink&quot; title=&quot;输入描述&quot;&gt;&lt;/a&gt;输入描述&lt;/h4&gt;&lt;p&gt;输入5个整数、保证每个数不大于13。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;0 3 2 6 4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;输出描述&quot;&gt;&lt;a href=&quot;#输出描述&quot; class=&quot;headerlink&quot; title=&quot;输出描述&quot;&gt;&lt;/a&gt;输出描述&lt;/h4&gt;&lt;p&gt;一个布尔值，True 或者False&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;true&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>翻转单词顺序列</title>
    <link href="http://yoursite.com/2020/12/18/%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2020/12/18/翻转单词顺序列/</id>
    <published>2020-12-18T08:20:42.549Z</published>
    <updated>2020-12-18T08:30:19.782Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><p>一个反序的字符串</p><blockquote><p>nowcoder. a am I</p></blockquote><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><p>翻转单词之后的字符串</p><blockquote><p>I am a nowcoder.</p></blockquote><a id="more"></a><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>定义两个指针，i 和 end ，分别表示一个单词第一个字母所处的下标，和最后一个字母所处的下标，</p><p>i从字符串的最后往前遍历，当i遇到空格时表示一个单词的开始，输出i到end的单词，</p><p>然后更新end为i，i继续往前遍历，当i==0时表示字符串遍历结束。</p><p>中间需要考虑空格的加入，</p><p><strong>时间复杂度</strong>：O(N)</p><p><strong>空间复杂度</strong>：O(N)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Solution;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">//键盘扫描类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="comment">//    private static BufferedReader input = new BufferedReader(new InputStreamReader(System.in));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> end = str.length();</span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) == <span class="string">' '</span> || i == <span class="number">0</span>) &#123;</span><br><span class="line">                ans.append(end == str.length() ? <span class="string">""</span> : <span class="string">" "</span>);</span><br><span class="line">                ans.append(str.substring(i == <span class="number">0</span> ? i : i+<span class="number">1</span>,end));</span><br><span class="line">                end = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String str = input.nextLine();</span><br><span class="line">        System.out.println(Main.ReverseSentence(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？&lt;/p&gt;
&lt;h4 id=&quot;输入描述&quot;&gt;&lt;a href=&quot;#输入描述&quot; class=&quot;headerlink&quot; title=&quot;输入描述&quot;&gt;&lt;/a&gt;输入描述&lt;/h4&gt;&lt;p&gt;一个反序的字符串&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nowcoder. a am I&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;输出描述&quot;&gt;&lt;a href=&quot;#输出描述&quot; class=&quot;headerlink&quot; title=&quot;输出描述&quot;&gt;&lt;/a&gt;输出描述&lt;/h4&gt;&lt;p&gt;翻转单词之后的字符串&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I am a nowcoder.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>PAT(Basic Level)Practice(中文)</title>
    <link href="http://yoursite.com/2020/12/10/PAT-Basic-Level-Practice-%E4%B8%AD%E6%96%87/"/>
    <id>http://yoursite.com/2020/12/10/PAT-Basic-Level-Practice-中文/</id>
    <published>2020-12-10T06:31:06.464Z</published>
    <updated>2022-07-05T12:37:56.337Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1001、害死人不偿命的-3n-1-猜想"><a href="#1001、害死人不偿命的-3n-1-猜想" class="headerlink" title="1001、害死人不偿命的(3n+1)猜想"></a>1001、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805325918486528" target="_blank" rel="noopener">害死人不偿命的(3n+1)猜想</a></h4><p>卡拉兹(Callatz)猜想：</p><p>对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……</p><p>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1？</p><a id="more"></a><p><strong>输入格式</strong></p><p>每个测试输入包含 1 个测试用例，即给出正整数 n 的值。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 3</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出格式</strong></p><p>输出从 n 计算到 1 需要的步数。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,k=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">while</span> (n != <span class="number">1</span>) &#123;</span><br><span class="line">        n = !(n&amp;<span class="number">1</span>) ? n &gt;&gt; <span class="number">1</span> : (<span class="number">3</span>*n+<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,k);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1002、写出这个数"><a href="#1002、写出这个数" class="headerlink" title="1002、写出这个数"></a>1002、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805324509200384" target="_blank" rel="noopener">写出这个数</a></h4><p>读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。 </p><p><strong>输入描述</strong></p><p>每个测试输入包含 1 个测试用例，即给出自然数 n 的值。这里保证 n 小于 10^100。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 1234567890987654321123456789</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行内输出 n 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> yi san wu</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="keyword">char</span> b[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (b[i] != <span class="string">'\0'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i] &gt;= <span class="string">'0'</span>&amp;&amp;b[i] &lt;= <span class="string">'9'</span>)</span><br><span class="line">temp += b[i]-<span class="string">'0'</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printfsum</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n/<span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> p = n%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">switch</span>(p)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span> : <span class="built_in">printf</span>(<span class="string">"ling"</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span> : <span class="built_in">printf</span>(<span class="string">"yi"</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span> : <span class="built_in">printf</span>(<span class="string">"er"</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span> : <span class="built_in">printf</span>(<span class="string">"san"</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span> : <span class="built_in">printf</span>(<span class="string">"si"</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span> : <span class="built_in">printf</span>(<span class="string">"wu"</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span> : <span class="built_in">printf</span>(<span class="string">"liu"</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span> : <span class="built_in">printf</span>(<span class="string">"qi"</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span> : <span class="built_in">printf</span>(<span class="string">"ba"</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span> : <span class="built_in">printf</span>(<span class="string">"jiu"</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span> : <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">printfsum (n/<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">printfsum (n%<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">105</span>];</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s"</span>,a);</span><br><span class="line">printfsum ( sum(a) );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1003、我要通过！"><a href="#1003、我要通过！" class="headerlink" title="1003、我要通过！"></a>1003、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805323154440192" target="_blank" rel="noopener">我要通过！</a></h4><p><strong>答案正确</strong>”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“<strong>答案正确</strong>”大派送 —— 只要读入的字符串满足下列条件，系统就输出“<strong>答案正确</strong>”，否则输出“<strong>答案错误</strong>”。</p><p>得到“<strong>答案正确</strong>”的条件是：</p><ol><li>字符串中必须仅有 <code>P</code>、 <code>A</code>、 <code>T</code>这三种字符，不可以包含其它字符；</li><li>任意形如 <code>xPATx</code> 的字符串都可以获得“<strong>答案正确</strong>”，其中 <code>x</code> 或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串；</li><li>如果 <code>aPbTc</code> 是正确的，那么 <code>aPbATca</code> 也是正确的，其中 <code>a</code>、 <code>b</code>、 <code>c</code> 均或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串。</li></ol><p>现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“<strong>答案正确</strong>”的。</p><p><strong>输入描述</strong></p><p>每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 8</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> PAT</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> PAAT</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> AAPATAA</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> AAPAATAAAA</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> xPATx</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> PT</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Whatever</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> APAAATAA</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>每个字符串的检测结果占一行，如果该字符串可以获得“<strong>答案正确</strong>”，则输出 <code>YES</code>，否则输出 <code>NO</code>。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> YES</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> YES</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> YES</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> YES</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> NO</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> NO</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> NO</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> NO</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">110</span>];</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s"</span>,str);</span><br><span class="line"><span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">int</span> p_pos,t_pos;</span><br><span class="line"><span class="keyword">int</span> p_num = <span class="number">0</span>,t_num = <span class="number">0</span>,other = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">'P'</span>) &#123;</span><br><span class="line">p_num++;</span><br><span class="line">p_pos=i;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">'T'</span>) &#123;</span><br><span class="line">t_num++;</span><br><span class="line">t_pos=i;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (str[i] != <span class="string">'A'</span>) &#123;</span><br><span class="line">other++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p_num != <span class="number">1</span> || t_num != <span class="number">1</span> || other != <span class="number">0</span> || t_pos-p_pos&lt;=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x=p_pos,y=t_pos-p_pos<span class="number">-1</span>,z=<span class="built_in">strlen</span>(str)-t_pos<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (z-x == x*(y<span class="number">-1</span>)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1004、成绩排名"><a href="#1004、成绩排名" class="headerlink" title="1004、成绩排名"></a>1004、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805321640296448" target="_blank" rel="noopener">成绩排名</a></h4><p>读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。 </p><p><strong>输入描述</strong></p><p>每个测试输入包含 1 个测试用例，格式为</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第 <span class="number">1</span> 行：正整数 n</span><br><span class="line">第 <span class="number">2</span> 行：第 <span class="number">1</span> 个学生的姓名 学号 成绩</span><br><span class="line">第 <span class="number">3</span> 行：第 <span class="number">2</span> 个学生的姓名 学号 成绩</span><br><span class="line">  ... ... ...</span><br><span class="line">第 n+<span class="number">1</span> 行：第 n 个学生的姓名 学号 成绩</span><br></pre></td></tr></table></figure><p>其中<code>姓名</code>和<code>学号</code>均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 3</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Joe Math990112 89</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Mike CS991301 100</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Mary EE990830 95</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Mike CS991301</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Joe Math990112</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">char</span> num[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> grade;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node,*Pnode;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitNode</span><span class="params">(Pnode p)</span> </span>&#123;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Printfstu</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">Pnode p;</span><br><span class="line">Pnode s;</span><br><span class="line">Pnode max;</span><br><span class="line">Pnode min;</span><br><span class="line">p = (Pnode)<span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (Node));</span><br><span class="line">InitNode(p);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">s = (Pnode ) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (Node ));</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s %s %d"</span>,s-&gt;name,s-&gt;num,&amp;s-&gt;grade);</span><br><span class="line">p-&gt;next = s;</span><br><span class="line">p = s;</span><br><span class="line">p-&gt;next =<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">max = p;</span><br><span class="line">min = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (max-&gt;grade &lt; p-&gt;grade)</span><br><span class="line">max = p;</span><br><span class="line"><span class="keyword">if</span> (min-&gt;grade &gt; p-&gt;grade)</span><br><span class="line">min = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%s %s\n"</span>,max-&gt;name,max-&gt;num);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%s %s"</span>,min-&gt;name,min-&gt;num);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">Printfstu(n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1005、继续-3n-1-猜想"><a href="#1005、继续-3n-1-猜想" class="headerlink" title="1005、继续(3n+1)猜想"></a>1005、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805320306507776" target="_blank" rel="noopener">继续(3n+1)猜想</a></h4><p>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。</p><p>当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。</p><p>现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</p><p><strong>输入描述</strong></p><p>每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 K (&lt;100)，第 2 行给出 K 个互不相同的待验证的正整数 n (1&lt;n≤100)的值，数字间用空格隔开。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">6</span></span><br><span class="line">&gt; <span class="number">3</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">11</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">7</span> <span class="number">6</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node, *LinkList;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitNode</span><span class="params">(LinkList p)</span> </span>&#123;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateFromNode</span><span class="params">(LinkList p,<span class="keyword">int</span> n)</span> </span>&#123;  <span class="comment">//*p是带头结点的空链表的表头指针，通过键盘输入元素值 </span></span><br><span class="line">LinkList r,s;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">r = p;  <span class="comment">//*r指针动态指向链表的结尾 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">s = (LinkList) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (Node));</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">r-&gt;next = s;</span><br><span class="line">r = s;</span><br><span class="line">r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeNode</span><span class="params">(LinkList p,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">LinkList pre,r;</span><br><span class="line">pre = p;</span><br><span class="line"><span class="keyword">while</span> (pre-&gt;next != <span class="literal">NULL</span>&amp;&amp;(pre-&gt;next)-&gt;data != x)</span><br><span class="line">pre = pre-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (! (pre-&gt;next)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">r = pre-&gt;next;</span><br><span class="line">pre-&gt;next = r-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(r);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNode</span><span class="params">(LinkList p)</span> </span>&#123;</span><br><span class="line">LinkList r;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">r = p-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (r != <span class="literal">NULL</span>) &#123;</span><br><span class="line">x = r-&gt;data;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (x%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">x = x/<span class="number">2</span>;</span><br><span class="line">DeNode(p,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">x = (<span class="number">3</span>*x+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">DeNode(p,x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">r = r-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintfNode</span><span class="params">(LinkList p)</span> </span>&#123;</span><br><span class="line">LinkList r;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i,j,temp;</span><br><span class="line">r = p-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (r != <span class="literal">NULL</span>) &#123;</span><br><span class="line">a[count++] = r-&gt;data;</span><br><span class="line">r = r-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= count<span class="number">-1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count<span class="number">-1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">temp = a[j];</span><br><span class="line">a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">a[j+<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) <span class="built_in">printf</span> (<span class="string">"%d"</span>,a[i]);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">" %d"</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LinkList p;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">p = (LinkList )<span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (Node));</span><br><span class="line">InitNode(p);</span><br><span class="line">CreateFromNode(p,n);</span><br><span class="line">GetNode(p);</span><br><span class="line">PrintfNode(p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1006、换个格式输出整数"><a href="#1006、换个格式输出整数" class="headerlink" title="1006、换个格式输出整数"></a>1006、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805318855278592" target="_blank" rel="noopener">换个格式输出整数</a></h4><p>让我们用字母 <code>B</code> 来表示“百”、字母 <code>S</code> 表示“十”，用 <code>12...n</code> 来表示不为零的个位数字 <code>n</code>（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 <code>234</code> 应该被输出为 <code>BBSSS1234</code>，因为它有 2 个“百”、3 个“十”、以及个位的 4。 </p><p><strong>输入描述</strong></p><p>每个测试输入包含 1 个测试用例，给出正整数 n（&lt;1000）。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 234</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>每个测试用例的输出占一行，用规定的格式输出 n。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> BBSSS1234</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">a = n/<span class="number">100</span>;</span><br><span class="line">b = (n%<span class="number">100</span>)/<span class="number">10</span>;</span><br><span class="line">c = n%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a; i++) </span><br><span class="line">str[i] = <span class="string">'B'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = a; i &lt; a+b; i++)</span><br><span class="line">str[i] = <span class="string">'S'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = a+b; i &lt; a+b+c; i++)</span><br><span class="line">str[i] = i-a-b+<span class="number">1</span>+<span class="string">'0'</span>;</span><br><span class="line">str[a+b+c] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">puts</span> (str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1007、素数对猜想"><a href="#1007、素数对猜想" class="headerlink" title="1007、素数对猜想"></a>1007、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805317546655744" target="_blank" rel="noopener">素数对猜想</a></h4><p>让我们定义d(n)为：d(n)=p(n+1)−p(n)，其中pi是第i个素数。显然有d1=1，且对于n&gt;1有dn是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。</p><p>现给定任意正整数<code>N</code>(&lt;10^5)，请计算不超过<code>N</code>的满足猜想的素数对的个数。</p><p><strong>输入描述</strong></p><p>输入在一行给出正整数<code>N</code> 。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 20</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中输出不超过<code>N</code>的满足猜想的素数对的个数。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 4</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprime</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">2</span>; i &lt;= (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(x); ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (x%i == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n ; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (sprime(i)) &#123;</span><br><span class="line"><span class="keyword">if</span> (i-temp == <span class="number">2</span>)</span><br><span class="line">count++;</span><br><span class="line">temp = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>,count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1008、数组元素循环右移问题"><a href="#1008、数组元素循环右移问题" class="headerlink" title="1008、数组元素循环右移问题"></a>1008、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805316250615808" target="_blank" rel="noopener">数组元素循环右移问题</a></h4><p>一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A(0)A(1)⋯A(N−1)）变换为（A(N−M)⋯A(N−1)A(0)A(1)⋯A(N−M−1)）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？ </p><p><strong>输入描述</strong></p><p>每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">6</span> <span class="number">2</span></span><br><span class="line">&gt; <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">5</span> <span class="number">6</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">move</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = a[n<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">a[i] = a[i<span class="number">-1</span>];</span><br><span class="line">a[<span class="number">0</span>] = temp;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">m %=n;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">move(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) <span class="built_in">printf</span> (<span class="string">"%d"</span>,a[i]);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">" %d"</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1009、说反话"><a href="#1009、说反话" class="headerlink" title="1009、说反话"></a>1009、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805314941992960" target="_blank" rel="noopener">说反话</a></h4><p>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。 </p><p><strong>输入描述</strong></p><p>测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Hello World Here I Come</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>每个测试用例的输出占一行，输出倒序后的句子。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Come I Here World Hello</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">gets(a);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">strlen</span>(a)<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] == <span class="string">' '</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%s"</span>,&amp;a[i+<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%c"</span>,a[i]);</span><br><span class="line">a[i] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%s"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1010、一元多项式求导"><a href="#1010、一元多项式求导" class="headerlink" title="1010、一元多项式求导"></a>1010、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805313708867584" target="_blank" rel="noopener">一元多项式求导</a></h4><p>设计函数求一元多项式的导数。（注：x^n^（n为整数）的一阶导数为nx^n−1^。） </p><p><strong>输入描述</strong></p><p>以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">3</span> <span class="number">4</span> <span class="number">-5</span> <span class="number">2</span> <span class="number">6</span> <span class="number">1</span> <span class="number">-2</span> <span class="number">0</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 <code>0 0</code> </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">12</span> <span class="number">3</span> <span class="number">-10</span> <span class="number">1</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b) != EOF) &#123;</span><br><span class="line"><span class="keyword">if</span> (first) &#123;  <span class="comment">//是第一项 </span></span><br><span class="line"><span class="keyword">if</span> (b&gt;<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, a*b, b - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"0 0"</span>);</span><br><span class="line">first = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b&gt;<span class="number">0</span>) &#123;  <span class="comment">//不是第一项，且非常数项（因为项数大于1时，常数项不用输出） </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %d %d"</span>, a*b, b - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1011、A-B-和-C"><a href="#1011、A-B-和-C" class="headerlink" title="1011、A+B 和 C"></a>1011、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805312417021952" target="_blank" rel="noopener">A+B 和 C</a></h4><p>给定区间 [−2^31^,2^31^] 内的 3 个整数 A、B 和 C，请判断 A+B 是否大于 C。 </p><p><strong>输入描述</strong></p><p>输入第 1 行给出正整数 T (≤10)，是测试用例的个数。随后给出 T 组测试用例，每组占一行，顺序给出 A、B 和 C。整数间以空格分隔。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">4</span></span><br><span class="line">&gt; <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">&gt; <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">&gt; <span class="number">2147483647</span> <span class="number">0</span> <span class="number">2147483646</span></span><br><span class="line">&gt; <span class="number">0</span> <span class="number">-2147483648</span> <span class="number">-2147483647</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>对每组测试用例，在一行中输出 <code>Case #X: true</code> 如果 A+B&gt;C，否则输出 <code>Case #X: false</code>，其中 <code>X</code> 是测试用例的编号（从 1 开始）。 </p><blockquote><figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">Case</span> <span class="string">#1</span>: <span class="literal">false</span></span><br><span class="line">&gt; <span class="keyword">Case</span> <span class="string">#2</span>: <span class="literal">true</span></span><br><span class="line">&gt; <span class="keyword">Case</span> <span class="string">#3</span>: <span class="literal">true</span></span><br><span class="line">&gt; <span class="keyword">Case</span> <span class="string">#4</span>: <span class="literal">false</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> a[<span class="number">15</span>],b[<span class="number">15</span>],c[<span class="number">15</span>];</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lf%lf%lf"</span>,&amp;a[i],&amp;b[i],&amp;c[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] + b[i] &gt; c[i])</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"Case #%d: true\n"</span>,i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"Case #%d: false\n"</span>,i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1012、数字分类"><a href="#1012、数字分类" class="headerlink" title="1012、数字分类"></a>1012、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805311146147840" target="_blank" rel="noopener">数字分类</a></h4><p>给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：</p><ul><li>A1 = 能被 5 整除的数字中所有偶数的和；</li><li>A2 = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n1−n2+n3−n4⋯；</li><li>A3 = 被 5 除后余 2 的数字的个数；</li><li>A4 = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位；</li><li>A5 = 被 5 除后余 4 的数字中最大数字。</li></ul><p><strong>输入描述</strong></p><p>每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N，随后给出 N 个不超过 1000 的待分类的正整数。数字间以空格分隔。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">13</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">20</span> <span class="number">16</span> <span class="number">18</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>对给定的 N 个正整数，按题目要求计算 A1~A5 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。</p><p>若其中某一类数字不存在，则在相应位置输出 <code>N</code>。</p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">30</span> <span class="number">11</span> <span class="number">2</span> <span class="number">9.7</span> <span class="number">9</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,value;</span><br><span class="line"><span class="keyword">int</span> a1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a2[<span class="number">1000</span>],count = <span class="number">0</span>,k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> he = <span class="number">0</span>,t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;value);</span><br><span class="line"><span class="keyword">if</span> (value%<span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">a1 += value;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value%<span class="number">5</span> == <span class="number">1</span>)</span><br><span class="line">a2[count++] = value;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value%<span class="number">5</span> == <span class="number">2</span>)</span><br><span class="line">a3++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value%<span class="number">5</span> == <span class="number">3</span>) &#123;</span><br><span class="line">he += value;</span><br><span class="line">t++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value%<span class="number">5</span> == <span class="number">4</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (value &gt; max)</span><br><span class="line">max = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= count<span class="number">-1</span>; j++) &#123;</span><br><span class="line">k += a2[j]*<span class="built_in">pow</span>(<span class="number">-1</span>,j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a1)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>,a1);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">"N"</span>);</span><br><span class="line"><span class="keyword">if</span> (count != <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">" %d"</span>,k);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">" N"</span>);</span><br><span class="line"><span class="keyword">if</span> (a3 != <span class="number">0</span>) <span class="built_in">printf</span> (<span class="string">" %d"</span>,a3);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">" N"</span>);</span><br><span class="line"><span class="keyword">if</span> (t != <span class="number">0</span>) <span class="built_in">printf</span> (<span class="string">" %0.1lf"</span>,(<span class="keyword">double</span>)he/t); </span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">" N"</span>);</span><br><span class="line"><span class="keyword">if</span> (max != <span class="number">0</span>) <span class="built_in">printf</span> (<span class="string">" %d"</span>,max);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">" N"</span>);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1013、数素数"><a href="#1013、数素数" class="headerlink" title="1013、数素数"></a>1013、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805309963354112" target="_blank" rel="noopener">数素数</a></h4><p>令 Pi 表示第 i 个素数。现任给两个正整数 M≤N≤10^4^，请输出 PM 到 PN 的所有素数。 </p><p><strong>输入描述</strong></p><p>输入在一行中给出 M 和 N，其间以空格分隔。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">5</span> <span class="number">27</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>输出从 PM 到 PN 的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">11</span> <span class="number">13</span> <span class="number">17</span> <span class="number">19</span> <span class="number">23</span> <span class="number">29</span> <span class="number">31</span> <span class="number">37</span> <span class="number">41</span> <span class="number">43</span></span><br><span class="line">&gt; <span class="number">47</span> <span class="number">53</span> <span class="number">59</span> <span class="number">61</span> <span class="number">67</span> <span class="number">71</span> <span class="number">73</span> <span class="number">79</span> <span class="number">83</span> <span class="number">89</span></span><br><span class="line">&gt; <span class="number">97</span> <span class="number">101</span> <span class="number">103</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sushu</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">2</span>; i &lt;= (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(x); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (x%i == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( i &gt; (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(x)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; ; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (sushu(i))</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count &gt;= m&amp;&amp;sushu(i)) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>,i);</span><br><span class="line"><span class="keyword">if</span> ((count-m+<span class="number">1</span>)%<span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (((count-m+<span class="number">1</span>)%<span class="number">10</span> != <span class="number">0</span>)&amp;&amp;count != n)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count == n)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1014、福尔摩斯的约会"><a href="#1014、福尔摩斯的约会" class="headerlink" title="1014、福尔摩斯的约会"></a>1014、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805308755394560" target="_blank" rel="noopener">福尔摩斯的约会</a></h4><p>大侦探福尔摩斯接到一张奇怪的字条：<code>我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm</code>。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间<code>星期四 14:04</code>，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 <code>D</code>，代表星期四；第 2 对相同的字符是 <code>E</code> ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 <code>A</code> 到 <code>N</code> 表示）；后面两字符串第 1 对相同的英文字母 <code>s</code> 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。 </p><p><strong>输入描述</strong></p><p>输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 3485djDkxh4hhGE </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2984akDfkkkkggEdsb </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> s&amp;hgsfdk </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> d&amp;Hyscvnm</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中输出约会的时间，格式为 <code>DAY HH:MM</code>，其中 <code>DAY</code> 是某星期的 3 字符缩写，即 <code>MON</code> 表示星期一，<code>TUE</code> 表示星期二，<code>WED</code> 表示星期三，<code>THU</code> 表示星期四，<code>FRI</code> 表示星期五，<code>SAT</code> 表示星期六，<code>SUN</code> 表示星期日。题目输入保证每个测试存在唯一解。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> THU 14:04</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str1[<span class="number">8</span>][<span class="number">4</span>] = &#123; <span class="string">" "</span>,<span class="string">"MON"</span>,<span class="string">"TUE"</span>,<span class="string">"WED"</span>,<span class="string">"THU"</span>,<span class="string">"FRI"</span>,<span class="string">"SAT"</span>,<span class="string">"SUN"</span> &#125;;</span><br><span class="line">  <span class="keyword">char</span> str2[<span class="number">61</span>], str3[<span class="number">61</span>], str4[<span class="number">61</span>], str5[<span class="number">61</span>];</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">  gets(str2);</span><br><span class="line">  gets(str3);</span><br><span class="line">  gets(str4);</span><br><span class="line">  gets(str5);</span><br><span class="line">  <span class="keyword">while</span> (str2[i] != <span class="string">'\0'</span> &amp;&amp; str3[i] != <span class="string">'\0'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= str2[i] &amp;&amp; str2[i] &lt;= <span class="string">'G'</span>)<span class="comment">// 第一行和第二行第一对相同位置、相同大写字母（A~G）</span></span><br><span class="line">        <span class="keyword">if</span> (str2[i] == str3[i])</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%s "</span>, str1[str2[i] - <span class="string">'A'</span>+<span class="number">1</span>]);</span><br><span class="line">          flag++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">'0'</span> &lt;= str2[i] &amp;&amp; str2[i] &lt;= <span class="string">'9'</span>)<span class="comment">//第一行和第二行第二对相同位置、相同大写字母（A~N）或数字（0~9 ）。 注意：是第二对，找到第二对就应该结循环了！</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (str2[i] == str3[i])</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%02d:"</span>, str2[i] - <span class="string">'0'</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= str2[i] &amp;&amp; str2[i] &lt;= <span class="string">'N'</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (str2[i] == str3[i])</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%02d:"</span>, str2[i] - <span class="number">55</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (str4[i] != <span class="string">'\0'</span> &amp;&amp; str5[i] != <span class="string">'\0'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="string">'a'</span> &lt;= str4[i] &amp;&amp; str4[i] &lt;= <span class="string">'z'</span>)||(<span class="string">'A'</span> &lt;= str4[i] &amp;&amp; str4[i] &lt;= <span class="string">'Z'</span>))<span class="comment">//第三行和第四行相同位置相同字母，不分大小写。</span></span><br><span class="line">        <span class="keyword">if</span> (str4[i] == str5[i])</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%02d\n"</span>, i);</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1015、德才论"><a href="#1015、德才论" class="headerlink" title="1015、德才论"></a>1015、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805307551629312" target="_blank" rel="noopener">德才论</a></h4><p>宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”</p><p>现给出一批考生的德才分数，请根据司马光的理论给出录取排名。</p><p><strong>输入描述</strong></p><p>输入第一行给出 3 个正整数，分别为：N（≤105），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。</p><p>随后 N 行，每行给出一位考生的信息，包括：<code>准考证号 德分 才分</code>，其中<code>准考证号</code>为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。</p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">14</span> <span class="number">60</span> <span class="number">80</span></span><br><span class="line">&gt; <span class="number">10000001</span> <span class="number">64</span> <span class="number">90</span></span><br><span class="line">&gt; <span class="number">10000002</span> <span class="number">90</span> <span class="number">60</span></span><br><span class="line">&gt; <span class="number">10000011</span> <span class="number">85</span> <span class="number">80</span></span><br><span class="line">&gt; <span class="number">10000003</span> <span class="number">85</span> <span class="number">80</span></span><br><span class="line">&gt; <span class="number">10000004</span> <span class="number">80</span> <span class="number">85</span></span><br><span class="line">&gt; <span class="number">10000005</span> <span class="number">82</span> <span class="number">77</span></span><br><span class="line">&gt; <span class="number">10000006</span> <span class="number">83</span> <span class="number">76</span></span><br><span class="line">&gt; <span class="number">10000007</span> <span class="number">90</span> <span class="number">78</span></span><br><span class="line">&gt; <span class="number">10000008</span> <span class="number">75</span> <span class="number">79</span></span><br><span class="line">&gt; <span class="number">10000009</span> <span class="number">59</span> <span class="number">90</span></span><br><span class="line">&gt; <span class="number">10000010</span> <span class="number">88</span> <span class="number">45</span></span><br><span class="line">&gt; <span class="number">10000012</span> <span class="number">80</span> <span class="number">100</span></span><br><span class="line">&gt; <span class="number">10000013</span> <span class="number">90</span> <span class="number">99</span></span><br><span class="line">&gt; <span class="number">10000014</span> <span class="number">66</span> <span class="number">60</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">12</span></span><br><span class="line">&gt; <span class="number">10000013</span> <span class="number">90</span> <span class="number">99</span></span><br><span class="line">&gt; <span class="number">10000012</span> <span class="number">80</span> <span class="number">100</span></span><br><span class="line">&gt; <span class="number">10000003</span> <span class="number">85</span> <span class="number">80</span></span><br><span class="line">&gt; <span class="number">10000011</span> <span class="number">85</span> <span class="number">80</span></span><br><span class="line">&gt; <span class="number">10000004</span> <span class="number">80</span> <span class="number">85</span></span><br><span class="line">&gt; <span class="number">10000007</span> <span class="number">90</span> <span class="number">78</span></span><br><span class="line">&gt; <span class="number">10000006</span> <span class="number">83</span> <span class="number">76</span></span><br><span class="line">&gt; <span class="number">10000005</span> <span class="number">82</span> <span class="number">77</span></span><br><span class="line">&gt; <span class="number">10000002</span> <span class="number">90</span> <span class="number">60</span></span><br><span class="line">&gt; <span class="number">10000014</span> <span class="number">66</span> <span class="number">60</span></span><br><span class="line">&gt; <span class="number">10000008</span> <span class="number">75</span> <span class="number">79</span></span><br><span class="line">&gt; <span class="number">10000001</span> <span class="number">64</span> <span class="number">90</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,d,c,total,<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">&#125;Student;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* _a,<span class="keyword">const</span> <span class="keyword">void</span>* _b)</span></span>&#123;</span><br><span class="line">    Student* a=(Student*)_a;</span><br><span class="line">    Student* b=(Student*)_b;</span><br><span class="line">    <span class="keyword">if</span>(a-&gt;class!=b-&gt;class) <span class="keyword">return</span> a-&gt;class-b-&gt;class;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a-&gt;total!=b-&gt;total) <span class="keyword">return</span> b-&gt;total-a-&gt;total;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a-&gt;d!=b-&gt;d) <span class="keyword">return</span> b-&gt;d-a-&gt;d;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a-&gt;id-b-&gt;id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,L,H,M=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;N,&amp;L,&amp;H);</span><br><span class="line">    Student stu[N];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;stu[i].id,&amp;stu[i].d,&amp;stu[i].c);</span><br><span class="line">        stu[i].total=stu[i].d+stu[i].c;</span><br><span class="line">        <span class="keyword">if</span>(stu[i].d&gt;=L&amp;&amp;stu[i].c&gt;=L)&#123;</span><br><span class="line">            M++;</span><br><span class="line">            <span class="keyword">if</span>(stu[i].d&gt;=H&amp;&amp;stu[i].c&gt;=H) stu[i].class=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stu[i].c&lt;H&amp;&amp;stu[i].d&gt;=H) stu[i].class=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stu[i].d&lt;H&amp;&amp;stu[i].d&lt;H,stu[i].d&gt;=stu[i].c) stu[i].class=<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span> stu[i].class=<span class="number">4</span>;    </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stu[i].class=<span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(stu,N,<span class="keyword">sizeof</span>(Student),cmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,M);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,stu[i].id,stu[i].d,stu[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1016、部分A-B"><a href="#1016、部分A-B" class="headerlink" title="1016、部分A+B"></a>1016、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805306310115328" target="_blank" rel="noopener">部分A+B</a></h4><p>正整数 A 的“DA（为 1 位整数）部分”定义为由 A 中所有 DA 组成的新整数 PA。例如：给定 A=3862767，DA=6，则 A 的“6 部分”PA 是 66，因为 A 中有 2 个 6。</p><p>现给定 A、DA、B、DB，请编写程序计算 PA+PB</p><p><strong>输入描述</strong></p><p>输入在一行中依次给出 A、DA、B、DB，中间以空格分隔，其中 0&lt;A,B&lt;10^10^。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">3862767</span> <span class="number">6</span> <span class="number">13530293</span> <span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中输出 PA+PB 的值。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 399</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pa,pb;</span><br><span class="line"><span class="keyword">int</span> counta = <span class="number">0</span>,countb =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">15</span>],b[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> a1 = <span class="number">0</span>,b1 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s %d %s %d"</span>,a,&amp;pa,b,&amp;pb);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(a); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((a[i]-<span class="string">'0'</span>) == pa)</span><br><span class="line">counta++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="built_in">strlen</span>(b); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((b[i]-<span class="string">'0'</span>) == pb)</span><br><span class="line">countb++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= counta; i++)</span><br><span class="line">a1 = a1*<span class="number">10</span>+pa;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= countb; i++)</span><br><span class="line">b1 = b1*<span class="number">10</span>+pb;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>,a1+b1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1017、A除以B"><a href="#1017、A除以B" class="headerlink" title="1017、A除以B"></a>1017、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805305181847552" target="_blank" rel="noopener">A除以B</a></h4><p>本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。 </p><p><strong>输入描述</strong></p><p>输入在一行中依次给出 A 和 B，中间以 1 空格分隔。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">123456789050987654321</span> <span class="number">7</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中依次输出 Q 和 R，中间以 1 空格分隔。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">17636684150141093474</span> <span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">while</span> ((c=getchar())!= <span class="string">' '</span>)</span><br><span class="line">a[count++] = c-<span class="string">'0'</span>;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;b);</span><br><span class="line"><span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((i != <span class="number">0</span>)||(a[i]/b != <span class="number">0</span>))</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>,(carry*<span class="number">10</span>+a[i])/b);</span><br><span class="line">carry = (carry*<span class="number">10</span>+a[i])%b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">1</span>&amp;&amp;a[<span class="number">0</span>]/b==<span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"0"</span>);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">" %d"</span>,carry);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1018、锤子剪刀布"><a href="#1018、锤子剪刀布" class="headerlink" title="1018、锤子剪刀布"></a>1018、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805304020025344" target="_blank" rel="noopener">锤子剪刀布</a></h4><p>现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。 </p><p><strong>输入描述</strong></p><p>输入第 1 行给出正整数 N（≤10^5^），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。<code>C</code> 代表“锤子”、<code>J</code> 代表“剪刀”、<code>B</code> 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。 </p><blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">10</span></span><br><span class="line">&gt; C <span class="keyword">J</span></span><br><span class="line"><span class="keyword">&gt; </span><span class="keyword">J </span><span class="keyword">B</span></span><br><span class="line"><span class="keyword">&gt; </span>C <span class="keyword">B</span></span><br><span class="line"><span class="keyword">&gt; </span><span class="keyword">B </span><span class="keyword">B</span></span><br><span class="line"><span class="keyword">&gt; </span><span class="keyword">B </span>C</span><br><span class="line">&gt; C C</span><br><span class="line">&gt; C <span class="keyword">B</span></span><br><span class="line"><span class="keyword">&gt; </span><span class="keyword">J </span><span class="keyword">B</span></span><br><span class="line"><span class="keyword">&gt; </span><span class="keyword">B </span>C</span><br><span class="line">&gt; <span class="keyword">J </span><span class="keyword">J</span></span><br><span class="line"><span class="keyword">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">5</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line">&gt; <span class="number">2</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line">&gt; B B</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d\n"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> countA = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> countB = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> c1,c2;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">3</span>];</span><br><span class="line">gets(str);</span><br><span class="line">c1 = str[<span class="number">0</span>];</span><br><span class="line">c2 = str[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (c1 == <span class="string">'C'</span>&amp;&amp;c2 == <span class="string">'B'</span>) &#123;</span><br><span class="line">countB++;</span><br><span class="line">b[<span class="number">0</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c1 == <span class="string">'C'</span>&amp;&amp;c2 == <span class="string">'J'</span>) &#123;</span><br><span class="line">countA++;</span><br><span class="line">a[<span class="number">1</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c1 == <span class="string">'J'</span>&amp;&amp;c2 == <span class="string">'C'</span>) &#123;</span><br><span class="line">countB++;</span><br><span class="line">b[<span class="number">1</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c1 == <span class="string">'J'</span>&amp;&amp;c2 == <span class="string">'B'</span>) &#123;</span><br><span class="line">countA++;</span><br><span class="line">a[<span class="number">2</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c1 == <span class="string">'B'</span>&amp;&amp;c2 == <span class="string">'C'</span>) &#123;</span><br><span class="line">countA++;</span><br><span class="line">a[<span class="number">0</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c1 == <span class="string">'B'</span>&amp;&amp;c2 == <span class="string">'J'</span>) &#123;</span><br><span class="line">countB++;</span><br><span class="line">b[<span class="number">2</span>]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d %d %d\n"</span>,countA,n-(countA+countB),countB);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d %d %d\n"</span>,countB,n-(countA+countB),countA);</span><br><span class="line"><span class="keyword">char</span> flagA,flagB;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i]&gt;=a[temp])</span><br><span class="line">temp = i;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (temp == <span class="number">0</span>) flagA = <span class="string">'B'</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="number">1</span>) flagA = <span class="string">'C'</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="number">2</span>) flagA = <span class="string">'J'</span>;</span><br><span class="line">temp = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i]&gt;=b[temp])</span><br><span class="line">temp = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="number">0</span>) flagB = <span class="string">'B'</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="number">1</span>) flagB = <span class="string">'C'</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="number">2</span>) flagB = <span class="string">'J'</span>;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%c %c\n"</span>,flagA,flagB);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1019、数字黑洞"><a href="#1019、数字黑洞" class="headerlink" title="1019、数字黑洞"></a>1019、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805302786899968" target="_blank" rel="noopener">数字黑洞</a></h4><p>给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 <code>6174</code>，这个神奇的数字也叫 Kaprekar 常数。</p><p>例如，我们从<code>6767</code>开始，将得到</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7766</span> - <span class="number">6677</span> = <span class="number">1089</span></span><br><span class="line"><span class="number">9810</span> - <span class="number">0189</span> = <span class="number">9621</span></span><br><span class="line"><span class="number">9621</span> - <span class="number">1269</span> = <span class="number">8352</span></span><br><span class="line"><span class="number">8532</span> - <span class="number">2358</span> = <span class="number">6174</span></span><br><span class="line"><span class="number">7641</span> - <span class="number">1467</span> = <span class="number">6174</span></span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><p>现给定任意 4 位正整数，请编写程序演示到达黑洞的过程。</p><p><strong>输入描述</strong></p><p>输入给出一个 (0,10^4^) 区间内的正整数 N。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 6767</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>如果 N 的 4 位数字全相等，则在一行内输出 <code>N - N = 0000</code>；否则将计算的每一步在一行内输出，直到 <code>6174</code> 作为差出现，输出格式见样例。注意每个数字按 <code>4</code> 位数格式输出。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">7766</span> - <span class="number">6677</span> = <span class="number">1089</span></span><br><span class="line">&gt; <span class="number">9810</span> - <span class="number">0189</span> = <span class="number">9621</span></span><br><span class="line">&gt; <span class="number">9621</span> - <span class="number">1269</span> = <span class="number">8352</span></span><br><span class="line">&gt; <span class="number">8532</span> - <span class="number">2358</span> = <span class="number">6174</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">a[i] = n%<span class="number">10</span>;</span><br><span class="line">n /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">temp = a[j];</span><br><span class="line">a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">a[j+<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>,min = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">max = max*<span class="number">10</span>+a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">min = min*<span class="number">10</span>+a[i];</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%04d - %04d = %04d\n"</span>,max,min,max-min);</span><br><span class="line">n = max-min;</span><br><span class="line">&#125;<span class="keyword">while</span> ((n != <span class="number">6174</span>)&amp;&amp;(n != <span class="number">0</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1020、月饼"><a href="#1020、月饼" class="headerlink" title="1020、月饼"></a>1020、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805301562163200" target="_blank" rel="noopener">月饼</a></h4><p>月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。</p><p>注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。</p><p><strong>输入描述</strong></p><p>每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 D 表示市场最大需求量。随后一行给出 N 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 N 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">3</span> <span class="number">20</span></span><br><span class="line">&gt; <span class="number">18</span> <span class="number">15</span> <span class="number">10</span></span><br><span class="line">&gt; <span class="number">75</span> <span class="number">72</span> <span class="number">45</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 94.50</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d %lf"</span>,&amp;n,&amp;d);</span><br><span class="line"><span class="keyword">double</span> arr1[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">double</span> arr2[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">double</span> arr3[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入数据 </span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lf"</span>,&amp;arr1[i]);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lf"</span>,&amp;arr2[i]);</span><br><span class="line">arr3[i] = (<span class="keyword">double</span>)arr2[i] / arr1[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将单位价格由小到大排序 </span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= (n<span class="number">-1</span>); i ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (n<span class="number">-1</span>); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr3[j] &lt; arr3[j+<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">double</span> temp;</span><br><span class="line">temp = arr3[j];</span><br><span class="line">arr3[j] = arr3[j+<span class="number">1</span>];</span><br><span class="line">arr3[j+<span class="number">1</span>] = temp;</span><br><span class="line">temp = arr1[j];</span><br><span class="line">arr1[j] = arr1[j+<span class="number">1</span>];</span><br><span class="line">arr1[j+<span class="number">1</span>] = arr1[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> price = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((d-arr1[i]) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">price += d*arr3[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">price += arr1[i] * arr3[i];</span><br><span class="line">d -= arr1[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%.2lf"</span>,price);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1021、个位数统计"><a href="#1021、个位数统计" class="headerlink" title="1021、个位数统计"></a>1021、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805300404535296" target="_blank" rel="noopener">个位数统计</a></h4><p>给定一个 k 位整数 N=d(k−1)10^k−1^+⋯+d(1)10^1+d(0) (0≤di≤9, i=0,⋯,k−1, d(k−1)&gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定 N=100311，则有 2 个 0，3 个 1，和 1 个 3。 </p><p><strong>输入描述</strong></p><p>每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 N。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 100311</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>对 N 中每一种不同的个位数字，以 <code>D:M</code> 的格式在一行中输出该位数字 <code>D</code> 及其在 N 中出现的次数 <code>M</code>。要求按 <code>D</code> 的升序输出。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 0:2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 1:3</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 3:1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">gets (a);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span> (a); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((a[i]-<span class="string">'0'</span>) == j) &#123;</span><br><span class="line">b[j]++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i] == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d:%d\n"</span>,i,b[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1022、D进制的A-B"><a href="#1022、D进制的A-B" class="headerlink" title="1022、D进制的A+B"></a>1022、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805299301433344" target="_blank" rel="noopener">D进制的A+B</a></h4><p>输入两个非负 10 进制整数 A 和 B (≤2^30^−1)，输出 A+B 的 D (1&lt;D≤10)进制数。 </p><p><strong>输入描述</strong></p><p>输入在一行中依次给出 3 个整数 A、B 和 D。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">123</span> <span class="number">456</span> <span class="number">8</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>输出 A+B 的 D 进制数。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 1103</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jinzhi</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a / b == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>,a%b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jinzhi(a / b,b);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d %d %d"</span>,&amp;a,&amp;b,&amp;d);</span><br><span class="line"></span><br><span class="line">jinzhi(a+b,d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1023、组个最小数"><a href="#1023、组个最小数" class="headerlink" title="1023、组个最小数"></a>1023、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805298269634560" target="_blank" rel="noopener">组个最小数</a></h4><p>给定数字 0-9 各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意 0 不能做首位）。例如：给定两个 0，两个 1，三个 5，一个 8，我们得到的最小的数就是 10015558。</p><p>现给定数字，请编写程序输出能够组成的最小的数。</p><p><strong>输入描述</strong></p><p>输入在一行中给出 10 个非负整数，顺序表示我们拥有数字 0、数字 1、……数字 9 的个数。整数间用一个空格分隔。10 个数字的总个数不超过 50，且至少拥有 1 个非 0 的数字。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">2</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中输出能够组成的最小的数。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 10015558</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">50</span>],b[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b[i]; j++) </span><br><span class="line">a[count++] = i;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (a[k] == <span class="number">0</span>) k++;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>,a[k]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>,a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k+<span class="number">1</span>; i &lt; count; i++)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>,a[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1024、科学计数法"><a href="#1024、科学计数法" class="headerlink" title="1024、科学计数法"></a>1024、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805297229447168" target="_blank" rel="noopener">科学计数法</a></h4><p>科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表达式 [+-][1-9]<code>.</code>[0-9]+E[+-][0-9]+，即数字的整数部分只有 1 位，小数部分至少有 1 位，该数字及其指数部分的正负号即使对正数也必定明确给出。</p><p>现以科学计数法的格式给出实数 A，请编写程序按普通数字表示法输出 A，并保证所有有效位都被保留。</p><p><strong>输入描述</strong></p><p>每个输入包含 1 个测试用例，即一个以科学计数法表示的实数 A。该数字的存储长度不超过 9999 字节，且其指数的绝对值不超过 9999。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> +1.23400E-03</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>对每个测试用例，在一行中按普通数字表示法输出 A，并保证所有有效位都被保留，包括末尾的 0。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 0.00123400</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str1[<span class="number">10000</span>], str2[<span class="number">10000</span>], ch1, ch2;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>, A = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">  ch2 = getchar();                         <span class="comment">//获取正负号</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ch1 = getchar();                       <span class="comment">//获取小数部分，舍弃小数点和E,因为小数点永远在第二位，所以不需要记住小数点的位置</span></span><br><span class="line">    <span class="keyword">if</span> (ch1 == <span class="string">'.'</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ch1 != <span class="string">'E'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      str1[i] = ch1;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str2);                       <span class="comment">//获取指数部分</span></span><br><span class="line">  <span class="built_in">sscanf</span>(str2, <span class="string">"%d"</span>, &amp;A);                  <span class="comment">//将字符串转化为整数</span></span><br><span class="line">  <span class="keyword">if</span> (A &lt; <span class="number">0</span>)                               <span class="comment">//当指数小于0时</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (ch2 == <span class="string">'-'</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"-0."</span>);                       <span class="comment">//注意输出时‘+’要丢弃</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"0."</span>);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; (<span class="number">0</span> - A); j++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%c"</span>, str1[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (A == <span class="number">0</span>)                        <span class="comment">//当指数等于0时</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (ch2 == <span class="string">'-'</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (j != <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, str1[j]);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">".%c"</span>, str1[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>                                     <span class="comment">//当指数大于0时</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (ch2 == <span class="string">'-'</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"-"</span>);                         <span class="comment">//丢弃'+'号</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ((j - <span class="number">1</span>) == A)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, str1[j]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (A &gt;= i &amp;&amp;j == (i<span class="number">-1</span>))            <span class="comment">//当指数大于0且能能使第一部分的数字变为整数时</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%c"</span>, str1[j]);</span><br><span class="line">          <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;=(A - i); k++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%c"</span>, str1[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1025、反转链表"><a href="#1025、反转链表" class="headerlink" title="1025、反转链表"></a>1025、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805296180871168" target="_blank" rel="noopener">反转链表</a></h4><p>给定一个常数 K 以及一个单链表 L，请编写程序将 L 中每 K 个结点反转。例如：给定 L 为 1→2→3→4→5→6，K 为 3，则输出应该为 3→2→1→6→5→4；如果 K 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 K 个元素不反转。 </p><p><strong>输入描述</strong></p><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 N (≤105)、以及正整数 K (≤N)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p><p>接下来有 N 行，每行格式为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Address </span><span class="meta">Data</span> Next</span><br></pre></td></tr></table></figure><p>其中 <code>Address</code> 是结点地址，<code>Data</code> 是该结点保存的整数数据，<code>Next</code> 是下一结点的地址。</p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">00100</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line">&gt; <span class="number">00000</span> <span class="number">4</span> <span class="number">99999</span></span><br><span class="line">&gt; <span class="number">00100</span> <span class="number">1</span> <span class="number">12309</span></span><br><span class="line">&gt; <span class="number">68237</span> <span class="number">6</span> <span class="number">-1</span></span><br><span class="line">&gt; <span class="number">33218</span> <span class="number">3</span> <span class="number">00000</span></span><br><span class="line">&gt; <span class="number">99999</span> <span class="number">5</span> <span class="number">68237</span></span><br><span class="line">&gt; <span class="number">12309</span> <span class="number">2</span> <span class="number">33218</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">00000</span> <span class="number">4</span> <span class="number">33218</span></span><br><span class="line">&gt; <span class="number">33218</span> <span class="number">3</span> <span class="number">12309</span></span><br><span class="line">&gt; <span class="number">12309</span> <span class="number">2</span> <span class="number">00100</span></span><br><span class="line">&gt; <span class="number">00100</span> <span class="number">1</span> <span class="number">99999</span></span><br><span class="line">&gt; <span class="number">99999</span> <span class="number">5</span> <span class="number">68237</span></span><br><span class="line">&gt; <span class="number">68237</span> <span class="number">6</span> <span class="number">-1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> node[<span class="number">100000</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">list</span>[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, k, start;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;start, &amp;n, &amp;k) != EOF)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> addr, data, next;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;addr, &amp;data, &amp;next);</span><br><span class="line">      node[addr][<span class="number">0</span>] = data, node[addr][<span class="number">1</span>] = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>[<span class="number">0</span>] = start;</span><br><span class="line">    <span class="keyword">int</span> last = start;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      node[last][<span class="number">2</span>] = last;</span><br><span class="line">      last = <span class="built_in">list</span>[i] = node[last][<span class="number">1</span>];</span><br><span class="line">      count++;</span><br><span class="line">      <span class="keyword">if</span> (node[last][<span class="number">1</span>] == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s, e;</span><br><span class="line">    s = <span class="number">0</span>;</span><br><span class="line">    e = s + k;</span><br><span class="line">    <span class="keyword">while</span> (e &lt;= count &amp;&amp; e &gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = e - <span class="number">1</span>; j &gt;= s; j--)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == k - <span class="number">1</span>)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%05d %d "</span>, <span class="built_in">list</span>[j], node[<span class="built_in">list</span>[j]][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%05d\n%05d %d "</span>, <span class="built_in">list</span>[j], <span class="built_in">list</span>[j], node[<span class="built_in">list</span>[j]][<span class="number">0</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      s = e;</span><br><span class="line">      e = s + k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = s; j &lt; count; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d %d "</span>, <span class="built_in">list</span>[j], node[<span class="built_in">list</span>[j]][<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d\n%05d %d "</span>, <span class="built_in">list</span>[j], <span class="built_in">list</span>[j], node[<span class="built_in">list</span>[j]][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1026、程序运行时间"><a href="#1026、程序运行时间" class="headerlink" title="1026、程序运行时间"></a>1026、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805295203598336" target="_blank" rel="noopener">程序运行时间</a></h4><p>要获得一个 C 语言程序的运行时间，常用的方法是调用头文件 time.h，其中提供了 clock() 函数，可以捕捉从程序开始运行到 clock() 被调用时所耗费的时间。这个时间单位是 clock tick，即“时钟打点”。同时还有一个常数 CLK_TCK，给出了机器时钟每秒所走的时钟打点数。于是为了获得一个函数 f 的运行时间，我们只要在调用 f 之前先调用 clock()，获得一个时钟打点数 C1；在 f 执行完成后再调用 clock()，获得另一个时钟打点数 C2；两次获得的时钟打点数之差 (C2-C1) 就是 f 运行所消耗的时钟打点数，再除以常数 CLK_TCK，就得到了以秒为单位的运行时间。</p><p>这里不妨简单假设常数 CLK_TCK 为 100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。</p><p><strong>输入描述</strong></p><p>输入在一行中顺序给出 2 个整数 C1 和 C2。注意两次获得的时钟打点数肯定不相同，即 C1 &lt; C2，并且取值在 [0,10^7^]。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">123</span> <span class="number">4577973</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中输出被测函数运行的时间。运行时间必须按照 <code>hh:mm:ss</code>（即2位的 <code>时:分:秒</code>）格式输出；不足 1 秒的时间四舍五入到秒。 </p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 12<span class="selector-pseudo">:42</span><span class="selector-pseudo">:59</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> c1,c2;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">int</span> h,m,s;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d %d"</span>,&amp;c1,&amp;c2);</span><br><span class="line">count = (c2-c1+<span class="number">50</span>) / <span class="number">100</span>;  <span class="comment">//加50为了四舍五入 </span></span><br><span class="line">h = count / <span class="number">3600</span>;</span><br><span class="line">m = (count-h*<span class="number">3600</span>) / <span class="number">60</span>;</span><br><span class="line">s = count % <span class="number">60</span>;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%02d:%02d:%02d\n"</span>,h,m,s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1027、打印沙漏"><a href="#1027、打印沙漏" class="headerlink" title="1027、打印沙漏"></a>1027、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805294251491328" target="_blank" rel="noopener">打印沙漏</a></h4><p>本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">****<span class="strong">*</span></span><br><span class="line"><span class="strong"> *</span>*<span class="strong">*</span></span><br><span class="line"><span class="strong">  *</span></span><br><span class="line"><span class="code"> ***</span></span><br><span class="line">****<span class="strong">*</span></span><br></pre></td></tr></table></figure><p>所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。</p><p>给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。</p><p><strong>输入描述</strong></p><p>输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 19 *</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> *****</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  ***</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">   *</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  ***</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> *****</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"math.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d %c"</span>,&amp;n,&amp;c);</span><br><span class="line"><span class="keyword">if</span> ( n &lt; <span class="number">7</span>) &#123;  <span class="comment">//当n小于7时只有一行 </span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%c\n"</span>,c);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>,n<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count = n;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">//记层数 </span></span><br><span class="line">count -= <span class="number">7</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">count = <span class="number">10</span>+(i<span class="number">-1</span>)*<span class="number">4</span>+count;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">count -= (<span class="number">10</span>+i*<span class="number">4</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">n = i;</span><br><span class="line"><span class="keyword">for</span> ( ; <span class="built_in">fabs</span>(n) &gt;= <span class="number">0</span>; n--) &#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line">m = i-<span class="built_in">fabs</span>(n);</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">" "</span>);</span><br><span class="line">m = <span class="number">2</span>*<span class="built_in">fabs</span>(n)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%c"</span>,c);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">if</span> ((-n) == i)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>,count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1028、人口普查"><a href="#1028、人口普查" class="headerlink" title="1028、人口普查"></a>1028、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805293282607104" target="_blank" rel="noopener">人口普查</a></h4><p>某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。</p><p>这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。</p><p><strong>输入描述</strong></p><p>输入在第一行给出正整数 N，取值在(0,10^5^]；随后 N 行，每行给出 1 个人的姓名（由不超过 5 个英文字母组成的字符串）、以及按 <code>yyyy/mm/dd</code>（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">5</span></span><br><span class="line">&gt; John <span class="number">2001</span>/<span class="number">05</span>/<span class="number">12</span></span><br><span class="line">&gt; Tom <span class="number">1814</span>/<span class="number">09</span>/<span class="number">06</span></span><br><span class="line">&gt; Ann <span class="number">2121</span>/<span class="number">01</span>/<span class="number">30</span></span><br><span class="line">&gt; James <span class="number">1814</span>/<span class="number">09</span>/<span class="number">05</span></span><br><span class="line">&gt; Steve <span class="number">1967</span>/<span class="number">11</span>/<span class="number">20</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 3 Tom John</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, count = <span class="number">0</span>, i;</span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">6</span>], YearMonthDay[<span class="number">11</span>], Maxname[<span class="number">6</span>], Minname[<span class="number">6</span>];</span><br><span class="line">  <span class="keyword">char</span> Min[<span class="number">11</span>] = <span class="string">"1814/09/05"</span>;</span><br><span class="line">  <span class="keyword">char</span> Max[<span class="number">11</span>] = <span class="string">"2014/09/07"</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, name, YearMonthDay);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(YearMonthDay, <span class="string">"1814/09/05"</span>)&gt;<span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">"2014/09/07"</span>, YearMonthDay)&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      count++;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(YearMonthDay, Min)&gt;<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(Min, YearMonthDay);</span><br><span class="line">        <span class="built_in">strcpy</span>(Minname, name);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(Max, YearMonthDay)&gt;<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(Max, YearMonthDay);</span><br><span class="line">        <span class="built_in">strcpy</span>(Maxname, name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (count&gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %s %s\n"</span>, count, Maxname, Minname);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1029、旧键盘"><a href="#1029、旧键盘" class="headerlink" title="1029、旧键盘"></a>1029、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805292322111488" target="_blank" rel="noopener">旧键盘</a></h4><p>旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及实际被输入的文字，请你列出肯定坏掉的那些键。 </p><p><strong>输入描述</strong></p><p>输入在 2 行中分别给出应该输入的文字、以及实际被输入的文字。每段文字是不超过 80 个字符的串，由字母 A-Z（包括大、小写）、数字 0-9、以及下划线 <code>_</code>（代表空格）组成。题目保证 2 个字符串均非空。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 7_This_is_a_test</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> _hs_s_a_es</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>按照发现顺序，在一行中输出坏掉的键。其中英文字母只输出大写，每个坏键只输出一次。题目保证至少有 1 个坏键。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 7TI</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">81</span>],b[<span class="number">81</span>],c[<span class="number">81</span>];</span><br><span class="line"><span class="keyword">int</span> i,j=<span class="number">0</span>,k,t,h;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,a,b);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;a[i];i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==b[j])</span><br><span class="line">&#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">t=<span class="number">1</span>;</span><br><span class="line"><span class="comment">/*for(k=0;c[k];k++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if(c[k]==toupper(a[i]))</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">t=0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">for</span>(h=<span class="number">0</span>;h&lt;k;h++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c[h]==<span class="built_in">toupper</span>(a[i]))</span><br><span class="line">&#123;</span><br><span class="line">t=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">c[k++]=<span class="built_in">toupper</span>(a[i]);</span><br><span class="line">c[k]=<span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf("%d\n",k);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;c[i];i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,c[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1030、完美数列"><a href="#1030、完美数列" class="headerlink" title="1030、完美数列"></a>1030、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805291311284224" target="_blank" rel="noopener">完美数列</a></h4><p>给定一个正整数数列，和正整数 p，设这个数列中的最大值是 M，最小值是 m，如果 M≤mp，则称这个数列是完美数列。</p><p>现在给定参数 p 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。</p><p><strong>输入描述</strong></p><p>输入第一行给出两个正整数 N 和 p，其中 N（≤10^5^）是输入的正整数的个数，p（≤10^9^）是给定的参数。第二行给出 N 个正整数，每个数不超过 10^9^。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">10</span> <span class="number">8</span></span><br><span class="line">&gt; <span class="number">2</span> <span class="number">3</span> <span class="number">20</span> <span class="number">4</span> <span class="number">5</span> <span class="number">1</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 8</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span> v[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> v[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> arr[<span class="number">100000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="keyword">int</span> i, j, count = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">double</span> N, P, temp;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;N, &amp;P);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  qsort(arr, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;  N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    temp = arr[i] * P;</span><br><span class="line">      <span class="keyword">for</span> (j = count; j&lt;N; j++) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j]&gt;temp)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> (j - i &gt;= max)</span><br><span class="line">           max = j - i + <span class="number">1</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">    count = j;  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span> v[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span>        <span class="comment">// #include &lt;stdlib.h&gt; 中有 qsort这个函数 不需要自己写 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, last;</span><br><span class="line">  <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  swap(v, left, (left + right) / <span class="number">2</span>);</span><br><span class="line">  last = left;</span><br><span class="line">  <span class="keyword">for</span> (i = left + <span class="number">1</span>; i &lt;= right; i++)</span><br><span class="line">    <span class="keyword">if</span> (v[i] &lt; v[left])</span><br><span class="line">      swap(v, ++last, i);</span><br><span class="line">  swap(v, left, last);</span><br><span class="line">  qsort(v, left, last - <span class="number">1</span>);</span><br><span class="line">  qsort(v, last + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> v[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">  temp = v[i];</span><br><span class="line">  v[i] = v[j];</span><br><span class="line">  v[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1031、查验身份证"><a href="#1031、查验身份证" class="headerlink" title="1031、查验身份证"></a>1031、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805290334011392" target="_blank" rel="noopener">查验身份证</a></h4><p>一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：</p><p>首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值<code>Z</code>；最后按照以下关系对应<code>Z</code>值与校验码<code>M</code>的值：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z：<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">M：<span class="number">1</span> <span class="number">0</span> X <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。</p><p><strong>输入描述</strong></p><p>输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 4</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 320124198808240056</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 12010X198901011234</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 110108196711301866</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 37070419881216001X</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出<code>All passed</code>。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 12010X198901011234</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 110108196711301866</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 37070419881216001X</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ID[<span class="number">100</span>][<span class="number">19</span>];</span><br><span class="line">  <span class="keyword">char</span> arr1[<span class="number">19</span>];</span><br><span class="line">  <span class="keyword">char</span> Z[<span class="number">11</span>] = &#123; <span class="string">'1'</span>,<span class="string">'0'</span>,<span class="string">'X'</span>,<span class="string">'9'</span>,<span class="string">'8'</span>,<span class="string">'7'</span>,<span class="string">'6'</span>,<span class="string">'5'</span>,<span class="string">'4'</span>,<span class="string">'3'</span>,<span class="string">'2'</span> &#125;;</span><br><span class="line">  <span class="keyword">int</span> N, i, j, cnt, flag = <span class="number">0</span>, flag1 = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> arr[<span class="number">17</span>] = &#123; <span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span> &#125;;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;N ; i++)</span><br><span class="line">  &#123;    </span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">17</span>; j++)                <span class="comment">// 将前17位加权求和 如果中间有非数字 则将它标记为1</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;arr1[j]);</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">'0'</span> &lt;= arr1[j] &amp;&amp; arr1[j] &lt;= <span class="string">'9'</span>)</span><br><span class="line">        count += arr[j] * (arr1[j] - <span class="number">48</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        flag1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    count = count % <span class="number">11</span>;                     <span class="comment">// 求Z值</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;arr1[<span class="number">17</span>]);                 <span class="comment">//保存最后一位</span></span><br><span class="line">    arr1[<span class="number">18</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr1[<span class="number">17</span>]!= Z[count++] || flag1 == <span class="number">1</span>)   <span class="comment">//如果Z与校验码不相等或者是该字符串被标记为1 则保存</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">strcpy</span>(ID[flag], arr1);</span><br><span class="line">      flag1 = <span class="number">0</span>;</span><br><span class="line">      flag++;                                  <span class="comment">//flag计数器 记录有几条字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"All passed"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; flag; i++)                 <span class="comment">//输出</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ID[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1032、挖掘机技术哪家强"><a href="#1032、挖掘机技术哪家强" class="headerlink" title="1032、挖掘机技术哪家强"></a>1032、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805289432236032" target="_blank" rel="noopener">挖掘机技术哪家强</a></h4><p>为了用事实说明挖掘机技术到底哪家强，PAT 组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。 </p><p><strong>输入描述</strong></p><p>输入在第 1 行给出不超过 10^5^ 的正整数 N，即参赛人数。随后 N 行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从 1 开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">6</span></span><br><span class="line">&gt; <span class="number">3</span> <span class="number">65</span></span><br><span class="line">&gt; <span class="number">2</span> <span class="number">80</span></span><br><span class="line">&gt; <span class="number">1</span> <span class="number">100</span></span><br><span class="line">&gt; <span class="number">2</span> <span class="number">70</span></span><br><span class="line">&gt; <span class="number">3</span> <span class="number">40</span></span><br><span class="line">&gt; <span class="number">3</span> <span class="number">0</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">2</span> <span class="number">150</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i,max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d %d"</span>,&amp;i,&amp;x);</span><br><span class="line"><span class="keyword">if</span> (i &gt; max) max = i;</span><br><span class="line">a[i<span class="number">-1</span>] += x;</span><br><span class="line">&#125;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; max<span class="number">-1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[i]) i = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d %d\n"</span>,i+<span class="number">1</span>,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1033、旧键盘打字"><a href="#1033、旧键盘打字" class="headerlink" title="1033、旧键盘打字"></a>1033、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805288530460672" target="_blank" rel="noopener">旧键盘打字</a></h4><p>旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？ </p><p><strong>输入描述</strong></p><p>输入在 2 行中分别给出坏掉的那些键、以及应该输入的文字。其中对应英文字母的坏键以大写给出；每段文字是不超过 105 个字符的串。可用的字符包括字母 [<code>a</code>-<code>z</code>, <code>A</code>-<code>Z</code>]、数字 <code>0</code>-<code>9</code>、以及下划线 <code>_</code>（代表空格）、<code>,</code>、<code>.</code>、<code>-</code>、<code>+</code>（代表上档键）。题目保证第 2 行输入的文字串非空。</p><p>注意：如果上档键坏掉了，那么大写的英文字母无法被打出。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 7+IE.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 7_This_is_a_test.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> _hs_s_a_tst</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str[<span class="number">67</span>];</span><br><span class="line"> <span class="keyword">char</span> ch;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>, flag = <span class="number">0</span>, flag1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   ch = getchar();</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'\n'</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'+'</span>)                        <span class="comment">// 将坏掉的那些键存入字符串 大写的因为字母改成小写 如果有‘+’号 则标记一下，不存入字符串</span></span><br><span class="line">      flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">65</span> &lt;= ch&amp;&amp;ch &lt;= <span class="number">90</span>)</span><br><span class="line">        ch = ch + <span class="number">32</span>;</span><br><span class="line">      str[i] = ch;</span><br><span class="line">      i++;          </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)           </span><br><span class="line">  &#123;</span><br><span class="line">    ch = getchar();</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'\n'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (flag1 == <span class="number">0</span>)             <span class="comment">// 如果flag1为0 则说明没有字符串输出 ，这里就必须要输入空行，不然过不了第三个检查点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>)              <span class="comment">// 当有‘+’号时 大写的因为字符一律不输出</span></span><br><span class="line">      <span class="keyword">if</span> (ch &lt; <span class="number">65</span> || ch&gt;<span class="number">90</span>)</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (ch == str[j])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">if</span> (j &gt; i)       <span class="comment">// 将每个输入的字符与坏的键比较一下 比较成功则不输出</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(ch);</span><br><span class="line">            flag1++;      <span class="comment">// 输出了就标记一下</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          j++;              </span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="number">1</span>)          <span class="comment">// 当没有'+'号时 </span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">65</span> &lt;= ch&amp;&amp;ch &lt;= <span class="number">90</span>)  <span class="comment">//  因为坏的那些键全部是存的小写字母，所以朋友输入的字符是大写的就需要转换成小写再比较</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (ch + <span class="number">32</span> == str[j])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>  <span class="keyword">if</span> (ch == str[j])</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; i)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">putchar</span>(ch);   </span><br><span class="line">          flag1++;            <span class="comment">//输出了就标记一下</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1034、有理数四则运算"><a href="#1034、有理数四则运算" class="headerlink" title="1034、有理数四则运算"></a>1034、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805287624491008" target="_blank" rel="noopener">有理数四则运算</a></h4><p>本题要求编写程序，计算 2 个有理数的和、差、积、商。 </p><p><strong>输入描述</strong></p><p>输入在一行中按照 <code>a1/b1 a2/b2</code> 的格式给出两个分数形式的有理数，其中分子和分母全是整型范围内的整数，负号只可能出现在分子前，分母不为 0。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">2</span>/<span class="number">3</span> <span class="number">-4</span>/<span class="number">2</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>分别在 4 行中按照 <code>有理数1 运算符 有理数2 = 结果</code> 的格式顺序输出 2 个有理数的和、差、积、商。注意输出的每个有理数必须是该有理数的最简形式 <code>k a/b</code>，其中 <code>k</code> 是整数部分，<code>a/b</code> 是最简分数部分；若为负数，则须加括号；若除法分母为 0，则输出 <code>Inf</code>。题目保证正确的输出中没有超过整型范围的整数。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">2</span>/<span class="number">3</span> + (<span class="number">-2</span>) = (<span class="number">-1</span> <span class="number">1</span>/<span class="number">3</span>)</span><br><span class="line">&gt; <span class="number">2</span>/<span class="number">3</span> - (<span class="number">-2</span>) = <span class="number">2</span> <span class="number">2</span>/<span class="number">3</span></span><br><span class="line">&gt; <span class="number">2</span>/<span class="number">3</span> * (<span class="number">-2</span>) = (<span class="number">-1</span> <span class="number">1</span>/<span class="number">3</span>)</span><br><span class="line">&gt; <span class="number">2</span>/<span class="number">3</span> / (<span class="number">-2</span>) = (<span class="number">-1</span>/<span class="number">3</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;  <span class="comment">//求最大公约数 </span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> m = a%b;</span><br><span class="line"><span class="keyword">while</span> (m) &#123;</span><br><span class="line">a = b;</span><br><span class="line">b = m;</span><br><span class="line">m = a%b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Print</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;  <span class="comment">//将分数输出函数 </span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"Inf"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">a = -a;</span><br><span class="line">flag = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> gcd = GCD(a,b);</span><br><span class="line">a /= gcd;</span><br><span class="line">b /= gcd;</span><br><span class="line"><span class="keyword">if</span> (a / b == <span class="number">0</span>&amp;&amp;a != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (flag &lt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"(-%lld/%lld)"</span>,a,b);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld/%lld"</span>,a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">flag = flag*a/b;</span><br><span class="line">a %= b;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">1</span>&amp;&amp;flag &lt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"(%lld)"</span>,flag);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">1</span>&amp;&amp;flag &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld"</span>,flag);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flag &lt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"(%lld %lld/%lld)"</span>,flag,a,b);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld %lld/%lld"</span>,flag,a,b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a1,<span class="keyword">long</span> <span class="keyword">long</span> b1,<span class="keyword">long</span> <span class="keyword">long</span> a2,<span class="keyword">long</span> <span class="keyword">long</span> b2,<span class="keyword">char</span> ch)</span> </span>&#123;  <span class="comment">//计算分数运算函数 </span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> c1;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> c2;</span><br><span class="line">Print(a1,b1);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">" %c "</span>,ch);</span><br><span class="line">Print(a2,b2);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">" = "</span>);</span><br><span class="line"><span class="keyword">switch</span>(ch) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">c1 = a1*b2+a2*b1;</span><br><span class="line">c2 = b1*b2;</span><br><span class="line">Print(c1,c2);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">c1 = a1*b2-a2*b1;</span><br><span class="line">c2 = b1*b2;</span><br><span class="line">Print(c1,c2);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">c1 = a1*a2;</span><br><span class="line">c2 = b1*b2;</span><br><span class="line">Print(c1,c2);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">c1 = a1*b2;</span><br><span class="line">c2 = b1*a2;</span><br><span class="line"><span class="keyword">if</span> (c2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">c2 = -c2;</span><br><span class="line">c1 = -c1;</span><br><span class="line">&#125;</span><br><span class="line">Print(c1,c2);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a1,b1,a2,b2;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lld/%lld %lld/%lld"</span>,&amp;a1,&amp;b1,&amp;a2,&amp;b2);</span><br><span class="line">count(a1,b1,a2,b2,<span class="string">'+'</span>);</span><br><span class="line">count(a1,b1,a2,b2,<span class="string">'-'</span>);</span><br><span class="line">count(a1,b1,a2,b2,<span class="string">'*'</span>);</span><br><span class="line">count(a1,b1,a2,b2,<span class="string">'/'</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1035、插入与归并"><a href="#1035、插入与归并" class="headerlink" title="1035、插入与归并"></a>1035、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805286714327040" target="_blank" rel="noopener">插入与归并</a></h4><p>根据维基百科的定义：</p><p><strong>插入排序</strong>是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。</p><p><strong>归并排序</strong>进行如下迭代操作：首先将原始序列看成 N 个只包含 1 个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下 1 个有序的序列。</p><p>现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？</p><p><strong>输入描述</strong></p><p>输入在第一行给出正整数 N (≤100)；随后一行给出原始序列的 N 个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">10</span></span><br><span class="line">&gt; <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">8</span> <span class="number">7</span> <span class="number">5</span> <span class="number">9</span> <span class="number">4</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line">&gt; <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span> <span class="number">9</span> <span class="number">4</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>首先在第 1 行中输出<code>Insertion Sort</code>表示插入排序、或<code>Merge Sort</code>表示归并排序；然后在第 2 行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行首尾不得有多余空格。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; Insertion Sort</span><br><span class="line">&gt; <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">4</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*a, <span class="keyword">const</span> <span class="keyword">void</span>*b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//freopen("input.txt", "r", stdin);</span></span><br><span class="line">  <span class="comment">//freopen("output.txt", "w", stdout);</span></span><br><span class="line">  <span class="keyword">int</span> n, *a, *b, i, j, k = <span class="number">1</span>, flag = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">  b = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span> &amp;&amp; b[i] &lt;= b[i + <span class="number">1</span>]; i++);</span><br><span class="line">  <span class="keyword">for</span> (j = i + <span class="number">1</span>; a[j] == b[j] &amp;&amp; j &lt; n; j++);</span><br><span class="line">  <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Insertion Sort\n"</span>);</span><br><span class="line">    qsort(a, i + <span class="number">2</span>,<span class="keyword">sizeof</span>(a[<span class="number">0</span>]),cmp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Merge Sort\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">      flag = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] != b[i])</span><br><span class="line">          flag = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      k = k * <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n / k; i++)</span><br><span class="line">        qsort(a + i * k, k,<span class="keyword">sizeof</span>(a[<span class="number">0</span>]),cmp);</span><br><span class="line">      qsort(a + n / k * k, n-n/k*k, <span class="keyword">sizeof</span>(a[<span class="number">0</span>]),cmp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, a[n - <span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1036、跟奥巴马一起编程"><a href="#1036、跟奥巴马一起编程" class="headerlink" title="1036、跟奥巴马一起编程"></a>1036、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805285812551680" target="_blank" rel="noopener">跟奥巴马一起编程</a></h4><p>美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014 年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！ </p><p><strong>输入描述</strong></p><p>输入在一行中给出正方形边长 N（3≤N≤20）和组成正方形边的某种字符 C，间隔一个空格。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 10 a</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>输出由给定字符 C 画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的 50%（四舍五入取整）。 </p><blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; aaaaaaaaaa</span><br><span class="line">&gt; <span class="selector-tag">a</span>        a</span><br><span class="line">&gt; <span class="selector-tag">a</span>        a</span><br><span class="line">&gt; <span class="selector-tag">a</span>        a</span><br><span class="line">&gt; aaaaaaaaaa</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d %c"</span>,&amp;n,&amp;c);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%c"</span>,c);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (n%<span class="number">2</span> == <span class="number">0</span>? (n/<span class="number">2</span>)<span class="number">-1</span>:n/<span class="number">2</span>); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span>||j == n<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%c"</span>,c);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%c"</span>,c);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1037、在霍格沃茨找零钱"><a href="#1037、在霍格沃茨找零钱" class="headerlink" title="1037、在霍格沃茨找零钱"></a>1037、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805284923359232" target="_blank" rel="noopener">在霍格沃茨找零钱</a></h4><p>如果你是哈利·波特迷，你会知道魔法世界有它自己的货币系统 —— 就如海格告诉哈利的：“十七个银西可(Sickle)兑一个加隆(Galleon)，二十九个纳特(Knut)兑一个西可，很容易。”现在，给定哈利应付的价钱 P 和他实付的钱 A，你的任务是写一个程序来计算他应该被找的零钱。 </p><p><strong>输入描述</strong></p><p>输入在 1 行中分别给出 P 和 A，格式为 <code>Galleon.Sickle.Knut</code>，其间用 1 个空格分隔。这里 <code>Galleon</code> 是 [0, 107] 区间内的整数，<code>Sickle</code> 是 [0, 17) 区间内的整数，<code>Knut</code> 是 [0, 29) 区间内的整数。 </p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 10<span class="selector-class">.16</span><span class="selector-class">.27</span> 14<span class="selector-class">.1</span><span class="selector-class">.28</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中用与输入同样的格式输出哈利应该被找的零钱。如果他没带够钱，那么输出的应该是负数。 </p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 3<span class="selector-class">.2</span><span class="selector-class">.1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> G1, S1, K1;</span><br><span class="line">  <span class="keyword">int</span> G2, S2, K2;</span><br><span class="line">  <span class="keyword">double</span> Count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">double</span> P, A;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d.%d.%d"</span>, &amp;G1, &amp;S1, &amp;K1);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d.%d.%d"</span>, &amp;G2, &amp;S2, &amp;K2);</span><br><span class="line">  P = G1 * <span class="number">17</span> * <span class="number">29</span> + S1 * <span class="number">29</span> + K1;</span><br><span class="line">  A = G2 * <span class="number">17</span> * <span class="number">29</span> + S2 * <span class="number">29</span> + K2;</span><br><span class="line">  Count = A - P;                                       <span class="comment">//纳特的剩余个数</span></span><br><span class="line">  <span class="keyword">if</span> (Count &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d.%d.%d"</span>, (<span class="keyword">int</span>)(Count / (<span class="number">17</span> * <span class="number">29</span>)), ((<span class="keyword">int</span>)Count / <span class="number">29</span>) % <span class="number">17</span>, ((<span class="keyword">int</span>)Count) % <span class="number">29</span>);        <span class="comment">//分正负输出</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    Count = -Count;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-%d.%d.%d"</span>, (<span class="keyword">int</span>)(Count / (<span class="number">17</span> * <span class="number">29</span>)), ((<span class="keyword">int</span>)Count / <span class="number">29</span>) % <span class="number">17</span>, ((<span class="keyword">int</span>)Count) % <span class="number">29</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1038、统计同成绩学生"><a href="#1038、统计同成绩学生" class="headerlink" title="1038、统计同成绩学生"></a>1038、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805284092887040" target="_blank" rel="noopener">统计同成绩学生</a></h4><p>本题要求读入 N 名学生的成绩，将获得某一给定分数的学生人数输出。 </p><p><strong>输入描述</strong></p><p>输入在第 1 行给出不超过 10^5^ 的正整数 N，即学生总人数。随后一行给出 N 名学生的百分制整数成绩，中间以空格分隔。最后一行给出要查询的分数个数 K（不超过 N 的正整数），随后是 K 个分数，中间以空格分隔。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">10</span></span><br><span class="line">&gt; <span class="number">60</span> <span class="number">75</span> <span class="number">90</span> <span class="number">55</span> <span class="number">75</span> <span class="number">99</span> <span class="number">82</span> <span class="number">90</span> <span class="number">75</span> <span class="number">50</span></span><br><span class="line">&gt; <span class="number">3</span> <span class="number">75</span> <span class="number">90</span> <span class="number">88</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中按查询顺序给出得分等于指定分数的学生人数，中间以空格分隔，但行末不得有多余空格。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">3</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> count [<span class="number">101</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;value);</span><br><span class="line">count[value] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100000</span>];</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) </span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> t = a[i];</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) <span class="built_in">printf</span> (<span class="string">"%d"</span>,count[t]);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">" %d"</span>,count[t]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1039、到底买不买"><a href="#1039、到底买不买" class="headerlink" title="1039、到底买不买"></a>1039、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805283241443328" target="_blank" rel="noopener">到底买不买</a></h4><p>小红想买些珠子做一串自己喜欢的珠串。卖珠子的摊主有很多串五颜六色的珠串，但是不肯把任何一串拆散了卖。于是小红要你帮忙判断一下，某串珠子里是否包含了全部自己想要的珠子？如果是，那么告诉她有多少多余的珠子；如果不是，那么告诉她缺了多少珠子。</p><p>为方便起见，我们用[0-9]、[a-z]、[A-Z]范围内的字符来表示颜色。例如在图1中，第3串是小红想做的珠串；那么第1串可以买，因为包含了全部她想要的珠子，还多了8颗不需要的珠子；第2串不能买，因为没有黑色珠子，并且少了一颗红色的珠子。</p><p><img src="/2020/12/10/PAT-Basic-Level-Practice-中文/1.jpg" alt></p><p><strong>输入描述</strong></p><p>每个输入包含 1 个测试用例。每个测试用例分别在 2 行中先后给出摊主的珠串和小红想做的珠串，两串都不超过 1000 个珠子。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ppRYYGrrYBR2258</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> YrR8RrY</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>如果可以买，则在一行中输出 <code>Yes</code> 以及有多少多余的珠子；如果不可以买，则在一行中输出 <code>No</code> 以及缺了多少珠子。其间以 1 个空格分隔。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Yes 8</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">123</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> count1 = <span class="number">0</span>;  <span class="comment">//珠子的个数</span></span><br><span class="line"><span class="keyword">int</span> count2 = <span class="number">0</span>;  <span class="comment">//剩余珠子的个数</span></span><br><span class="line"><span class="keyword">int</span> count3 = <span class="number">0</span>;  <span class="comment">//缺少的珠子的个数 </span></span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = getchar()) != <span class="string">'\n'</span>) &#123;</span><br><span class="line">arr[c]++;</span><br><span class="line">count1++;</span><br><span class="line">&#125;</span><br><span class="line">count2 = count1;</span><br><span class="line"><span class="keyword">while</span> ((c = getchar()) != <span class="string">'\n'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[c] != <span class="number">0</span>) &#123;</span><br><span class="line">arr[c]--;</span><br><span class="line">count2--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">count3++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count3 == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"Yes %d"</span>,count2);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"No %d"</span>,count3);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1040、有几个PAT"><a href="#1040、有几个PAT" class="headerlink" title="1040、有几个PAT"></a>1040、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805282389999616" target="_blank" rel="noopener">有几个PAT</a></h4><p>字符串 <code>APPAPT</code> 中包含了两个单词 <code>PAT</code>，其中第一个 <code>PAT</code> 是第 2 位(<code>P</code>)，第 4 位(<code>A</code>)，第 6 位(<code>T</code>)；第二个 <code>PAT</code> 是第 3 位(<code>P</code>)，第 4 位(<code>A</code>)，第 6 位(<code>T</code>)。</p><p>现给定字符串，问一共可以形成多少个 <code>PAT</code>？</p><p><strong>输入描述</strong></p><p>输入只有一行，包含一个字符串，长度不超过105，只包含 <code>P</code>、<code>A</code>、<code>T</code> 三种字母。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> APPAPT</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中输出给定字符串中包含多少个 <code>PAT</code>。由于结果可能比较大，只输出对 1000000007 取余数的结果。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> countt = <span class="number">0</span>,countp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) != <span class="string">'\n'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'P'</span>)</span><br><span class="line">str[i++] = ch;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'A'</span>)</span><br><span class="line">str[i++] = ch;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'T'</span>) &#123;</span><br><span class="line">countt++;</span><br><span class="line">str[i++] = ch;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">str[i] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span> (str); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">'A'</span>)</span><br><span class="line">count = (count+(countt*countp))%<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">'P'</span>)</span><br><span class="line">countp++;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">'T'</span>)</span><br><span class="line">countt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>,count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1041、考试座位号"><a href="#1041、考试座位号" class="headerlink" title="1041、考试座位号"></a>1041、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805281567916032" target="_blank" rel="noopener">考试座位号</a></h4><p>每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。 </p><p><strong>输入描述</strong></p><p>输入第一行给出一个正整数 N（≤1000），随后 N 行，每行给出一个考生的信息：<code>准考证号 试机座位号 考试座位号</code>。其中<code>准考证号</code>由 16 位数字组成，座位从 1 到 N 编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。</p><p>考生信息之后，给出一个正整数 M（≤N），随后一行中给出 M 个待查询的试机座位号码，以空格分隔。</p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">4</span></span><br><span class="line">&gt; <span class="number">3310120150912233</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line">&gt; <span class="number">3310120150912119</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line">&gt; <span class="number">3310120150912126</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line">&gt; <span class="number">3310120150912002</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line">&gt; <span class="number">2</span></span><br><span class="line">&gt; <span class="number">3</span> <span class="number">4</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用 1 个空格分隔。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">3310120150912002</span> <span class="number">2</span></span><br><span class="line">&gt; <span class="number">3310120150912119</span> <span class="number">1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> arr[<span class="number">1001</span>][<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;         <span class="comment">// 保存信息</span></span><br><span class="line">  <span class="keyword">int</span> arr1[<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;;              <span class="comment">//保存需要输出的试机座位号</span></span><br><span class="line">  <span class="keyword">int</span> N, M, i, j, k;</span><br><span class="line">  <span class="keyword">double</span> ID, SJ, KS;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>, &amp;ID, &amp;SJ, &amp;KS);</span><br><span class="line">    arr[(<span class="keyword">int</span>)SJ][<span class="number">0</span>] = ID;</span><br><span class="line">    arr[(<span class="keyword">int</span>)SJ][<span class="number">1</span>] = KS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;M);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr1[i]);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.0lf %.0lf\n"</span>, arr[arr1[i]][<span class="number">0</span>], arr[arr1[i]][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1042、字符统计"><a href="#1042、字符统计" class="headerlink" title="1042、字符统计"></a>1042、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805280817135616" target="_blank" rel="noopener">字符统计</a></h4><p>请编写程序，找出一段给定文字中出现最频繁的那个英文字母。 </p><p><strong>输入描述</strong></p><p>输入在一行中给出一个长度不超过 1000 的字符串。字符串由 ASCII 码表中任意可见字符及空格组成，至少包含 1 个英文字母，以回车结束（回车不算在内）。 </p><blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; This is a<span class="built_in"> simple </span>TEST.  There ARE numbers <span class="keyword">and</span> other symbols 1&amp;2&amp;3<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中输出出现频率最高的那个英文字母及其出现次数，其间以空格分隔。如果有并列，则输出按字母序最小的那个字母。统计时不区分大小写，输出小写字母。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> e 7</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span> ( (c= getchar()) != <span class="string">'\n'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (c &gt;= <span class="number">65</span>&amp;&amp;c &lt;= <span class="number">90</span>)</span><br><span class="line">arr[c+<span class="number">32</span>]++;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">arr[c]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">128</span>; i &gt;= <span class="number">97</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt;= arr[max])</span><br><span class="line">max = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%c %d"</span>,max,arr[max]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1043、输出PATest"><a href="#1043、输出PATest" class="headerlink" title="1043、输出PATest"></a>1043、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805280074743808" target="_blank" rel="noopener">输出PATest</a></h4><p>给定一个长度不超过 10^4^ 的、仅由英文字母构成的字符串。请将字符重新调整顺序，按 <code>PATestPATest....</code> 这样的顺序输出，并忽略其它字符。当然，六种字符的个数不一定是一样多的，若某种字符已经输出完，则余下的字符仍按 PATest 的顺序打印，直到所有字符都被输出。 </p><p><strong>输入描述</strong></p><p>输入在一行中给出一个长度不超过 10^4^ 的、仅由英文字母构成的非空字符串。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> redlesPayBestPATTopTeePHPereatitAPPT</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中按题目要求输出排序后的字符串。题目保证输出非空。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> PATestPATestPTetPTePePee</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">int</span> countP = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> countA = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> countT = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> counte = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> counts = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> countt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((ch = getchar ()) != <span class="string">'\n'</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span>(ch) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'P'</span>:countP++; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'A'</span>:countA++; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'T'</span>:countT++; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'e'</span>:counte++; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'s'</span>:counts++; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'t'</span>:countt++; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ((countP)||(countA)||(countT)||(counte)||(counts)||(countt)) &#123;</span><br><span class="line"><span class="keyword">if</span> (countP) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"P"</span>);</span><br><span class="line">countP--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (countA) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"A"</span>);</span><br><span class="line">countA--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (countT) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"T"</span>);</span><br><span class="line">countT--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (counte) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"e"</span>);</span><br><span class="line">counte--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (counts) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"s"</span>);</span><br><span class="line">counts--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (countt) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"t"</span>);</span><br><span class="line">countt--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1044、火星数字"><a href="#1044、火星数字" class="headerlink" title="1044、火星数字"></a>1044、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805279328157696" target="_blank" rel="noopener">火星数字</a></h4><p>火星人是以 13 进制计数的：</p><ul><li>地球人的 0 被火星人称为 tret。</li><li>地球人数字 1 到 12 的火星文分别为：jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec。</li><li>火星人将进位以后的 12 个高位数字分别称为：tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou。</li></ul><p>例如地球人的数字 <code>29</code> 翻译成火星文就是 <code>hel mar</code>；而火星文 <code>elo nov</code> 对应地球数字 <code>115</code>。为了方便交流，请你编写程序实现地球和火星数字之间的互译。</p><p><strong>输入描述</strong></p><p>输入第一行给出一个正整数 N（&lt;100），随后 N 行，每行给出一个 [0, 169) 区间内的数字 —— 或者是地球文，或者是火星文。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 4</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 29</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> elo nov</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> tam</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>对应输入的每一行，在一行中输出翻译后的另一种语言的数字。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> hel mar</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> may</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 115</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 13</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str[<span class="number">13</span>][<span class="number">5</span>] = &#123; <span class="string">""</span>,<span class="string">"tam"</span>, <span class="string">"hel"</span>, <span class="string">"maa"</span>, <span class="string">"huh"</span>, <span class="string">"tou"</span>, <span class="string">"kes"</span>, <span class="string">"hei"</span>, <span class="string">"elo"</span>, <span class="string">"syy"</span>, <span class="string">"lok"</span>, <span class="string">"mer"</span>, <span class="string">"jou"</span> &#125;;</span><br><span class="line">  <span class="keyword">char</span> str1[<span class="number">13</span>][<span class="number">5</span>] = &#123; <span class="string">"tret"</span>, <span class="string">"jan"</span>, <span class="string">"feb"</span>, <span class="string">"mar"</span>,<span class="string">"apr"</span>, <span class="string">"may"</span>, <span class="string">"jun"</span>, <span class="string">"jly"</span>, <span class="string">"aug"</span>, <span class="string">"sep"</span>, <span class="string">"oct"</span>, <span class="string">"nov"</span>, <span class="string">"dec"</span> &#125;;</span><br><span class="line">  <span class="keyword">char</span> str2[<span class="number">10</span>], str3[<span class="number">10</span>], str4[<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">char</span> out[<span class="number">100</span>][<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">int</span> i, N, Num, Num1, Num2, j = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">while</span> (N--)</span><br><span class="line">  &#123;</span><br><span class="line">    gets(str2);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isalpha</span>(str2[<span class="number">0</span>]) == <span class="number">0</span>) <span class="comment">//  判断是不是数字</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">sscanf</span>(str2, <span class="string">"%d"</span>, &amp;Num);</span><br><span class="line">      <span class="keyword">if</span> (Num &lt; <span class="number">13</span>)</span><br><span class="line">        <span class="built_in">sprintf</span>(out[j], <span class="string">"%s"</span>, str1[Num]);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (Num == <span class="number">13</span>)</span><br><span class="line">        <span class="built_in">sprintf</span>(out[j], <span class="string">"tam"</span>);</span><br><span class="line">      <span class="keyword">else</span>  <span class="keyword">if</span> (Num % <span class="number">13</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">sprintf</span>(out[j], <span class="string">"%s"</span>, str[(Num - Num % <span class="number">13</span>) / <span class="number">13</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">sprintf</span>(out[j], <span class="string">"%s %s"</span>, str[(Num-Num%<span class="number">13</span>) / <span class="number">13</span>], str1[Num%<span class="number">13</span>]);   <span class="comment">//这里先取余再取整  直接除的话 167好像就就不行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strlen</span>(str2) &gt;= <span class="number">5</span>)                      <span class="comment">//字符串大于5就是 2位数了</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">sscanf</span>(str2, <span class="string">"%s%s"</span>, str3, str4);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">strcmp</span>(str3, str[i]) == <span class="number">0</span>)</span><br><span class="line">            Num1 = i;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">strcmp</span>(str4, str1[i]) == <span class="number">0</span>)</span><br><span class="line">            Num2 = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sprintf</span>(out[j], <span class="string">"%d"</span>, Num1 * <span class="number">13</span> + Num2);   </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>                                         <span class="comment">// 一位数</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i++)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(str2, str1[i]) == <span class="number">0</span>)</span><br><span class="line">              <span class="built_in">sprintf</span>(out[j], <span class="string">"%d"</span>,i);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(str2, str[i]) == <span class="number">0</span>)</span><br><span class="line">              <span class="built_in">sprintf</span>(out[j], <span class="string">"%d"</span>, i*<span class="number">13</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; j; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, out[i]);                      <span class="comment">//输出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1045、快速排序"><a href="#1045、快速排序" class="headerlink" title="1045、快速排序"></a>1045、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805278589960192" target="_blank" rel="noopener">快速排序</a></h4><p>著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的 N 个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？</p><p>例如给定 $N = 5$, 排列是1、3、2、4、5。则：</p><ul><li>1 的左边没有元素，右边的元素都比它大，所以它可能是主元；</li><li>尽管 3 的左边元素都比它小，但其右边的 2 比它小，所以它不能是主元；</li><li>尽管 2 的右边元素都比它大，但其左边的 3 比它大，所以它不能是主元；</li><li>类似原因，4 和 5 都可能是主元。</li></ul><p>因此，有 3 个元素可能是主元。</p><p><strong>输入描述</strong></p><p>输入在第 1 行中给出一个正整数 N（≤10^5^）； 第 2 行是空格分隔的 N 个不同的正整数，每个数不超过 10^9^。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">5</span></span><br><span class="line">&gt; <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在第 1 行中输出有可能是主元的元素个数；在第 2 行中按递增顺序输出这些元素，其间以 1 个空格分隔，行首尾不得有多余空格。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">3</span></span><br><span class="line">&gt; <span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a,<span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> *((<span class="keyword">int</span> *)a)-*((<span class="keyword">int</span> *)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num[<span class="number">100000</span>],temp[<span class="number">100000</span>],result[<span class="number">100000</span>],*p_result=result,i,j,n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,num+i);</span><br><span class="line">    temp[i]=num[i];</span><br><span class="line">  &#125;</span><br><span class="line">  qsort(temp,n,<span class="keyword">sizeof</span>(<span class="keyword">int</span>),compare);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(temp[i]==num[i])</span><br><span class="line">    &#123;</span><br><span class="line">      *(p_result++)=i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n&amp;&amp;j&lt;p_result-result;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;result[j]&amp;&amp;num[i]&lt;num[result[j]])</span><br><span class="line">      ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=result[j])</span><br><span class="line">      j++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num[i]&gt;num[result[j]])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span>(num[i]&gt;num[result[j]]&amp;&amp;j&lt;p_result-result)</span><br><span class="line">      &#123;</span><br><span class="line">        result[j]=<span class="number">-1</span>;</span><br><span class="line">        j++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>,n=<span class="number">0</span>;i&lt;p_result-result;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(result[i]&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      temp[n++]=num[result[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n);</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,temp[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,temp[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1046、划拳"><a href="#1046、划拳" class="headerlink" title="1046、划拳"></a>1046、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805277847568384" target="_blank" rel="noopener">划拳</a></h4><p>划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就赢了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。</p><p>下面给出甲、乙两人的划拳记录，请你统计他们最后分别喝了多少杯酒。</p><p><strong>输入描述</strong></p><p>输入第一行先给出一个正整数 N（≤100），随后 N 行，每行给出一轮划拳的记录，格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">甲喊 甲划 乙喊 乙划</span><br></pre></td></tr></table></figure><p>其中<code>喊</code>是喊出的数字，<code>划</code>是划出的数字，均为不超过 100 的正整数（两只手一起划）。</p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">5</span></span><br><span class="line">&gt; <span class="number">8</span> <span class="number">10</span> <span class="number">9</span> <span class="number">12</span></span><br><span class="line">&gt; <span class="number">5</span> <span class="number">10</span> <span class="number">5</span> <span class="number">10</span></span><br><span class="line">&gt; <span class="number">3</span> <span class="number">8</span> <span class="number">5</span> <span class="number">12</span></span><br><span class="line">&gt; <span class="number">12</span> <span class="number">18</span> <span class="number">1</span> <span class="number">13</span></span><br><span class="line">&gt; <span class="number">4</span> <span class="number">16</span> <span class="number">12</span> <span class="number">15</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中先后输出甲、乙两人喝酒的杯数，其间以一个空格分隔。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span> <span class="number">2</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> count1 = <span class="number">0</span>,count2 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line"><span class="keyword">int</span> a1,b1,a2,b2;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d %d %d %d"</span>,&amp;a1,&amp;b1,&amp;a2,&amp;b2);</span><br><span class="line"><span class="keyword">if</span> (b1 == a1+a2&amp;&amp;b2 == a1+a2)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b1 != a1+a2&amp;&amp;b2 != a1+a2)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b1 == a1+a2&amp;&amp;b2 != a1+a2)</span><br><span class="line">count1++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b1 != a1+a2&amp;&amp;b2 == a1+a2)</span><br><span class="line">count2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d %d"</span>,count2,count1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1047、编程团体赛"><a href="#1047、编程团体赛" class="headerlink" title="1047、编程团体赛"></a>1047、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805277163896832" target="_blank" rel="noopener">编程团体赛</a></h4><p>编程团体赛的规则为：每个参赛队由若干队员组成；所有队员独立比赛；参赛队的成绩为所有队员的成绩和；成绩最高的队获胜。</p><p>现给定所有队员的比赛成绩，请你编写程序找出冠军队。</p><p><strong>输入描述</strong></p><p>输入第一行给出一个正整数 N（≤104），即所有参赛队员总数。随后 N 行，每行给出一位队员的成绩，格式为：<code>队伍编号-队员编号 成绩</code>，其中<code>队伍编号</code>为 1 到 1000 的正整数，<code>队员编号</code>为 1 到 10 的正整数，<code>成绩</code>为 0 到 100 的整数。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">6</span></span><br><span class="line">&gt; <span class="number">3</span><span class="number">-10</span> <span class="number">99</span></span><br><span class="line">&gt; <span class="number">11</span><span class="number">-5</span> <span class="number">87</span></span><br><span class="line">&gt; <span class="number">102</span><span class="number">-1</span> <span class="number">0</span></span><br><span class="line">&gt; <span class="number">102</span><span class="number">-3</span> <span class="number">100</span></span><br><span class="line">&gt; <span class="number">11</span><span class="number">-9</span> <span class="number">89</span></span><br><span class="line">&gt; <span class="number">3</span><span class="number">-2</span> <span class="number">61</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中输出冠军队的编号和总成绩，其间以一个空格分隔。注意：题目保证冠军队是唯一的。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">11</span> <span class="number">176</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1001</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> t,grade;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d-%d %d"</span>,&amp;count,&amp;t,&amp;grade);</span><br><span class="line">a[count] += grade;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1001</span>; i++)</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; a[k]) k = i;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d %d"</span>,k,a[k]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1048、-数字加密"><a href="#1048、-数字加密" class="headerlink" title="1048、 数字加密"></a>1048、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805276438282240" target="_blank" rel="noopener"> 数字加密</a></h4><p>本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算：对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。 </p><p><strong>输入描述</strong></p><p>输入在一行中依次给出 A 和 B，均为不超过 100 位的正整数，其间以空格分隔。 </p><blockquote><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1234567</span> <span class="number">368782971</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中输出加密后的结果。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 3695Q8118</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>, m = <span class="number">0</span>,n = <span class="number">0</span>, flag = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> ch, arr1[<span class="number">101</span>], arr2[<span class="number">101</span>], arr3[<span class="number">101</span>];</span><br><span class="line">  <span class="keyword">while</span> ((ch = getchar()) != <span class="string">' '</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    arr1[i] = ch;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ((ch = getchar()) != <span class="string">'\n'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    arr2[j] = ch;</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  arr2[j] = <span class="string">'\0'</span>;</span><br><span class="line">  <span class="keyword">if</span> (j &lt; i)</span><br><span class="line">  &#123;</span><br><span class="line">    k = i - j;</span><br><span class="line">    <span class="keyword">for</span> (m = <span class="number">0</span>; m &lt; k; m++)</span><br><span class="line">      arr3[m] = <span class="string">'0'</span>;</span><br><span class="line">    arr3[m] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">strcat</span>(arr3, arr2);</span><br><span class="line">    <span class="built_in">strcpy</span>(arr2, arr3);</span><br><span class="line">    j = i;</span><br><span class="line">  &#125;</span><br><span class="line">  m = i; n = j;</span><br><span class="line">  <span class="keyword">for</span> (; flag &lt;=m; flag++, i--, j--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ((flag &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr2[j - <span class="number">1</span>] - arr1[i - <span class="number">1</span>] &gt;= <span class="number">0</span>)</span><br><span class="line">        arr2[j - <span class="number">1</span>] = arr2[j - <span class="number">1</span>] - arr1[i - <span class="number">1</span>]+<span class="number">48</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        arr2[j - <span class="number">1</span>] = arr2[j - <span class="number">1</span>] - arr1[i - <span class="number">1</span>] + <span class="number">10</span> + <span class="number">48</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ((arr1[i - <span class="number">1</span>] + arr2[j - <span class="number">1</span>]<span class="number">-96</span>) % <span class="number">13</span> &lt; <span class="number">10</span>)</span><br><span class="line">        arr2[j - <span class="number">1</span>] = (arr1[i - <span class="number">1</span>] + arr2[j - <span class="number">1</span>]<span class="number">-96</span>) % <span class="number">13</span>+<span class="number">48</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ((arr1[i - <span class="number">1</span>] + arr2[j - <span class="number">1</span>] - <span class="number">96</span>) % <span class="number">13</span> == <span class="number">10</span>)</span><br><span class="line">          arr2[j - <span class="number">1</span>] = <span class="string">'J'</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((arr1[i - <span class="number">1</span>] + arr2[j - <span class="number">1</span>] - <span class="number">96</span>) % <span class="number">13</span> == <span class="number">11</span>)</span><br><span class="line">          arr2[j - <span class="number">1</span>] = <span class="string">'Q'</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((arr1[i - <span class="number">1</span>] + arr2[j - <span class="number">1</span>] - <span class="number">96</span>) % <span class="number">13</span> == <span class="number">12</span>)</span><br><span class="line">          arr2[j - <span class="number">1</span>] = <span class="string">'K'</span>; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, arr2[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1049、数列的片段和"><a href="#1049、数列的片段和" class="headerlink" title="1049、数列的片段和"></a>1049、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805275792359424" target="_blank" rel="noopener">数列的片段和</a></h4><p>给定一个正数数列，我们可以从中截取任意的连续的几个数，称为片段。例如，给定数列 { 0.1, 0.2, 0.3, 0.4 }，我们有 (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4) 这 10 个片段。</p><p>给定正整数数列，求出全部片段包含的所有的数之和。如本例中 10 个片段总和是 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0。</p><p><strong>输入描述</strong></p><p>输入第一行给出一个不超过 10^5^ 的正整数 N，表示数列中数的个数，第二行给出 N 个不超过 1.0 的正数，是数列中的数，其间以空格分隔。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">4</span></span><br><span class="line">&gt; <span class="number">0.1</span> <span class="number">0.2</span> <span class="number">0.3</span> <span class="number">0.4</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中输出该序列所有片段包含的数之和，精确到小数点后 2 位。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 5.00</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> flag = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++ ) &#123;</span><br><span class="line"><span class="keyword">double</span> num ;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lf"</span>,&amp;num);</span><br><span class="line">sum += (<span class="keyword">double</span>) i*flag*num;</span><br><span class="line">flag--;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%.2lf"</span>,sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1050、螺旋矩阵"><a href="#1050、螺旋矩阵" class="headerlink" title="1050、螺旋矩阵"></a>1050、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805275146436608" target="_blank" rel="noopener">螺旋矩阵</a></h4><p>本题要求将给定的 N 个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1 个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 m 行 n 列，满足条件：m×n 等于 N；m≥n；且 m−n 取所有可能值中的最小值。 </p><p><strong>输入描述</strong></p><p>输入在第 1 行中给出一个正整数 N，第 2 行给出 N 个待填充的正整数。所有数字不超过 10^4^，相邻数字以空格分隔。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">12</span></span><br><span class="line">&gt; <span class="number">37</span> <span class="number">76</span> <span class="number">20</span> <span class="number">98</span> <span class="number">76</span> <span class="number">42</span> <span class="number">53</span> <span class="number">95</span> <span class="number">60</span> <span class="number">81</span> <span class="number">58</span> <span class="number">93</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>输出螺旋矩阵。每行 n 个数字，共 m 行。相邻数字以 1 个空格分隔，行末不得有多余空格。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">98</span> <span class="number">95</span> <span class="number">93</span></span><br><span class="line">&gt; <span class="number">42</span> <span class="number">37</span> <span class="number">81</span></span><br><span class="line">&gt; <span class="number">53</span> <span class="number">20</span> <span class="number">76</span></span><br><span class="line">&gt; <span class="number">58</span> <span class="number">60</span> <span class="number">76</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span> *)b - *(<span class="keyword">int</span> *)a;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> N, i,j,k,l, *arr=<span class="literal">NULL</span>,mem,meN;  </span><br><span class="line">    <span class="keyword">int</span> beg, over, men;  </span><br><span class="line">    <span class="keyword">int</span> m, n;  </span><br><span class="line">    <span class="keyword">int</span> **pmn=<span class="literal">NULL</span>;  </span><br><span class="line">    <span class="keyword">int</span> lu[<span class="number">2</span>], ld[<span class="number">2</span>], ru[<span class="number">2</span>], rd[<span class="number">2</span>];  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp; N);  </span><br><span class="line">    arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*N);  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    qsort(arr, N, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), cmp);  </span><br><span class="line">  </span><br><span class="line">    m=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(N);  </span><br><span class="line">    n = m;  </span><br><span class="line">    mem = m;  </span><br><span class="line">    <span class="comment">//以平方根为中间值向两边查找m*n大于N时令n-1  </span></span><br><span class="line">    <span class="keyword">while</span> ((m*n) != N) &#123;  </span><br><span class="line">        <span class="keyword">while</span>((m*n )&lt; N&amp;&amp;(m*n) != N) &#123;  </span><br><span class="line">            m++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (m*n == N)  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        n--;  </span><br><span class="line">        m = mem;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//创建二维数组  </span></span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">    pmn = (<span class="keyword">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span> *)*m+<span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;  </span><br><span class="line">        pmn[i] = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n+<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//开始螺旋赋值  </span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//初始化边界x[0]为行标，x[1]为横着数  </span></span><br><span class="line">    lu[<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">    lu[<span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">    ru[<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">    ru[<span class="number">1</span>] = n - <span class="number">1</span>;  </span><br><span class="line">    rd[<span class="number">0</span>] = m - <span class="number">1</span>;  </span><br><span class="line">    rd[<span class="number">1</span>] = n - <span class="number">1</span>;  </span><br><span class="line">    ld[<span class="number">0</span>] = m - <span class="number">1</span>;  </span><br><span class="line">    ld[<span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">    <span class="comment">//初始化矩阵行数mem,列数men  </span></span><br><span class="line">    mem = m;  </span><br><span class="line">    men = n;  </span><br><span class="line">    <span class="comment">//初始化数组指针  </span></span><br><span class="line">    meN = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (meN &lt; N) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (i = lu[<span class="number">0</span>], j = lu[<span class="number">1</span>]; meN &lt; N&amp;&amp;j &lt;ru[<span class="number">1</span>]; j++) &#123;  </span><br><span class="line">            pmn[i][j] = arr[meN++];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//men--;  </span></span><br><span class="line">        <span class="keyword">if</span> (lu[<span class="number">0</span>] &lt; ld[<span class="number">0</span>])lu[<span class="number">0</span>]++;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lu[<span class="number">0</span>] &gt; ld[<span class="number">0</span>])<span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">if</span>(lu[<span class="number">1</span>]&lt;ru[<span class="number">1</span>])lu[<span class="number">1</span>]++;  </span><br><span class="line">        <span class="comment">//lu[0]++;  </span></span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (i = ru[<span class="number">0</span>], j = ru[<span class="number">1</span>]; meN &lt; N&amp;&amp;i&lt;rd[<span class="number">0</span>]; i++) &#123;  </span><br><span class="line">            pmn[i][j] = arr[meN++];  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="keyword">if</span>( ru[<span class="number">0</span>]&lt;rd[<span class="number">0</span>])ru[<span class="number">0</span>]++;  </span><br><span class="line">    <span class="keyword">if</span>(ru[<span class="number">1</span>]&gt;lu[<span class="number">1</span>])ru[<span class="number">1</span>]--;  </span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (i = rd[<span class="number">0</span>], j = rd[<span class="number">1</span>]; meN &lt; N&amp;&amp;j &gt; ld[<span class="number">1</span>]; j--) &#123;  </span><br><span class="line">            pmn[i][j] = arr[meN++];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (ru[<span class="number">0</span>]&lt;rd[<span class="number">0</span>])rd[<span class="number">0</span>]--;  </span><br><span class="line">        <span class="keyword">if</span>(rd[<span class="number">1</span>]&gt;ld[<span class="number">1</span>])rd[<span class="number">1</span>]--;  </span><br><span class="line">        <span class="keyword">for</span> (i = ld[<span class="number">0</span>], j = ld[<span class="number">1</span>]; meN&lt;N&amp;&amp;i&gt;lu[<span class="number">0</span>]<span class="number">-1</span>; i--) &#123;  </span><br><span class="line">            pmn[i][j] = arr[meN++];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(ld[<span class="number">0</span>]&gt;lu[<span class="number">0</span>])ld[<span class="number">0</span>]--;  </span><br><span class="line">        <span class="keyword">if</span>(ld[<span class="number">1</span>]&lt;rd[<span class="number">1</span>])ld[<span class="number">1</span>]++;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (j != n - <span class="number">1</span>)  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, pmn[i][j]);  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>, pmn[i][j]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="built_in">free</span>(arr);  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;  </span><br><span class="line">        <span class="built_in">free</span>(pmn[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1051、复数乘法"><a href="#1051、复数乘法" class="headerlink" title="1051、复数乘法"></a>1051、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805274496319488" target="_blank" rel="noopener">复数乘法</a></h4><p>复数可以写成 (A+Bi) 的常规形式，其中 A 是实部，B 是虚部，i 是虚数单位，满足 i^2^=−1；也可以写成极坐标下的指数形式 (R×e^(Pi)^)，其中 R 是复数模，P 是辐角，i 是虚数单位，其等价于三角形式 R(cos(P)+isin(P))。</p><p>现给定两个复数的 R 和 P，要求输出两数乘积的常规形式。</p><p><strong>输入描述</strong></p><p>输入在一行中依次给出两个复数的 R1, P1, R2, P2，数字间以空格分隔。 </p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 2<span class="selector-class">.3</span> 3<span class="selector-class">.5</span> 5<span class="selector-class">.2</span> 0<span class="selector-class">.4</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中按照 <code>A+Bi</code> 的格式输出两数乘积的常规形式，实部和虚部均保留 2 位小数。注意：如果 <code>B</code> 是负数，则应该写成 <code>A-|B|i</code> 的形式。 </p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">-8</span><span class="selector-class">.68-8</span><span class="selector-class">.23i</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"math.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> r1,p1,r2,p2;</span><br><span class="line"><span class="keyword">double</span> A,B;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lf %lf %lf %lf"</span>,&amp;r1,&amp;p1,&amp;r2,&amp;p2);</span><br><span class="line">A = r1*r2*<span class="built_in">cos</span>(p1+p2);</span><br><span class="line">B = r1*r2*<span class="built_in">sin</span>(p1+p2);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(A) &lt; <span class="number">0.01</span>)</span><br><span class="line">A = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(B) &lt; <span class="number">0.01</span>)</span><br><span class="line">B = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (B &lt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%.2lf-%.2lfi"</span>,A,<span class="built_in">fabs</span>(B));</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%.2lf+%.2lfi"</span>,A,B);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1052、卖个萌"><a href="#1052、卖个萌" class="headerlink" title="1052、卖个萌"></a>1052、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805273883951104" target="_blank" rel="noopener">卖个萌</a></h4><p>萌萌哒表情符号通常由“手”、“眼”、“口”三个主要部分组成。简单起见，我们假设一个表情符号是按下列格式输出的：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">左手</span>](<span class="link">[左眼][口][右眼]</span>)[<span class="string">右手</span>]</span><br></pre></td></tr></table></figure><p>现给出可选用的符号集合，请你按用户的要求输出表情。</p><p><strong>输入描述</strong></p><p>输入首先在前三行顺序对应给出手、眼、口的可选符号集。每个符号括在一对方括号 <code>[]</code>内。题目保证每个集合都至少有一个符号，并不超过 10 个符号；每个符号包含 1 到 4 个非空字符。</p><p>之后一行给出一个正整数 K，为用户请求的个数。随后 K 行，每行给出一个用户的符号选择，顺序为左手、左眼、口、右眼、右手——这里只给出符号在相应集合中的序号（从 1 开始），数字间以空格分隔。</p><blockquote><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; [╮][╭][o][~\][/~]  [&lt;][&gt;]</span><br><span class="line">&gt;  [╯][╰][^][-][=][&gt;][&lt;][@][⊙]</span><br><span class="line">&gt; [Д][▽][<span class="symbol">_</span>][ε][^]  ...</span><br><span class="line">&gt; <span class="number">4</span></span><br><span class="line">&gt; <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line">&gt; <span class="number">6</span> <span class="number">8</span> <span class="number">1</span> <span class="number">5</span> <span class="number">5</span></span><br><span class="line">&gt; <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">&gt; <span class="number">2</span> <span class="number">10</span> <span class="number">3</span> <span class="number">9</span> <span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>对每个用户请求，在一行中输出生成的表情。若用户选择的序号不存在，则输出 <code>Are you kidding me? @\/@</code>。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ╮(╯▽╰)╭</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &lt;(@Д=)/~</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> o(^ε^)o</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Are you kidding me? @\/@</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">pump</span><span class="params">(<span class="keyword">char</span> a[])</span> <span class="comment">// 表情提取函数，识别开始的'[' ，记录表情，到']'结束，遇到换行符表示录入结束，返回NULL</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> c = <span class="number">0</span>, i;</span><br><span class="line">  <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">while</span> ((c = getchar()) != <span class="string">'['</span>)</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'\n'</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; (c = getchar()) != <span class="string">']'</span>; i++)</span><br><span class="line">    a[i] = c;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">store</span><span class="params">(<span class="keyword">char</span> db[][<span class="number">5</span>], <span class="keyword">char</span> a[])</span> <span class="comment">// 存储读取到的表情，并返回读到的表情个数因为个数从0开始记，返回i-1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; pump(a) != <span class="literal">NULL</span>; i++)</span><br><span class="line">    <span class="built_in">strcpy</span>(db[i], a);</span><br><span class="line">  <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> db[][<span class="number">11</span>][<span class="number">5</span>], <span class="keyword">int</span> size[])</span> <span class="comment">// 读取请求并输出表情</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">5</span>], tag = <span class="number">1</span>, i;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">  &#123; <span class="comment">// 读取一组表情请求的序号</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">    a[i] -= <span class="number">1</span>; <span class="comment">// 同样的，转换为0开始的序号</span></span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; size[i] || a[i] &lt; <span class="number">0</span>) tag = <span class="number">0</span>; <span class="comment">// 遇到不存在的序号，标记tag为0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (tag) <span class="comment">// 根据请求的序号是否全存在，选择输出模式</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s(%s%s%s)%s\n"</span>, db[<span class="number">0</span>][a[<span class="number">0</span>]], db[<span class="number">1</span>][a[<span class="number">1</span>]], db[<span class="number">2</span>][a[<span class="number">2</span>]], db[<span class="number">1</span>][a[<span class="number">3</span>]], db[<span class="number">0</span>][a[<span class="number">4</span>]]);</span><br><span class="line">  <span class="comment">// db为表情存储数组，根据序号选择对应表情</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Are you kidding me? @\\/@\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> a[<span class="number">5</span>], db[<span class="number">3</span>][<span class="number">11</span>][<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="keyword">int</span> n, size[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;, i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    size[i] = store(db[i], a); <span class="comment">// 根据store函数返回的值，记录改组表情的个数，从而判断请求是否合理</span></span><br><span class="line">  size[<span class="number">4</span>] = size[<span class="number">0</span>], size[<span class="number">3</span>] = size[<span class="number">1</span>]; <span class="comment">// 因为两只眼睛，两只手，所以3和4的可选范围与左边对称</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 输出n次请求的表情</span></span><br><span class="line">    print(db, size);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1053、住房空置率"><a href="#1053、住房空置率" class="headerlink" title="1053、住房空置率"></a>1053、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805273284165632" target="_blank" rel="noopener">住房空置率</a></h4><p>在不打扰居民的前提下，统计住房空置率的一种方法是根据每户用电量的连续变化规律进行判断。判断方法如下：</p><ul><li>在观察期内，若存在超过一半的日子用电量低于某给定的阈值 e，则该住房为“可能空置”；</li><li>若观察期超过某给定阈值 D 天，且满足上一个条件，则该住房为“空置”。</li></ul><p>现给定某居民区的住户用电量数据，请你统计“可能空置”的比率和“空置”比率，即以上两种状态的住房占居民区住房总套数的百分比。</p><p><strong>输入描述</strong></p><p>输入第一行给出正整数 N（≤1000），为居民区住房总套数；正实数 e，即低电量阈值；正整数 D，即观察期阈值。随后 N 行，每行按以下格式给出一套住房的用电量数据：</p><p>K E1 E2 … EK</p><p>其中 K 为观察的天数，Ei 为第 i 天的用电量。</p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">5</span> <span class="number">0.5</span> <span class="number">10</span></span><br><span class="line">&gt; <span class="number">6</span> <span class="number">0.3</span> <span class="number">0.4</span> <span class="number">0.5</span> <span class="number">0.2</span> <span class="number">0.8</span> <span class="number">0.6</span></span><br><span class="line">&gt; <span class="number">10</span> <span class="number">0.0</span> <span class="number">0.1</span> <span class="number">0.2</span> <span class="number">0.3</span> <span class="number">0.0</span> <span class="number">0.8</span> <span class="number">0.6</span> <span class="number">0.7</span> <span class="number">0.0</span> <span class="number">0.5</span></span><br><span class="line">&gt; <span class="number">5</span> <span class="number">0.4</span> <span class="number">0.3</span> <span class="number">0.5</span> <span class="number">0.1</span> <span class="number">0.7</span></span><br><span class="line">&gt; <span class="number">11</span> <span class="number">0.1</span> <span class="number">0.1</span> <span class="number">0.1</span> <span class="number">0.1</span> <span class="number">0.1</span> <span class="number">0.1</span> <span class="number">0.1</span> <span class="number">0.1</span> <span class="number">0.1</span> <span class="number">0.1</span> <span class="number">0.1</span></span><br><span class="line">&gt; <span class="number">11</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0.1</span> <span class="number">1</span> <span class="number">0.1</span> <span class="number">0.1</span> <span class="number">0.1</span> <span class="number">0.1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中输出“可能空置”的比率和“空置”比率的百分比值，其间以一个空格分隔，保留小数点后 1 位。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">40.0</span>% <span class="number">20.0</span>%</span><br><span class="line">&gt; （样例解释：第<span class="number">2</span>、<span class="number">3</span>户为“可能空置”，第<span class="number">4</span>户为“空置”，其他户不是空置。）</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> D;</span><br><span class="line"><span class="keyword">double</span> e;</span><br><span class="line"><span class="keyword">int</span> count1 = <span class="number">0</span>,count2 = <span class="number">0</span>,count3 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d%lf%d"</span>,&amp;N,&amp;e,&amp;D);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line"><span class="keyword">double</span> temp;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lf"</span>,&amp;temp);</span><br><span class="line"><span class="keyword">if</span> (temp &lt; e)</span><br><span class="line">count1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count1&gt;(k / <span class="number">2.0</span>)&amp;&amp;k &gt; D)</span><br><span class="line">count2++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (count1 &gt; (k / <span class="number">2.0</span>) &amp;&amp; k &lt;= D)</span><br><span class="line">count3++;</span><br><span class="line">count1 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%.01lf%% %.01lf%%"</span>,(<span class="keyword">double</span>)count3*<span class="number">100</span>/N,(<span class="keyword">double</span>)count2*<span class="number">100</span>/N);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1054、求平均值"><a href="#1054、求平均值" class="headerlink" title="1054、求平均值"></a>1054、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805272659214336" target="_blank" rel="noopener">求平均值</a></h4><p>本题的基本要求非常简单：给定 N 个实数，计算它们的平均值。但复杂的是有些输入数据可能是非法的。一个“合法”的输入是 [−1000,1000] 区间内的实数，并且最多精确到小数点后 2 位。当你计算平均值的时候，不能把那些非法的数据算在内。 </p><p><strong>输入描述</strong></p><p>输入第一行给出正整数 N（≤100）。随后一行给出 N 个实数，数字间以一个空格分隔。 </p><blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 7</span><br><span class="line">&gt; 5 -3.2<span class="built_in"> aaa </span>9999 2.3.4 7.123 2.35</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>对每个非法输入，在一行中输出 <code>ERROR: X is not a legal number</code>，其中 <code>X</code> 是输入。最后在一行中输出结果：<code>The average of K numbers is Y</code>，其中 <code>K</code> 是合法输入的个数，<code>Y</code> 是它们的平均值，精确到小数点后 2 位。如果平均值无法计算，则用 <code>Undefined</code> 替换 <code>Y</code>。如果 <code>K</code> 为 1，则输出 <code>The average of 1 number is Y</code>。 </p><blockquote><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; ERROR: aaa <span class="keyword">is</span> <span class="keyword">not</span> a legal <span class="built_in">number</span></span><br><span class="line">&gt; ERROR: <span class="number">9999</span> <span class="keyword">is</span> <span class="keyword">not</span> a legal <span class="built_in">number</span></span><br><span class="line">&gt; ERROR: <span class="number">2.3</span><span class="number">.4</span> <span class="keyword">is</span> <span class="keyword">not</span> a legal <span class="built_in">number</span></span><br><span class="line">&gt; ERROR: <span class="number">7.123</span> <span class="keyword">is</span> <span class="keyword">not</span> a legal <span class="built_in">number</span></span><br><span class="line">&gt; The average <span class="keyword">of</span> <span class="number">3</span> numbers <span class="keyword">is</span> <span class="number">1.38</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, i, flag = <span class="number">0</span>, flag1 = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">double</span>  Num, Count = <span class="number">0</span>, Average = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> str2[<span class="number">100</span>], str1[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str1);</span><br><span class="line">    <span class="built_in">sscanf</span>(str1, <span class="string">"%lf"</span>, &amp;Num);              <span class="comment">//比较2个转换的字符串是不是相同的 相同的则说明是最多有2位小数的整数</span></span><br><span class="line">    <span class="built_in">sprintf</span>(str2,<span class="string">"%.2lf"</span>, Num);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(str1);j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (str1[j] != str2[j]) flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag || Num &lt; <span class="number">-1000</span> || Num&gt;<span class="number">1000</span>)   <span class="comment">// 如果不是最多有2位小数的整数或者是大于1000或小于-1000的整数 则输出</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"ERROR: %s is not a legal number\n"</span>,str1);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      Count += Num; flag1++;</span><br><span class="line">    &#125;</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Average = Count / flag1;</span><br><span class="line">  <span class="keyword">if</span> (flag1 == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The average of 1 number is %.02lf\n"</span>, Count);   <span class="comment">//只有一个数的时候是number 没"S"</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (flag1 == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The average of 0 numbers is Undefined\n"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The average of %d numbers is %.02lf\n"</span>, flag1, Average);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1055、-集体照"><a href="#1055、-集体照" class="headerlink" title="1055、 集体照"></a>1055、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805272021680128" target="_blank" rel="noopener"> 集体照</a></h4><p>拍集体照时队形很重要，这里对给定的 N 个人 K 排的队形设计排队规则如下：</p><ul><li>每排人数为 N/K（向下取整），多出来的人全部站在最后一排；</li><li>后排所有人的个子都不比前排任何人矮；</li><li>每排中最高者站中间（中间位置为 m/2+1，其中 m 为该排人数，除法向下取整）；</li><li>每排其他人以中间人为轴，按身高非增序，先右后左交替入队站在中间人的两侧（例如5人身高为190、188、186、175、170，则队形为175、188、190、186、170。这里假设你面对拍照者，所以你的左边是中间人的右边）；</li><li>若多人身高相同，则按名字的字典序升序排列。这里保证无重名。</li></ul><p>现给定一组拍照人，请编写程序输出他们的队形。</p><p><strong>输入描述</strong></p><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出两个正整数 N（≤10^4^，总人数）和 K（≤10，总排数）。随后 N 行，每行给出一个人的名字（不包含空格、长度不超过 8 个英文字母）和身高（[30, 300] 区间内的整数）。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">10</span> <span class="number">3</span></span><br><span class="line">&gt; Tom <span class="number">188</span></span><br><span class="line">&gt; Mike <span class="number">170</span></span><br><span class="line">&gt; Eva <span class="number">168</span></span><br><span class="line">&gt; Tim <span class="number">160</span></span><br><span class="line">&gt; Joe <span class="number">190</span></span><br><span class="line">&gt; Ann <span class="number">168</span></span><br><span class="line">&gt; Bob <span class="number">175</span></span><br><span class="line">&gt; Nick <span class="number">186</span></span><br><span class="line">&gt; Amy <span class="number">160</span></span><br><span class="line">&gt; John <span class="number">159</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>输出拍照的队形。即K排人名，其间以空格分隔，行末不得有多余空格。注意：假设你面对拍照者，后排的人输出在上方，前排输出在下方。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Bob Tom Joe Nick</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Ann Mike Eva</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Tim Amy John</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">In</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">9</span>];</span><br><span class="line">  <span class="keyword">int</span> tall;</span><br><span class="line">&#125;s[<span class="number">10002</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">In</span> *<span class="title">c</span> = ( <span class="title">In</span> *)<span class="title">a</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">In</span> *<span class="title">d</span> = (<span class="title">In</span> *)<span class="title">b</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (c-&gt;tall != d-&gt;tall) <span class="keyword">return</span> d-&gt;tall- c-&gt;tall ;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">strcmp</span>(c-&gt;name,d-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//freopen("input.txt", "r", stdin);</span></span><br><span class="line">  <span class="comment">//freopen("output.txt", "w", stdout);</span></span><br><span class="line">  <span class="keyword">int</span> N = <span class="number">0</span>, K = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i, j, temp = <span class="number">0</span>, col = <span class="number">0</span>, col2 = <span class="number">0</span>, flag1 = <span class="number">0</span>, flag2 = <span class="number">0</span>, flag3 = <span class="number">0</span>, flag4 = <span class="number">0</span>, flag5 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;N, &amp;K);</span><br><span class="line">  col = N / K;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, &amp;s[i].name, &amp;s[i].tall);</span><br><span class="line">  &#125;</span><br><span class="line">  qsort(s, <span class="number">10002</span>, <span class="keyword">sizeof</span>(s[<span class="number">0</span>]), cmp);</span><br><span class="line">  <span class="comment">//for (i = 0; i &lt; N; i++)</span></span><br><span class="line">    <span class="comment">//printf("%s\n", s[i].name);</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= K; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    flag3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (col % <span class="number">2</span> == <span class="number">0</span>||col == <span class="number">1</span>)</span><br><span class="line">      flag2 = col;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      flag2 = col - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= col; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (col*K &lt; N &amp;&amp; !flag1)</span><br><span class="line">      &#123;</span><br><span class="line">        flag2 = flag4 = N - col*(K - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (flag4--)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (!flag3)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">printf</span>(s[<span class="built_in">abs</span>(flag2) - <span class="number">1</span>].name); flag3 = <span class="number">1</span>; <span class="keyword">if</span> (flag2 == <span class="number">2</span>) flag2--; flag2 -= <span class="number">2</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %s"</span>, s[<span class="built_in">abs</span>(flag2) - <span class="number">1</span>].name); <span class="keyword">if</span> (flag2 == <span class="number">2</span>) flag2--; flag2 -= <span class="number">2</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag1 = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag3)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(s[<span class="built_in">abs</span>(flag2)<span class="number">-1</span> + flag4].name); flag3 = <span class="number">1</span>; <span class="keyword">if</span> (flag2 == <span class="number">2</span>) flag2--; flag2 -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">" %s"</span>, s[<span class="built_in">abs</span>(flag2) - <span class="number">1</span>+flag4].name); <span class="keyword">if</span> (flag2 == <span class="number">2</span>) flag2--; flag2 -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>); </span><br><span class="line">    <span class="keyword">if</span> (!flag5)</span><br><span class="line">    &#123;</span><br><span class="line">      flag4 = N - col*(K - <span class="number">1</span>); flag5 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      flag4 += col;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1056、组合数的和"><a href="#1056、组合数的和" class="headerlink" title="1056、组合数的和"></a>1056、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805271455449088" target="_blank" rel="noopener">组合数的和</a></h4><p>给定 N 个非 0 的个位数字，用其中任意 2 个数字都可以组合成 1 个 2 位的数字。要求所有可能组合出来的 2 位数字的和。例如给定 2、5、8，则可以组合出：25、28、52、58、82、85，它们的和为330。 </p><p><strong>输入描述</strong></p><p>输入在一行中先给出 N（1 &lt; N &lt; 10），随后给出 N 个不同的非 0 个位数字。数字间以空格分隔。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">3</span> <span class="number">2</span> <span class="number">8</span> <span class="number">5</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>输出所有可能组合出来的2位数字的和。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 330</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">count += num*(N<span class="number">-1</span>)*<span class="number">10</span>+num*(N<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>,count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1057、数零壹"><a href="#1057、数零壹" class="headerlink" title="1057、数零壹"></a>1057、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805270914383872" target="_blank" rel="noopener">数零壹</a></h4><p>给定一串长度不超过 105 的字符串，本题要求你将其中所有英文字母的序号（字母 a-z 对应序号 1-26，不分大小写）相加，得到整数 N，然后再分析一下 N 的二进制表示中有多少 0、多少 1。例如给定字符串 <code>PAT (Basic)</code>，其字母序号之和为：16+1+20+2+1+19+9+3=71，而 71 的二进制是 1000111，即有 3 个 0、4 个 1。 </p><p><strong>输入描述</strong></p><p>输入在一行中给出长度不超过 10^5^、以回车结束的字符串。 </p><blockquote><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; PAT (<span class="name">Basic</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中先后输出 0 的个数和 1 的个数，其间以空格分隔。注意：若字符串中不存在字母，则视为 N 不存在，也就没有 0 和 1。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">3</span> <span class="number">4</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) != <span class="string">'\n'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch &gt;= <span class="string">'A'</span>&amp;&amp;ch &lt;= <span class="string">'Z'</span>)</span><br><span class="line">count += ch-<span class="string">'A'</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= <span class="string">'a'</span>&amp;&amp; ch &lt;= <span class="string">'z'</span>)</span><br><span class="line">count += ch-<span class="string">'a'</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">0</span>,num2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (count) &#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">temp = count%<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="number">0</span>)</span><br><span class="line">num1++;</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="number">1</span>)</span><br><span class="line">num2++;</span><br><span class="line">count = count/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d %d"</span>,num1,num2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1058、选择题"><a href="#1058、选择题" class="headerlink" title="1058、选择题"></a>1058、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805270356541440" target="_blank" rel="noopener">选择题</a></h4><p>批改多选题是比较麻烦的事情，本题就请你写个程序帮助老师批改多选题，并且指出哪道题错的人最多。 </p><p><strong>输入描述</strong></p><p>输入在第一行给出两个正整数 N（≤ 1000）和 M（≤ 100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 <code>(选中的选项个数 选项1 ……)</code>，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。 </p><blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">3</span> <span class="number">4</span> </span><br><span class="line">&gt; <span class="number">3</span> <span class="number">4</span> <span class="number">2</span> <span class="selector-tag">a</span> c</span><br><span class="line">&gt; <span class="number">2</span> <span class="number">5</span> <span class="number">1</span> b</span><br><span class="line">&gt; <span class="number">5</span> <span class="number">3</span> <span class="number">2</span> <span class="selector-tag">b</span> c</span><br><span class="line">&gt; <span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> d e</span><br><span class="line">&gt; (<span class="number">2</span> <span class="selector-tag">a</span> c) (<span class="number">2</span> <span class="selector-tag">b</span> d) (<span class="number">2</span> <span class="selector-tag">a</span> c) (<span class="number">3</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> e)</span><br><span class="line">&gt; (<span class="number">2</span> <span class="selector-tag">a</span> c) (<span class="number">1</span> b) (<span class="number">2</span> <span class="selector-tag">a</span> b) (<span class="number">4</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> d e)</span><br><span class="line">&gt; (<span class="number">2</span> <span class="selector-tag">b</span> d) (<span class="number">1</span> e) (<span class="number">2</span> <span class="selector-tag">b</span> c) (<span class="number">4</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> c d)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>按照输入的顺序给出每个学生的得分，每个分数占一行。注意判题时只有选择全部正确才能得到该题的分数。最后一行输出错得最多的题目的错误次数和编号（题目按照输入的顺序从 1 开始编号）。如果有并列，则按编号递增顺序输出。数字间用空格分隔，行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 <code>Too simple</code>。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">3</span></span><br><span class="line">&gt; <span class="number">6</span></span><br><span class="line">&gt; <span class="number">5</span></span><br><span class="line">&gt; <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//freopen("input.txt", "r", stdin);</span></span><br><span class="line">  <span class="comment">//freopen("output.txt", "w", stdout);</span></span><br><span class="line">  <span class="keyword">int</span> N, M, i, j, flag1 = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> ch;</span><br><span class="line">  <span class="keyword">char</span> str[<span class="number">10</span>] = &#123; <span class="string">"\0"</span> &#125;, str1[<span class="number">10</span>] = &#123; <span class="string">"\0"</span> &#125;;</span><br><span class="line">  <span class="keyword">char</span> option[<span class="number">200</span>][<span class="number">20</span>];                        </span><br><span class="line">  <span class="keyword">int</span> subject[<span class="number">200</span>][<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="keyword">int</span> sutdent[<span class="number">2000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;N, &amp;M);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d "</span>, &amp;subject[i][<span class="number">0</span>]);</span><br><span class="line">    getchar(); getchar(); getchar(); getchar();</span><br><span class="line">    fgets(option[i], <span class="number">10</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span>(option[i][<span class="built_in">strlen</span>(option[i])<span class="number">-1</span>]==<span class="string">'\n'</span>)</span><br><span class="line">      option[i][<span class="built_in">strlen</span>(option[i]) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= M; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      getchar(); getchar(); getchar();</span><br><span class="line">      <span class="keyword">while</span> ((ch=getchar()) != <span class="string">')'</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">strncpy</span>(str1,&amp;ch,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(str, str1);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(option[j], str))</span><br><span class="line">        sutdent[i] += subject[j][<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        subject[j][<span class="number">1</span>]++; flag1 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      getchar();</span><br><span class="line">      <span class="built_in">memset</span>(str, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sutdent[i]);</span><br><span class="line">  <span class="keyword">if</span> (flag1 == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Too simple"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (subject[i][<span class="number">1</span>] &gt;= max)</span><br><span class="line">      max = subject[i][<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, max);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (subject[i][<span class="number">1</span>] == max)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">" %d"</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1059、C语言竞赛"><a href="#1059、C语言竞赛" class="headerlink" title="1059、C语言竞赛"></a>1059、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805269828059136" target="_blank" rel="noopener">C语言竞赛</a></h4><p>C 语言竞赛是浙江大学计算机学院主持的一个欢乐的竞赛。既然竞赛主旨是为了好玩，颁奖规则也就制定得很滑稽：</p><ul><li>0、冠军将赢得一份“神秘大奖”（比如很巨大的一本学生研究论文集……）。</li><li>1、排名为素数的学生将赢得最好的奖品 —— 小黄人玩偶！</li><li>2、其他人将得到巧克力。</li></ul><p>给定比赛的最终排名以及一系列参赛者的 ID，你要给出这些参赛者应该获得的奖品。</p><p><strong>输入描述</strong></p><p>输入第一行给出一个正整数 N（≤104），是参赛者人数。随后 N 行给出最终排名，每行按排名顺序给出一位参赛者的 ID（4 位数字组成）。接下来给出一个正整数 K 以及 K 个需要查询的 ID。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 6</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 1111</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 6666</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 8888</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 1234</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 5555</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 0001</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 6</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 8888</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 0001</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 1111</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2222</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 8888</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2222</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>对每个要查询的 ID，在一行中输出 <code>ID: 奖品</code>，其中奖品或者是 <code>Mystery Award</code>（神秘大奖）、或者是 <code>Minion</code>（小黄人）、或者是 <code>Chocolate</code>（巧克力）。如果所查 ID 根本不在排名里，打印 <code>Are you kidding?</code>（耍我呢？）。如果该 ID 已经查过了（即奖品已经领过了），打印 <code>ID: Checked</code>（不能多吃多占）。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 8888: Minion</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 0001: Chocolate</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 1111: Mystery Award</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2222: Are you kidding?</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 8888: Checked</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2222: Are you kidding?</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"math.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10001</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">arr[num] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;num);</span><br><span class="line"><span class="keyword">if</span> (arr[num] == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%04d: Checked\n"</span>,num);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[num] == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%04d: Mystery Award\n"</span>,num);</span><br><span class="line">arr[num] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= <span class="built_in">sqrt</span>(arr[num]); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[num]%j == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%04d: Chocolate\n"</span>,num);</span><br><span class="line">arr[num] = <span class="number">-1</span>;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag&amp;&amp;arr[num] != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%04d: Minion\n"</span>,num);</span><br><span class="line">arr[num] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%04d: Are you kidding?\n"</span>,num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1060、爱丁顿数"><a href="#1060、爱丁顿数" class="headerlink" title="1060、爱丁顿数"></a>1060、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805269312159744" target="_blank" rel="noopener">爱丁顿数</a></h4><p>英国天文学家爱丁顿很喜欢骑车。据说他为了炫耀自己的骑车功力，还定义了一个“爱丁顿数” E ，即满足有 E 天骑车超过 E 英里的最大整数 E。据说爱丁顿自己的 E 等于87。</p><p>现给定某人 N 天的骑车距离，请你算出对应的爱丁顿数 E（≤N）。</p><p><strong>输入描述</strong></p><p>输入第一行给出一个正整数 N (≤10^5^)，即连续骑车的天数；第二行给出 N 个非负整数，代表每天的骑车距离。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">10</span></span><br><span class="line">&gt; <span class="number">6</span> <span class="number">7</span> <span class="number">6</span> <span class="number">9</span> <span class="number">3</span> <span class="number">10</span> <span class="number">8</span> <span class="number">2</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中给出 N 天的爱丁顿数。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 6</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*a, <span class="keyword">const</span> <span class="keyword">void</span>*b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="keyword">int</span> *)b - *(<span class="keyword">int</span> *)a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//freopen("input.txt", "r", stdin);</span></span><br><span class="line">  <span class="comment">//freopen("output.txt", "w", stdout);</span></span><br><span class="line">  <span class="keyword">int</span> n, i;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">  qsort(&amp;a[<span class="number">1</span>], n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), comp);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt;= i)<span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, i - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1061、判断题"><a href="#1061、判断题" class="headerlink" title="1061、判断题"></a>1061、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805268817231872" target="_blank" rel="noopener">判断题</a></h4><p>判断题的评判很简单，本题就要求你写个简单的程序帮助老师判题并统计学生们判断题的得分。 </p><p><strong>输入描述</strong></p><p>输入在第一行给出两个不超过 100 的正整数 N 和 M，分别是学生人数和判断题数量。第二行给出 M 个不超过 5 的正整数，是每道题的满分值。第三行给出每道题对应的正确答案，0 代表“非”，1 代表“是”。随后 N 行，每行给出一个学生的解答。数字间均以空格分隔。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">3</span> <span class="number">6</span></span><br><span class="line">&gt; <span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">&gt; <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">&gt; <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">&gt; <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">&gt; <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>按照输入的顺序输出每个学生的得分，每个分数占一行。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 13</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 11</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 12</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">100</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d %d"</span>,&amp;N,&amp;M);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) </span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;arr[i][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;arr[i][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;num);</span><br><span class="line"><span class="keyword">if</span> (num == arr[j][<span class="number">1</span>])</span><br><span class="line">count += arr[j][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>,count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1062、最简分数"><a href="#1062、最简分数" class="headerlink" title="1062、最简分数"></a>1062、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805268334886912" target="_blank" rel="noopener">最简分数</a></h4><p>一个分数一般写成两个整数相除的形式：N/M，其中 M 不为0。最简分数是指分子和分母没有公约数的分数表示形式。</p><p>现给定两个不相等的正分数 N1/M1 和 N2/M2，要求你按从小到大的顺序列出它们之间分母为 K 的最简分数。</p><p><strong>输入描述</strong></p><p>输入在一行中按 N/M 的格式给出两个正分数，随后是一个正整数分母 K，其间以空格分隔。题目保证给出的所有整数都不超过 1000。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">7</span>/<span class="number">18</span> <span class="number">13</span>/<span class="number">20</span> <span class="number">12</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中按 N/M 的格式列出两个给定分数之间分母为 K 的所有最简分数，按从小到大的顺序，其间以 1 个空格分隔。行首尾不得有多余空格。题目保证至少有 1 个输出。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">5</span>/<span class="number">12</span> <span class="number">7</span>/<span class="number">12</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kgcd</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>*, <span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//freopen("input.txt", "r", stdin);</span></span><br><span class="line">  <span class="comment">//freopen("output.txt", "w", stdout);</span></span><br><span class="line">  <span class="keyword">int</span> N1, N2, M1, M2, K;</span><br><span class="line">  <span class="keyword">int</span> Num = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d/%d %d/%d %d"</span>, &amp;N1, &amp;M1, &amp;N2, &amp;M2, &amp;K);</span><br><span class="line">  <span class="keyword">if</span> (N2*M1 &lt; N1*M2) &#123;</span><br><span class="line">    swap(&amp;N1, &amp;N2);</span><br><span class="line">    swap(&amp;M1, &amp;M2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (N1*K &gt;= Num*M1) Num++;</span><br><span class="line">  <span class="keyword">while</span> (N1*K &lt; Num*M1&amp;&amp;Num*M2 &lt; K*N2) &#123;</span><br><span class="line">      <span class="keyword">if</span> (kgcd(Num, K) == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d/%d"</span>, Num, K); flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">" %d/%d"</span>, Num, K);</span><br><span class="line">        &#125;</span><br><span class="line">    Num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a == b)</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">    <span class="keyword">return</span> kgcd(b, a);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(a &amp; <span class="number">1</span>) &amp;&amp; !(b &amp; <span class="number">1</span>))</span><br><span class="line">      <span class="keyword">return</span> kgcd(a &gt;&gt; <span class="number">1</span>, b &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!(a &amp; <span class="number">1</span>) &amp;&amp; b &amp; <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> kgcd(a &gt;&gt; <span class="number">1</span>, b);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &amp; <span class="number">1</span> &amp;&amp; !(b &amp; <span class="number">1</span>))</span><br><span class="line">      <span class="keyword">return</span> kgcd(a, b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> kgcd(b, a - b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">  temp = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1063、计算谱半径"><a href="#1063、计算谱半径" class="headerlink" title="1063、计算谱半径"></a>1063、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805267860930560" target="_blank" rel="noopener">计算谱半径</a></h4><p>在数学中，矩阵的“谱半径”是指其特征值的模集合的上确界。换言之，对于给定的 n 个复数空间的特征值 { a1+b1i,⋯,an+bni }，它们的模为实部与虚部的平方和的开方，而“谱半径”就是最大模。</p><p>现在给定一些复数空间的特征值，请你计算并输出这些特征值的谱半径。</p><p><strong>输入描述</strong></p><p>输入第一行给出正整数 N（≤ 10 000）是输入的特征值的个数。随后 N 行，每行给出 1 个特征值的实部和虚部，其间以空格分隔。注意：题目保证实部和虚部均为绝对值不超过 1000 的整数。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">5</span></span><br><span class="line">&gt; <span class="number">0</span> <span class="number">1</span></span><br><span class="line">&gt; <span class="number">2</span> <span class="number">0</span></span><br><span class="line">&gt; <span class="number">-1</span> <span class="number">0</span></span><br><span class="line">&gt; <span class="number">3</span> <span class="number">3</span></span><br><span class="line">&gt; <span class="number">0</span> <span class="number">-3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中输出谱半径，四舍五入保留小数点后 2 位。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 4.24</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"math.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> num1,num2;</span><br><span class="line"><span class="keyword">double</span> temp;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d %d"</span>,&amp;num1,&amp;num2);</span><br><span class="line">temp = (<span class="keyword">double</span>)<span class="built_in">sqrt</span>(num1*num1+num2*num2);</span><br><span class="line"><span class="keyword">if</span> (temp &gt; max)</span><br><span class="line">max = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%.2lf"</span>,max);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1064、朋友数"><a href="#1064、朋友数" class="headerlink" title="1064、朋友数"></a>1064、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805267416334336" target="_blank" rel="noopener">朋友数</a></h4><p>如果两个整数各位数字的和是一样的，则被称为是“朋友数”，而那个公共的和就是它们的“朋友证号”。例如 123 和 51 就是朋友数，因为 1+2+3 = 5+1 = 6，而 6 就是它们的朋友证号。给定一些整数，要求你统计一下它们中有多少个不同的朋友证号。 </p><p><strong>输入描述</strong></p><p>输入第一行给出正整数 N。随后一行给出 N 个正整数，数字间以空格分隔。题目保证所有数字小于 10^4^。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">8</span></span><br><span class="line">&gt; <span class="number">123</span> <span class="number">899</span> <span class="number">51</span> <span class="number">998</span> <span class="number">27</span> <span class="number">33</span> <span class="number">36</span> <span class="number">12</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>首先第一行输出给定数字中不同的朋友证号的个数；随后一行按递增顺序输出这些朋友证号，数字间隔一个空格，且行末不得有多余空格。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">4</span></span><br><span class="line">&gt; <span class="number">3</span> <span class="number">6</span> <span class="number">9</span> <span class="number">26</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">result = result + num%<span class="number">10</span>;</span><br><span class="line">num = num / <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">//不同朋友证号的个数</span></span><br><span class="line"><span class="keyword">int</span> result[<span class="number">100000</span>];  <span class="comment">//不同朋友证号 </span></span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;num[i]);</span><br><span class="line"><span class="keyword">int</span> shusum = sum (num[i]);</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (result[j] == shusum) &#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">result[count] = shusum;</span><br><span class="line">count = count + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将朋友证号按递增方式排列 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count<span class="number">-1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count<span class="number">-1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (result[j] &gt; result[j+<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">temp = result[j];</span><br><span class="line">result[j] = result[j+<span class="number">1</span>];</span><br><span class="line">result[j+<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>,count);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ( i == <span class="number">0</span>) </span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>,result[i]);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">printf</span> (<span class="string">" %d"</span>,result[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1065、单身狗"><a href="#1065、单身狗" class="headerlink" title="1065、单身狗"></a>1065、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805266942377984" target="_blank" rel="noopener">单身狗</a></h4><p>“单身狗”是中文对于单身人士的一种爱称。本题请你从上万人的大型派对中找出落单的客人，以便给予特殊关爱。 </p><p><strong>输入描述</strong></p><p>输入第一行给出一个正整数 N（≤ 50 000），是已知夫妻/伴侣的对数；随后 N 行，每行给出一对夫妻/伴侣——为方便起见，每人对应一个 ID 号，为 5 位数字（从 00000 到 99999），ID 间以空格分隔；之后给出一个正整数 M（≤ 10 000），为参加派对的总人数；随后一行给出这 M 位客人的 ID，以空格分隔。题目保证无人重婚或脚踩两条船。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">3</span></span><br><span class="line">&gt; <span class="number">11111</span> <span class="number">22222</span></span><br><span class="line">&gt; <span class="number">33333</span> <span class="number">44444</span></span><br><span class="line">&gt; <span class="number">55555</span> <span class="number">66666</span></span><br><span class="line">&gt; <span class="number">7</span></span><br><span class="line">&gt; <span class="number">55555</span> <span class="number">44444</span> <span class="number">10000</span> <span class="number">88888</span> <span class="number">22222</span> <span class="number">11111</span> <span class="number">23333</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>首先第一行输出落单客人的总人数；随后第二行按 ID 递增顺序列出落单的客人。ID 间用 1 个空格分隔，行的首尾不得有多余空格。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">5</span></span><br><span class="line">&gt; <span class="number">10000</span> <span class="number">23333</span> <span class="number">44444</span> <span class="number">55555</span> <span class="number">88888</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">50000</span>][<span class="number">2</span>];</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> num1,num2;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d %d"</span>,&amp;num1,&amp;num2);</span><br><span class="line">arr[i][<span class="number">0</span>] = num1;</span><br><span class="line">arr[i][<span class="number">1</span>] = num2;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> arr1[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">arr1[num] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((arr1[arr[i][<span class="number">0</span>]] == <span class="number">1</span> )&amp;&amp;( arr1[arr[i][<span class="number">1</span>]] == <span class="number">1</span>)) &#123;</span><br><span class="line">arr1[arr[i][<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">arr1[arr[i][<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">m -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>,m);</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr1[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (!flag) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%05d"</span>,i);</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">printf</span> (<span class="string">" %05d"</span>,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1066、图像过滤"><a href="#1066、图像过滤" class="headerlink" title="1066、图像过滤"></a>1066、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805266514558976" target="_blank" rel="noopener">图像过滤</a></h4><p>图像过滤是把图像中不重要的像素都染成背景色，使得重要部分被凸显出来。现给定一幅黑白图像，要求你将灰度值位于某指定区间内的所有像素颜色都用一种指定的颜色替换。 </p><p><strong>输入描述</strong></p><p>输入在第一行给出一幅图像的分辨率，即两个正整数 M 和 N（0&lt;M,N≤500），另外是待过滤的灰度值区间端点 A 和 B（0≤A&lt;B≤255）、以及指定的替换灰度值。随后 M 行，每行给出 N 个像素点的灰度值，其间以空格分隔。所有灰度值都在 [0, 255] 区间内。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">3</span> <span class="number">5</span> <span class="number">100</span> <span class="number">150</span> <span class="number">0</span></span><br><span class="line">&gt; <span class="number">3</span> <span class="number">189</span> <span class="number">254</span> <span class="number">101</span> <span class="number">119</span></span><br><span class="line">&gt; <span class="number">150</span> <span class="number">233</span> <span class="number">151</span> <span class="number">99</span> <span class="number">100</span></span><br><span class="line">&gt; <span class="number">88</span> <span class="number">123</span> <span class="number">149</span> <span class="number">0</span> <span class="number">255</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>输出按要求过滤后的图像。即输出 M 行，每行 N 个像素灰度值，每个灰度值占 3 位（例如黑色要显示为 <code>000</code>），其间以一个空格分隔。行首尾不得有多余空格。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">003</span> <span class="number">189</span> <span class="number">254</span> <span class="number">000</span> <span class="number">000</span></span><br><span class="line">&gt; <span class="number">000</span> <span class="number">233</span> <span class="number">151</span> <span class="number">099</span> <span class="number">000</span></span><br><span class="line">&gt; <span class="number">088</span> <span class="number">000</span> <span class="number">000</span> <span class="number">000</span> <span class="number">255</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d %d %d %d %d"</span>,&amp;m,&amp;n,&amp;a,&amp;b,&amp;temp);</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;num[i][j]);</span><br><span class="line"><span class="keyword">if</span> (num[i][j] &gt;= a&amp;&amp;num[i][j] &lt;= b)</span><br><span class="line">num[i][j] = temp; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> ( j == <span class="number">0</span>) </span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%03d"</span>,num[i][j]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">" %03d"</span>,num[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1067、试密码"><a href="#1067、试密码" class="headerlink" title="1067、试密码"></a>1067、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805266007048192" target="_blank" rel="noopener">试密码</a></h4><p>当你试图登录某个系统却忘了密码时，系统一般只会允许你尝试有限多次，当超出允许次数时，账号就会被锁死。本题就请你实现这个小功能。 </p><p><strong>输入描述</strong></p><p>输入在第一行给出一个密码（长度不超过 20 的、不包含空格、Tab、回车的非空字符串）和一个正整数 N（≤ 10），分别是正确的密码和系统允许尝试的次数。随后每行给出一个以回车结束的非空字符串，是用户尝试输入的密码。输入保证至少有一次尝试。当读到一行只有单个 # 字符时，输入结束，并且这一行不是用户的输入。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Correct%pw 3</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> correct%pw</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Correct@PW</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> whatisthepassword!</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Correct%pw</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment">#</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>对用户的每个输入，如果是正确的密码且尝试次数不超过 N，则在一行中输出 <code>Welcome in</code>，并结束程序；如果是错误的，则在一行中按格式输出 <code>Wrong password: 用户输入的错误密码</code>；当错误尝试达到 N 次时，再输出一行 <code>Account locked</code>，并结束程序。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Wrong password: correct%pw</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Wrong password: Correct@PW</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Wrong password: whatisthepassword!</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Account locked</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//freopen("input.txt", "r", stdin);</span></span><br><span class="line">  <span class="comment">//freopen("output.txt", "w", stdout);</span></span><br><span class="line">  <span class="keyword">char</span> psw[<span class="number">21</span>], ans[<span class="number">10000</span>];     <span class="comment">//这里输出的密码数组记得大一点</span></span><br><span class="line">  <span class="keyword">int</span> N, flag;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, psw, &amp;N);</span><br><span class="line">  flag = N;</span><br><span class="line">  getchar();                    <span class="comment">//吃掉回车</span></span><br><span class="line">  fgets(ans, <span class="number">10000</span>, <span class="built_in">stdin</span>);     <span class="comment">//如果想读取带空格的字符串，就用fgets吧 不过fgets会读取最后一个‘/n’,所以要去掉‘/n’</span></span><br><span class="line">  <span class="keyword">if</span> (ans[<span class="built_in">strlen</span>(ans) - <span class="number">1</span>] == <span class="string">'\n'</span>) </span><br><span class="line">    ans[<span class="built_in">strlen</span>(ans) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">strlen</span>(ans) != <span class="number">1</span> || ans[<span class="number">0</span>] != <span class="string">'#'</span>)   <span class="comment">//这里就是判断是不是答案了 判断的先后顺序也很重要 </span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(psw, ans) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Welcome in"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Wrong password: %s\n"</span>, ans); flag--;    <span class="comment">//flag就是剩余的可以输入的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Account locked"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fgets(ans, <span class="number">10000</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> (ans[<span class="built_in">strlen</span>(ans) - <span class="number">1</span>] == <span class="string">'\n'</span>)</span><br><span class="line">      ans[<span class="built_in">strlen</span>(ans) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1068、万绿丛中一点红"><a href="#1068、万绿丛中一点红" class="headerlink" title="1068、万绿丛中一点红"></a>1068、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805265579229184" target="_blank" rel="noopener">万绿丛中一点红</a></h4><p>对于计算机而言，颜色不过是像素点对应的一个 24 位的数值。现给定一幅分辨率为 M×N 的画，要求你找出万绿丛中的一点红，即有独一无二颜色的那个像素点，并且该点的颜色与其周围 8 个相邻像素的颜色差充分大。 </p><p><strong>输入描述</strong></p><p>输入第一行给出三个正整数，分别是 M 和 N（≤ 1000），即图像的分辨率；以及 TOL，是所求像素点与相邻点的颜色差阈值，色差超过 TOL 的点才被考虑。随后 N 行，每行给出 M 个像素的颜色值，范围在 [0,224) 内。所有同行数字间用空格或 TAB 分开。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">8</span> <span class="number">6</span> <span class="number">200</span></span><br><span class="line">&gt; <span class="number">0</span>      <span class="number">0</span>       <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span>          <span class="number">0</span>           <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">&gt; <span class="number">65280</span>      <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">16711479</span> <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">65280</span></span><br><span class="line">&gt; <span class="number">16711479</span> <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">16711680</span> <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">65280</span></span><br><span class="line">&gt; <span class="number">65280</span>      <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">165280</span>   <span class="number">165280</span></span><br><span class="line">&gt; <span class="number">65280</span>      <span class="number">65280</span>       <span class="number">16777015</span> <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">165280</span>   <span class="number">65480</span>    <span class="number">165280</span></span><br><span class="line">&gt; <span class="number">16777215</span> <span class="number">16777215</span> <span class="number">16777215</span> <span class="number">16777215</span> <span class="number">16777215</span> <span class="number">16777215</span> <span class="number">16777215</span> <span class="number">16777215</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中按照 <code>(x, y): color</code> 的格式输出所求像素点的位置以及颜色值，其中位置 <code>x</code> 和 <code>y</code> 分别是该像素在图像矩阵中的列、行编号（从 1 开始编号）。如果这样的点不唯一，则输出 <code>Not Unique</code>；如果这样的点不存在，则输出 <code>Not Exist</code>。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> (5, 3): 16711680</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serch</span><span class="params">(<span class="keyword">int</span>**,<span class="keyword">int</span> ,<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;   <span class="comment">//判断这个数是不是只有一个</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//freopen("input.txt", "r", stdin);</span></span><br><span class="line">  <span class="comment">//freopen("output.txt", "w", stdout);</span></span><br><span class="line">  <span class="keyword">int</span> i, j, flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> **arr, **arr1, M, N, TOL, x, y, color, m, n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;M, &amp;N, &amp;TOL);</span><br><span class="line">  arr = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)*(N + <span class="number">2</span>));           <span class="comment">//申请2个相同的动态二维数组</span></span><br><span class="line">  arr1 = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)*(N + <span class="number">2</span>));</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N + <span class="number">2</span>; i++) &#123;</span><br><span class="line">    arr[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(M + <span class="number">2</span>)); </span><br><span class="line">    arr1[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(M + <span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N + <span class="number">2</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M + <span class="number">2</span>; j++) &#123;</span><br><span class="line">      arr[i][j] = <span class="number">0</span>;</span><br><span class="line">      arr1[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= M; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//for (i = 0; i &lt;= N + 1; i++) &#123;</span></span><br><span class="line">  <span class="comment">//  for (j = 0; j &lt;= M + 1; j++)</span></span><br><span class="line">  <span class="comment">//    printf("%.0lf\t", arr[i][j]);</span></span><br><span class="line">  <span class="comment">//  printf("\n");</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N; i++) &#123;              <span class="comment">//判断 8个方向</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= M; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (TOL &lt; <span class="built_in">abs</span>(arr[i][j] - arr[i - <span class="number">1</span>][j - <span class="number">1</span>]) &amp;&amp; TOL &lt; <span class="built_in">abs</span>(arr[i][j] - arr[i - <span class="number">1</span>][j]) &amp;&amp;</span><br><span class="line">        TOL &lt; <span class="built_in">abs</span>(arr[i][j] - arr[i - <span class="number">1</span>][j + <span class="number">1</span>]) &amp;&amp; TOL &lt; <span class="built_in">abs</span>(arr[i][j] - arr[i][j - <span class="number">1</span>]) &amp;&amp;</span><br><span class="line">        TOL &lt; <span class="built_in">abs</span>(arr[i][j] - arr[i][j + <span class="number">1</span>]) &amp;&amp; TOL &lt; <span class="built_in">abs</span>(arr[i][j] - arr[i + <span class="number">1</span>][j - <span class="number">1</span>]) &amp;&amp;</span><br><span class="line">        TOL &lt; <span class="built_in">abs</span>(arr[i][j] - arr[i + <span class="number">1</span>][j]) &amp;&amp; TOL &lt; <span class="built_in">abs</span>(arr[i][j] - arr[i + <span class="number">1</span>][j + <span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">if</span> (serch(arr, M, N, arr[i][j])) &#123;      <span class="comment">//如果上面条件满足，还要满足这个数只有一个</span></span><br><span class="line">          x = j; y = i; color = arr[i][j]; flag++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span>(flag==<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(%d, %d): %d"</span>, x, y, color);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(flag&gt;<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Not Unique"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Not Exist"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serch</span><span class="params">(<span class="keyword">int</span>** a,<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">int</span> color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j, k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i][j] == color)</span><br><span class="line">        k++;</span><br><span class="line">      <span class="keyword">if</span>(k&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1069、微博转发抽奖"><a href="#1069、微博转发抽奖" class="headerlink" title="1069、微博转发抽奖"></a>1069、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805265159798784" target="_blank" rel="noopener">微博转发抽奖</a></h4><p>小明 PAT 考了满分，高兴之余决定发起微博转发抽奖活动，从转发的网友中按顺序每隔 N 个人就发出一个红包。请你编写程序帮助他确定中奖名单。 </p><p><strong>输入描述</strong></p><p>输入第一行给出三个正整数 M（≤ 1000）、N 和 S，分别是转发的总量、小明决定的中奖间隔、以及第一位中奖者的序号（编号从 1 开始）。随后 M 行，顺序给出转发微博的网友的昵称（不超过 20 个字符、不包含空格回车的非空字符串）。</p><p>注意：可能有人转发多次，但不能中奖多次。所以如果处于当前中奖位置的网友已经中过奖，则跳过他顺次取下一位。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 9 3 2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Imgonnawin!</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> PickMe</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> PickMeMeMeee</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> LookHere</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Imgonnawin!</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> TryAgainAgain</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> TryAgainAgain</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Imgonnawin!</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> TryAgainAgain</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>按照输入的顺序输出中奖名单，每个昵称占一行。如果没有人中奖，则输出 <code>Keep going...</code>。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> PickMe</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Imgonnawin!</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> TryAgainAgain</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//freopen("input.txt", "r", stdin);</span></span><br><span class="line">  <span class="comment">//freopen("output.txt", "w", stdout);</span></span><br><span class="line">  <span class="keyword">int</span> M, N, S, i, j,flag = <span class="number">0</span>, flag1 = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> <span class="built_in">list</span>[<span class="number">1010</span>][<span class="number">30</span>];</span><br><span class="line">  <span class="keyword">char</span> str[<span class="number">30</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;M, &amp;N, &amp;S);</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    fgets(str, <span class="number">30</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> (str[<span class="built_in">strlen</span>(str) - <span class="number">1</span>] == <span class="string">'\n'</span>)</span><br><span class="line">      str[<span class="built_in">strlen</span>(str) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= S) &#123;</span><br><span class="line">      <span class="keyword">if</span> (count% N == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; flag; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="built_in">list</span>[j], str) == <span class="number">0</span>) &#123;</span><br><span class="line">            flag1 = <span class="number">1</span>; count--;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag1) &#123;</span><br><span class="line">          <span class="built_in">strcpy</span>(<span class="built_in">list</span>[flag], str); flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        flag1 = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Keep going...\n"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; flag; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="built_in">list</span>[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1070、结绳"><a href="#1070、结绳" class="headerlink" title="1070、结绳"></a>1070、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805264706813952" target="_blank" rel="noopener">结绳</a></h4><p>给定一段一段的绳子，你需要把它们串成一条绳。每次串连的时候，是把两段绳子对折，再如下图所示套接在一起。这样得到的绳子又被当成是另一段绳子，可以再次对折去跟另一段绳子串连。每次串连后，原来两段绳子的长度就会减半。 给定 N 段绳子的长度，你需要找出它们能串成的绳子的最大长度。 </p><p><strong>输入描述</strong></p><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出正整数 N (2≤N≤10^4^)；第 2 行给出 N 个正整数，即原始绳段的长度，数字间以空格分隔。所有整数都不超过10^4^。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">8</span></span><br><span class="line">&gt; <span class="number">10</span> <span class="number">15</span> <span class="number">12</span> <span class="number">3</span> <span class="number">4</span> <span class="number">13</span> <span class="number">1</span> <span class="number">15</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中输出能够串成的绳子的最大长度。结果向下取整，即取为不超过最大长度的最近整数。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 14</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*a, <span class="keyword">const</span> <span class="keyword">void</span>*b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//freopen("input.txt", "r", stdin);</span></span><br><span class="line">  <span class="comment">//freopen("output.txt", "w", stdout);</span></span><br><span class="line">  <span class="keyword">int</span> N, i;</span><br><span class="line">  <span class="keyword">int</span> arr[<span class="number">100000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="keyword">double</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  qsort(arr, N, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br><span class="line">  count += arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (i =<span class="number">1</span>; i &lt;N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    count = count / <span class="number">2</span> + (arr[i] / <span class="number">2.0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="keyword">int</span>)count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1071、小赌怡情"><a href="#1071、小赌怡情" class="headerlink" title="1071、小赌怡情"></a>1071、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805264312549376" target="_blank" rel="noopener">小赌怡情</a></h4><p>常言道“小赌怡情”。这是一个很简单的小游戏：首先由计算机给出第一个整数；然后玩家下注赌第二个整数将会比第一个数大还是小；玩家下注 t 个筹码后，计算机给出第二个数。若玩家猜对了，则系统奖励玩家 t 个筹码；否则扣除玩家 t 个筹码。</p><p>注意：玩家下注的筹码数不能超过自己帐户上拥有的筹码数。当玩家输光了全部筹码后，游戏就结束。</p><p><strong>输入描述</strong></p><p>输入在第一行给出 2 个正整数 T 和 K（≤ 100），分别是系统在初始状态下赠送给玩家的筹码数、以及需要处理的游戏次数。随后 K 行，每行对应一次游戏，顺序给出 4 个数字：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">n1</span> b t <span class="symbol">n2</span></span><br></pre></td></tr></table></figure><p>其中 <code>n1</code> 和 <code>n2</code> 是计算机先后给出的两个[0, 9]内的整数，保证两个数字不相等。<code>b</code> 为 0 表示玩家赌<code>小</code>，为 1 表示玩家赌<code>大</code>。<code>t</code> 表示玩家下注的筹码数，保证在整型范围内。</p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">100</span> <span class="number">4</span></span><br><span class="line">&gt; <span class="number">8</span> <span class="number">0</span> <span class="number">100</span> <span class="number">2</span></span><br><span class="line">&gt; <span class="number">3</span> <span class="number">1</span> <span class="number">50</span> <span class="number">1</span></span><br><span class="line">&gt; <span class="number">5</span> <span class="number">1</span> <span class="number">200</span> <span class="number">6</span></span><br><span class="line">&gt; <span class="number">7</span> <span class="number">0</span> <span class="number">200</span> <span class="number">8</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>对每一次游戏，根据下列情况对应输出（其中 <code>t</code> 是玩家下注量，<code>x</code> 是玩家当前持有的筹码量）：</p><ul><li>玩家赢，输出 <code>Win t! Total = x.</code>；</li><li>玩家输，输出 <code>Lose t. Total = x.</code>；</li><li>玩家下注超过持有的筹码量，输出 <code>Not enough tokens. Total = x.</code>；</li><li>玩家输光后，输出 <code>Game Over.</code> 并结束程序。</li></ul><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; Win <span class="number">100</span>!  Total = <span class="number">200.</span></span><br><span class="line">&gt; Lose <span class="number">50.</span>  Total = <span class="number">150.</span></span><br><span class="line">&gt; Not enough tokens.  Total = <span class="number">150.</span></span><br><span class="line">&gt; Not enough tokens.  Total = <span class="number">150.</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x,k;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d %d"</span>,&amp;x,&amp;k);</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">105</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d %d %d %d"</span>,&amp;num[i][<span class="number">0</span>],&amp;num[i][<span class="number">1</span>],&amp;num[i][<span class="number">2</span>],&amp;num[i][<span class="number">3</span>]);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> n1,b,t,n2;</span><br><span class="line">n1 = num[i][<span class="number">0</span>];</span><br><span class="line">b = num[i][<span class="number">1</span>];</span><br><span class="line">t = num[i][<span class="number">2</span>];</span><br><span class="line">n2 = num[i][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">if</span> ( t &gt; x ) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"Not enough tokens.  Total = %d."</span>,x);</span><br><span class="line"><span class="keyword">if</span> (i != k<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (((n2 &lt; n1) &amp;&amp; (b == <span class="number">0</span>)) || ((n2 &gt; n1) &amp;&amp; (b == <span class="number">1</span>))) &#123; <span class="comment">// win</span></span><br><span class="line">x += t;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Win %d!  Total = %d."</span>,t,x);</span><br><span class="line"><span class="keyword">if</span> (i != k<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">x -= t;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"Lose %d.  Total = %d."</span>,t,x);</span><br><span class="line"><span class="keyword">if</span> (i != k<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"Game Over."</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1072、开学寄语"><a href="#1072、开学寄语" class="headerlink" title="1072、开学寄语"></a>1072、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805263964422144" target="_blank" rel="noopener">开学寄语</a></h4><p>下图是上海某校的新学期开学寄语：天将降大任于斯人也，必先删其微博，卸其 QQ，封其电脑，夺其手机，收其 ipad，断其 wifi，使其百无聊赖，然后，净面、理发、整衣，然后思过、读书、锻炼、明智、开悟、精进。而后必成大器也！ 本题要求你写个程序帮助这所学校的老师检查所有学生的物品，以助其成大器。 </p><p><strong>输入描述</strong></p><p>输入第一行给出两个正整数 N（≤ 1000）和 M（≤ 6），分别是学生人数和需要被查缴的物品种类数。第二行给出 M 个需要被查缴的物品编号，其中编号为 4 位数字。随后 N 行，每行给出一位学生的姓名缩写（由 1-4 个大写英文字母组成）、个人物品数量 K（0 ≤ K ≤ 10）、以及 K 个物品的编号。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">4</span> <span class="number">2</span></span><br><span class="line">&gt; <span class="number">2333</span> <span class="number">6666</span></span><br><span class="line">&gt; CYLL <span class="number">3</span> <span class="number">1234</span> <span class="number">2345</span> <span class="number">3456</span></span><br><span class="line">&gt; U <span class="number">4</span> <span class="number">9966</span> <span class="number">6666</span> <span class="number">8888</span> <span class="number">6666</span></span><br><span class="line">&gt; GG <span class="number">2</span> <span class="number">2333</span> <span class="number">7777</span></span><br><span class="line">&gt; JJ <span class="number">3</span> <span class="number">0012</span> <span class="number">6666</span> <span class="number">2333</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>顺次检查每个学生携带的物品，如果有需要被查缴的物品存在，则按以下格式输出该生的信息和其需要被查缴的物品的信息（注意行末不得有多余空格）：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">姓名缩写: 物品编号1 物品编号2 ……</span></span><br></pre></td></tr></table></figure><p>最后一行输出存在问题的学生的总人数和被查缴物品的总数。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> U: 6666 6666</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GG: 2333</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> JJ: 6666 2333</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 3 5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st , th , i , j , in[<span class="number">10000</span>] = &#123;<span class="number">0</span>&#125; , all = <span class="number">0</span> , num = <span class="number">0</span> , tmp , temp , flag ; </span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">5</span>] ; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; st &gt;&gt; th ; </span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; th ; i++ ) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp ;  </span><br><span class="line">        in[tmp] = <span class="number">1</span> ;  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; st ; i++ )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; name &gt;&gt; tmp ; </span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span> , flag = <span class="number">0</span> ; j &lt; tmp ; j++ )&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp ; </span><br><span class="line">            <span class="keyword">if</span> ( in[temp] == <span class="number">1</span> )&#123;</span><br><span class="line">                num++ ; </span><br><span class="line">                <span class="keyword">if</span> ( flag == <span class="number">0</span> ) &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">":"</span> ; </span><br><span class="line">                    flag = <span class="number">1</span> ; </span><br><span class="line">                    all++ ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %04d"</span>,temp) ; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( flag )</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; all &lt;&lt; <span class="string">" "</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1073、多选题常见计分法"><a href="#1073、多选题常见计分法" class="headerlink" title="1073、多选题常见计分法"></a>1073、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805263624683520" target="_blank" rel="noopener">多选题常见计分法</a></h4><p>批改多选题是比较麻烦的事情，有很多不同的计分方法。有一种最常见的计分方法是：如果考生选择了部分正确选项，并且没有选择任何错误选项，则得到 50% 分数；如果考生选择了任何一个错误的选项，则不能得分。本题就请你写个程序帮助老师批改多选题，并且指出哪道题的哪个选项错的人最多。 </p><p><strong>输入描述</strong></p><p>输入在第一行给出两个正整数 N（≤1000）和 M（≤100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 <code>(选中的选项个数 选项1 ……)</code>，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。 </p><blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">3</span> <span class="number">4</span> </span><br><span class="line">&gt; <span class="number">3</span> <span class="number">4</span> <span class="number">2</span> <span class="selector-tag">a</span> c</span><br><span class="line">&gt; <span class="number">2</span> <span class="number">5</span> <span class="number">1</span> b</span><br><span class="line">&gt; <span class="number">5</span> <span class="number">3</span> <span class="number">2</span> <span class="selector-tag">b</span> c</span><br><span class="line">&gt; <span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> d e</span><br><span class="line">&gt; (<span class="number">2</span> <span class="selector-tag">a</span> c) (<span class="number">3</span> <span class="selector-tag">b</span> d e) (<span class="number">2</span> <span class="selector-tag">a</span> c) (<span class="number">3</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> e)</span><br><span class="line">&gt; (<span class="number">2</span> <span class="selector-tag">a</span> c) (<span class="number">1</span> b) (<span class="number">2</span> <span class="selector-tag">a</span> b) (<span class="number">4</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> d e)</span><br><span class="line">&gt; (<span class="number">2</span> <span class="selector-tag">b</span> d) (<span class="number">1</span> e) (<span class="number">1</span> c) (<span class="number">4</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> c d)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>按照输入的顺序给出每个学生的得分，每个分数占一行，输出小数点后 1 位。最后输出错得最多的题目选项的信息，格式为：<code>错误次数 题目编号（题目按照输入的顺序从1开始编号）-选项号</code>。如果有并列，则每行一个选项，按题目编号递增顺序输出；再并列则按选项号递增顺序输出。行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 <code>Too simple</code>。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">3.5</span></span><br><span class="line">&gt; <span class="number">6.0</span></span><br><span class="line">&gt; <span class="number">2.5</span></span><br><span class="line">&gt; <span class="number">2</span> <span class="number">2</span>-e</span><br><span class="line">&gt; <span class="number">2</span> <span class="number">3</span>-a</span><br><span class="line">&gt; <span class="number">2</span> <span class="number">3</span>-b</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> n, m, i, j, k, max = <span class="number">0</span>, temp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%hd%hd"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">short</span> score[m], ac[m], err[m][<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">float</span> stu_sco[n];</span><br><span class="line">    <span class="built_in">memset</span>(ac, <span class="number">0</span>, m &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(stu_sco, <span class="number">0</span>, n &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memset</span>(err, <span class="number">0</span>, <span class="keyword">sizeof</span>(err));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%hd%*d%hd"</span>, score + i, &amp;j);</span><br><span class="line">        <span class="keyword">while</span>(j--)</span><br><span class="line">        &#123;</span><br><span class="line">            getchar();</span><br><span class="line">            ac[i] |= <span class="number">1</span> &lt;&lt; (getchar() - <span class="number">97</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%*[^0-5]%hd"</span>, &amp;k);</span><br><span class="line">            temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(k--)</span><br><span class="line">            &#123;</span><br><span class="line">                getchar();</span><br><span class="line">                temp |= <span class="number">1</span> &lt;&lt; (getchar() - <span class="number">97</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp == ac[j])</span><br><span class="line">            &#123;</span><br><span class="line">                stu_sco[i] += score[j];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((temp | ac[j]) == ac[j])</span><br><span class="line">            &#123;</span><br><span class="line">                stu_sco[i] += score[j] / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp ^= ac[j];</span><br><span class="line">            <span class="keyword">while</span>(temp != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                k = temp &amp; -temp;</span><br><span class="line">                <span class="keyword">switch</span>(k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>: err[j][<span class="number">0</span>]++; max &lt; err[j][<span class="number">0</span>] ? max = err[j][<span class="number">0</span>] : <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>: err[j][<span class="number">1</span>]++; max &lt; err[j][<span class="number">1</span>] ? max = err[j][<span class="number">1</span>] : <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">4</span>: err[j][<span class="number">2</span>]++; max &lt; err[j][<span class="number">2</span>] ? max = err[j][<span class="number">2</span>] : <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">8</span>: err[j][<span class="number">3</span>]++; max &lt; err[j][<span class="number">3</span>] ? max = err[j][<span class="number">3</span>] : <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>: err[j][<span class="number">4</span>]++; max &lt; err[j][<span class="number">4</span>] ? max = err[j][<span class="number">4</span>] : <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp -= k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.1f\n"</span>, stu_sco[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(max == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Too simple"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(err[i][j] == max)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%hd %hd-%c\n"</span>, max, i + <span class="number">1</span>, <span class="number">97</span> + j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1074、宇宙无敌加法器"><a href="#1074、宇宙无敌加法器" class="headerlink" title="1074、宇宙无敌加法器"></a>1074、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805263297527808" target="_blank" rel="noopener">宇宙无敌加法器</a></h4><p>地球人习惯使用十进制数，并且默认一个数字的每一位都是十进制的。而在 PAT 星人开挂的世界里，每个数字的每一位都是不同进制的，这种神奇的数字称为“PAT数”。每个 PAT 星人都必须熟记各位数字的进制表，例如“……0527”就表示最低位是 7 进制数、第 2 位是 2 进制数、第 3 位是 5 进制数、第 4 位是 10 进制数，等等。每一位的进制 d 或者是 0（表示十进制）、或者是 [2，9] 区间内的整数。理论上这个进制表应该包含无穷多位数字，但从实际应用出发，PAT 星人通常只需要记住前 20 位就够用了，以后各位默认为 10 进制。</p><p>在这样的数字系统中，即使是简单的加法运算也变得不简单。例如对应进制表“0527”，该如何计算“6203 + 415”呢？我们得首先计算最低位：3 + 5 = 8；因为最低位是 7 进制的，所以我们得到 1 和 1 个进位。第 2 位是：0 + 1 + 1（进位）= 2；因为此位是 2 进制的，所以我们得到 0 和 1 个进位。第 3 位是：2 + 4 + 1（进位）= 7；因为此位是 5 进制的，所以我们得到 2 和 1 个进位。第 4 位是：6 + 1（进位）= 7；因为此位是 10 进制的，所以我们就得到 7。最后我们得到：6203 + 415 = 7201。</p><p><strong>输入描述</strong></p><p>输入首先在第一行给出一个 N 位的进制表（0 &lt; N ≤ 20），以回车结束。 随后两行，每行给出一个不超过 N 位的非负的 PAT 数。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 30527</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 06203</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 415</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中输出两个 PAT 数之和。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 7201</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">char</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = n &gt;&gt; <span class="number">1</span>, i;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] ^= a[n - i];</span><br><span class="line">        a[n - i] ^= a[i];</span><br><span class="line">        a[i] ^= a[n - i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">21</span>], b[<span class="number">22</span>], c[<span class="number">21</span>];</span><br><span class="line">    <span class="keyword">int</span> x, y, z, i;</span><br><span class="line">    gets(a);</span><br><span class="line">    x = <span class="built_in">strlen</span>(a);</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">48</span>, x + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">48</span>, x);</span><br><span class="line">    gets(b);</span><br><span class="line">    gets(c);</span><br><span class="line">    y = <span class="built_in">strlen</span>(b);</span><br><span class="line">    b[y] = <span class="number">48</span>;</span><br><span class="line">    z = <span class="built_in">strlen</span>(c);</span><br><span class="line">    c[z] = <span class="number">48</span>;</span><br><span class="line">    rev(a, x);</span><br><span class="line">    rev(b, y);</span><br><span class="line">    rev(c, z);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; x; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">48</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = <span class="number">58</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        b[i] += c[i] - <span class="number">48</span>;</span><br><span class="line">        <span class="keyword">if</span>(b[i] &gt;= a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] -= <span class="number">48</span>;</span><br><span class="line">            b[i] -= <span class="number">48</span>;</span><br><span class="line">            b[i + <span class="number">1</span>] += b[i] / a[i];</span><br><span class="line">            b[i] = b[i] % a[i] + <span class="number">48</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = x; i &gt;= <span class="number">0</span> &amp;&amp; b[i] == <span class="number">48</span>; i--);</span><br><span class="line">    rev(b, i + <span class="number">1</span>);</span><br><span class="line">    b[i + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(b[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1075、链表元素分类"><a href="#1075、链表元素分类" class="headerlink" title="1075、链表元素分类"></a>1075、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805262953594880" target="_blank" rel="noopener">链表元素分类</a></h4><p>给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而 [0, K] 区间内的元素都排在大于 K 的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为 18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为 -4→-6→-2→7→0→5→10→18→11。 </p><p><strong>输入描述</strong></p><p>每个输入包含一个测试用例。每个测试用例第 1 行给出：第 1 个结点的地址；结点总个数，即正整数N (≤105)；以及正整数K (≤103)。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p><p>接下来有 N 行，每行格式为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Address </span><span class="meta">Data</span> Next</span><br></pre></td></tr></table></figure><p>其中 <code>Address</code> 是结点地址；<code>Data</code> 是该结点保存的数据，为 [−105,105] 区间内的整数；<code>Next</code> 是下一结点的地址。题目保证给出的链表不为空。</p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">00100</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">&gt; <span class="number">23333</span> <span class="number">10</span> <span class="number">27777</span></span><br><span class="line">&gt; <span class="number">00000</span> <span class="number">0</span> <span class="number">99999</span></span><br><span class="line">&gt; <span class="number">00100</span> <span class="number">18</span> <span class="number">12309</span></span><br><span class="line">&gt; <span class="number">68237</span> <span class="number">-6</span> <span class="number">23333</span></span><br><span class="line">&gt; <span class="number">33218</span> <span class="number">-4</span> <span class="number">00000</span></span><br><span class="line">&gt; <span class="number">48652</span> <span class="number">-2</span> <span class="number">-1</span></span><br><span class="line">&gt; <span class="number">99999</span> <span class="number">5</span> <span class="number">68237</span></span><br><span class="line">&gt; <span class="number">27777</span> <span class="number">11</span> <span class="number">48652</span></span><br><span class="line">&gt; <span class="number">12309</span> <span class="number">7</span> <span class="number">33218</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>对每个测试用例，按链表从头到尾的顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">33218</span> <span class="number">-4</span> <span class="number">68237</span></span><br><span class="line">&gt; <span class="number">68237</span> <span class="number">-6</span> <span class="number">48652</span></span><br><span class="line">&gt; <span class="number">48652</span> <span class="number">-2</span> <span class="number">12309</span></span><br><span class="line">&gt; <span class="number">12309</span> <span class="number">7</span> <span class="number">00000</span></span><br><span class="line">&gt; <span class="number">00000</span> <span class="number">0</span> <span class="number">99999</span></span><br><span class="line">&gt; <span class="number">99999</span> <span class="number">5</span> <span class="number">23333</span></span><br><span class="line">&gt; <span class="number">23333</span> <span class="number">10</span> <span class="number">00100</span></span><br><span class="line">&gt; <span class="number">00100</span> <span class="number">18</span> <span class="number">27777</span></span><br><span class="line">&gt; <span class="number">27777</span> <span class="number">11</span> <span class="number">-1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m, *value;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (value[a] &lt; <span class="number">0</span> &amp;&amp; value[b] &gt;= <span class="number">0</span>) || (value[a] &lt;= m &amp;&amp; value[b] &gt; m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head, n, i, x, next[<span class="number">100000</span>], val[<span class="number">100000</span>];</span><br><span class="line">    value = val;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;head, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> que[n];</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, val + x, next + x);</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        que[i++] = head;</span><br><span class="line">        head = next[head];</span><br><span class="line">    &#125;</span><br><span class="line">    stable_sort(que, que + i, cmp);</span><br><span class="line">    n = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d %d %05d\n"</span>, que[i], val[que[i]], que[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%05d %d -1"</span>, que[i], val[que[i]]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1076、Wifi密码"><a href="#1076、Wifi密码" class="headerlink" title="1076、Wifi密码"></a>1076、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805262622244864" target="_blank" rel="noopener">Wifi密码</a></h4><p>下面是微博上流传的一张照片：“各位亲爱的同学们，鉴于大家有时需要使用 wifi，又怕耽误亲们的学习，现将 wifi 密码设置为下列数学题答案：A-1；B-2；C-3；D-4；请同学们自己作答，每两日一换。谢谢合作！！~”—— 老师们为了促进学生学习也是拼了…… 本题就要求你写程序把一系列题目的答案按照卷子上给出的对应关系翻译成 wifi 的密码。这里简单假设每道选择题都有 4 个选项，有且只有 1 个正确答案。</p><p><strong>输入描述</strong></p><p>输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行按照 <code>编号-答案</code> 的格式给出一道题的 4 个选项，<code>T</code> 表示正确选项，<code>F</code> 表示错误选项。选项间用空格分隔。 </p><blockquote><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">8</span></span><br><span class="line">&gt; A-<span class="literal">T</span> B-<span class="literal">F</span> C-<span class="literal">F</span> D-<span class="literal">F</span></span><br><span class="line">&gt; C-<span class="literal">T</span> B-<span class="literal">F</span> A-<span class="literal">F</span> D-<span class="literal">F</span></span><br><span class="line">&gt; A-<span class="literal">F</span> D-<span class="literal">F</span> C-<span class="literal">F</span> B-<span class="literal">T</span></span><br><span class="line">&gt; B-<span class="literal">T</span> A-<span class="literal">F</span> C-<span class="literal">F</span> D-<span class="literal">F</span></span><br><span class="line">&gt; B-<span class="literal">F</span> D-<span class="literal">T</span> A-<span class="literal">F</span> C-<span class="literal">F</span></span><br><span class="line">&gt; A-<span class="literal">T</span> C-<span class="literal">F</span> B-<span class="literal">F</span> D-<span class="literal">F</span></span><br><span class="line">&gt; D-<span class="literal">T</span> B-<span class="literal">F</span> C-<span class="literal">F</span> A-<span class="literal">F</span></span><br><span class="line">&gt; C-<span class="literal">T</span> A-<span class="literal">F</span> B-<span class="literal">F</span> D-<span class="literal">F</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中输出 wifi 密码。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 13224143</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">105</span>];</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> ch1,an1,ch2,an2,ch3,an3,ch4,an4;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"\n%c-%c %c-%c %c-%c %c-%c"</span>,&amp;ch1,&amp;an1,&amp;ch2,&amp;an2,&amp;ch3,&amp;an3,&amp;ch4,&amp;an4);</span><br><span class="line"><span class="keyword">if</span> (an1 == <span class="string">'T'</span>)</span><br><span class="line">ans[i] = ch1-<span class="string">'A'</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (an2 == <span class="string">'T'</span>)</span><br><span class="line">ans[i] = ch2-<span class="string">'A'</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (an3 == <span class="string">'T'</span>)</span><br><span class="line">ans[i] = ch3-<span class="string">'A'</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (an4 == <span class="string">'T'</span>)</span><br><span class="line">ans[i] = ch4-<span class="string">'A'</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>,ans[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1077、互评成绩计算"><a href="#1077、互评成绩计算" class="headerlink" title="1077、互评成绩计算"></a>1077、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805262303477760" target="_blank" rel="noopener">互评成绩计算</a></h4><p>在浙大的计算机专业课中，经常有互评分组报告这个环节。一个组上台介绍自己的工作，其他组在台下为其表现评分。最后这个组的互评成绩是这样计算的：所有其他组的评分中，去掉一个最高分和一个最低分，剩下的分数取平均分记为 G1；老师给这个组的评分记为 G2。该组得分为 (G1+G2)/2，最后结果四舍五入后保留整数分。本题就要求你写个程序帮助老师计算每个组的互评成绩。 </p><p><strong>输入描述</strong></p><p>输入第一行给出两个正整数 N（&gt; 3）和 M，分别是分组数和满分，均不超过 100。随后 N 行，每行给出该组得到的 N 个分数（均保证为整型范围内的整数），其中第 1 个是老师给出的评分，后面 N−1 个是其他组给的评分。合法的输入应该是 [0,M] 区间内的整数，若不在合法区间内，则该分数须被忽略。题目保证老师的评分都是合法的，并且每个组至少会有 3 个来自同学的合法评分。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">6</span> <span class="number">50</span></span><br><span class="line">&gt; <span class="number">42</span> <span class="number">49</span> <span class="number">49</span> <span class="number">35</span> <span class="number">38</span> <span class="number">41</span></span><br><span class="line">&gt; <span class="number">36</span> <span class="number">51</span> <span class="number">50</span> <span class="number">28</span> <span class="number">-1</span> <span class="number">30</span></span><br><span class="line">&gt; <span class="number">40</span> <span class="number">36</span> <span class="number">41</span> <span class="number">33</span> <span class="number">47</span> <span class="number">49</span></span><br><span class="line">&gt; <span class="number">30</span> <span class="number">250</span> <span class="number">-25</span> <span class="number">27</span> <span class="number">45</span> <span class="number">31</span></span><br><span class="line">&gt; <span class="number">48</span> <span class="number">0</span> <span class="number">0</span> <span class="number">50</span> <span class="number">50</span> <span class="number">1234</span></span><br><span class="line">&gt; <span class="number">43</span> <span class="number">41</span> <span class="number">36</span> <span class="number">29</span> <span class="number">42</span> <span class="number">29</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>为每个组输出其最终得分。每个得分占一行。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 42</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 33</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 41</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 31</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 37</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 39</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">double</span> grade_lao;</span><br><span class="line"><span class="keyword">double</span> max = <span class="number">0</span>,min = m+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lf"</span>,&amp;grade_lao);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n<span class="number">-1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">double</span> temp;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lf"</span>,&amp;temp);</span><br><span class="line"><span class="keyword">if</span> (temp &gt;= <span class="number">0</span> &amp;&amp; temp &lt;= m) &#123;</span><br><span class="line">count++;</span><br><span class="line">sum += temp;</span><br><span class="line"><span class="keyword">if</span> (max &lt; temp)</span><br><span class="line">max = temp;</span><br><span class="line"><span class="keyword">if</span> (min &gt; temp)</span><br><span class="line">min = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> ans = (grade_lao + (<span class="keyword">double</span>)(sum - max - min)/ (count - <span class="number">2</span>)) / <span class="number">2</span>;</span><br><span class="line">ans = (<span class="keyword">int</span>)(ans + <span class="number">0.5</span>) &gt; (<span class="keyword">int</span>)ans ? (<span class="keyword">int</span>) ans + <span class="number">1</span> : (<span class="keyword">int</span> ) ans;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>,(<span class="keyword">int</span>)ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1078、字符串压缩与解压"><a href="#1078、字符串压缩与解压" class="headerlink" title="1078、字符串压缩与解压"></a>1078、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805262018265088" target="_blank" rel="noopener">字符串压缩与解压</a></h4><p>文本压缩有很多种方法，这里我们只考虑最简单的一种：把由相同字符组成的一个连续的片段用这个字符和片段中含有这个字符的个数来表示。例如 <code>ccccc</code> 就用 <code>5c</code> 来表示。如果字符没有重复，就原样输出。例如 <code>aba</code> 压缩后仍然是 <code>aba</code>。</p><p>解压方法就是反过来，把形如 <code>5c</code> 这样的表示恢复为 <code>ccccc</code>。</p><p>本题需要你根据压缩或解压的要求，对给定字符串进行处理。这里我们简单地假设原始字符串是完全由英文字母和空格组成的非空字符串。</p><p><strong>输入描述</strong></p><p>输入第一行给出一个字符，如果是 <code>C</code> 就表示下面的字符串需要被压缩；如果是 <code>D</code> 就表示下面的字符串需要被解压。第二行给出需要被压缩或解压的不超过 1000 个字符的字符串，以回车结尾。题目保证字符重复个数在整型范围内，且输出文件不超过 1MB。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> C</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> TTTTThhiiiis isssss a   tesssst CAaaa as</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>根据要求压缩或解压字符串，并在一行中输出结果。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 5T2h4is i5s a3 te4st CA3a as</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="built_in">string</span> all ; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">D</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; all.length() ; i++ ) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span> ; </span><br><span class="line">        <span class="keyword">while</span> ( all[i] &gt;= <span class="string">'0'</span> &amp;&amp; all[i] &lt;= <span class="string">'9'</span> ) </span><br><span class="line">            sum = sum*<span class="number">10</span> + all[i++]-<span class="string">'0'</span> ; </span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; sum ; j++ ) </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; all[i] ; </span><br><span class="line">        <span class="keyword">if</span> ( sum == <span class="number">0</span> ) </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; all[i] ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">C</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span> ; j &lt; all.length() ; ) &#123;</span><br><span class="line">        <span class="keyword">while</span> ( all[i] == all[j] ) </span><br><span class="line">            j++ ; </span><br><span class="line">        <span class="keyword">if</span> ( j - i &gt; <span class="number">1</span> ) <span class="built_in">cout</span> &lt;&lt; j - i ; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; all[i] ; </span><br><span class="line">        i = j ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> f ; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; f ; </span><br><span class="line">    getchar() ; </span><br><span class="line">    getline(<span class="built_in">cin</span>,all) ; </span><br><span class="line">    <span class="keyword">if</span> ( f == <span class="string">'D'</span> ) </span><br><span class="line">        D() ; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        C() ; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1079、延迟的回文数"><a href="#1079、延迟的回文数" class="headerlink" title="1079、延迟的回文数"></a>1079、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805261754023936" target="_blank" rel="noopener">延迟的回文数</a></h4><p>给定一个 k+1 位的正整数 N，写成 ak⋯a1a0 的形式，其中对所有 i 有 0≤ai<10 且 ak>0。N 被称为一个<strong>回文数</strong>，当且仅当对所有 i 有 ai=ak−i。零也被定义为一个回文数。</10></p><p>非回文数也可以通过一系列操作变出回文数。首先将该数字逆转，再将逆转数与该数相加，如果和还不是一个回文数，就重复这个逆转再相加的操作，直到一个回文数出现。如果一个非回文数可以变出回文数，就称这个数为<strong>延迟的回文数</strong>。（定义翻译自 <a href="https://en.wikipedia.org/wiki/Palindromic_number" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Palindromic_number</a> ）</p><p>给定任意一个正整数，本题要求你找到其变出的那个回文数。</p><p><strong>输入描述</strong></p><p>输入在一行中给出一个不超过1000位的正整数。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 97152</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>对给定的整数，一行一行输出其变出回文数的过程。每行格式如下</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A + <span class="keyword">B </span>= C</span><br></pre></td></tr></table></figure><p>其中 <code>A</code> 是原始的数字，<code>B</code> 是 <code>A</code> 的逆转数，<code>C</code> 是它们的和。<code>A</code> 从输入的整数开始。重复操作直到 <code>C</code> 在 10 步以内变成回文数，这时在一行中输出 <code>C is a palindromic number.</code>；或者如果 10 步都没能得到回文数，最后就在一行中输出 <code>Not found in 10 iterations.</code>。</p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">97152</span> + <span class="number">25179</span> = <span class="number">122331</span></span><br><span class="line">&gt; <span class="number">122331</span> + <span class="number">133221</span> = <span class="number">255552</span></span><br><span class="line">&gt; <span class="number">255552</span> is a palindromic number.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a ; </span><br><span class="line">    <span class="keyword">int</span> i, j ; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a ; </span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ ) &#123;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>, len = a.length(), flag = <span class="number">0</span> ; </span><br><span class="line">        <span class="built_in">string</span> b = <span class="string">""</span> ; </span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span> ; j &lt; len ; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( a[j] != a[len<span class="number">-1</span>-j] ) </span><br><span class="line">                flag = <span class="number">1</span> ; </span><br><span class="line">            <span class="keyword">int</span> tmp = a[j] + a[len<span class="number">-1</span>-j] - <span class="number">2</span>*<span class="string">'0'</span> ; </span><br><span class="line">            b += ((tmp + last )% <span class="number">10</span> + <span class="string">'0'</span>) ;  </span><br><span class="line">            last = (tmp + last ) / <span class="number">10</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( flag == <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" is a palindromic number."</span> &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( last != <span class="number">0</span> )  </span><br><span class="line">            b += (last + <span class="string">'0'</span>) ; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" + "</span> ; </span><br><span class="line">        reverse(a.begin(),a.end()) ; </span><br><span class="line">        reverse(b.begin(),b.end()) ; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">        a = b ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found in 10 iterations."</span> &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1080、MOOC期终成绩"><a href="#1080、MOOC期终成绩" class="headerlink" title="1080、MOOC期终成绩"></a>1080、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805261493977088" target="_blank" rel="noopener">MOOC期终成绩</a></h4><p>对于在中国大学MOOC（<a href="http://www.icourse163.org/" target="_blank" rel="noopener">http://www.icourse163.org/</a> ）学习“数据结构”课程的学生，想要获得一张合格证书，必须首先获得不少于200分的在线编程作业分，然后总评获得不少于60分（满分100）。总评成绩的计算公式为 G=(Gmid−term×40%+Gfinal×60%)，如果 Gmid−term&gt;Gfinal；否则总评 G 就是 Gfinal。这里 Gmid−term 和 Gfinal 分别为学生的期中和期末成绩。</p><p>现在的问题是，每次考试都产生一张独立的成绩单。本题就请你编写程序，把不同的成绩单合为一张。</p><p><strong>输入描述</strong></p><p>输入在第一行给出3个整数，分别是 P（做了在线编程作业的学生数）、M（参加了期中考试的学生数）、N（参加了期末考试的学生数）。每个数都不超过10000。</p><p>接下来有三块输入。第一块包含 P 个在线编程成绩 Gp；第二块包含 M 个期中考试成绩 Gmid−term；第三块包含 N 个期末考试成绩 Gfinal。每个成绩占一行，格式为：<code>学生学号 分数</code>。其中<code>学生学号</code>为不超过20个字符的英文字母和数字；<code>分数</code>是非负整数（编程总分最高为900分，期中和期末的最高分为100分）。</p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">6</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line">&gt; <span class="number">01234</span> <span class="number">880</span></span><br><span class="line">&gt; a1903 <span class="number">199</span></span><br><span class="line">&gt; ydjh2 <span class="number">200</span></span><br><span class="line">&gt; wehu8 <span class="number">300</span></span><br><span class="line">&gt; dx86w <span class="number">220</span></span><br><span class="line">&gt; missing <span class="number">400</span></span><br><span class="line">&gt; ydhfu77 <span class="number">99</span></span><br><span class="line">&gt; wehu8 <span class="number">55</span></span><br><span class="line">&gt; ydjh2 <span class="number">98</span></span><br><span class="line">&gt; dx86w <span class="number">88</span></span><br><span class="line">&gt; a1903 <span class="number">86</span></span><br><span class="line">&gt; <span class="number">01234</span> <span class="number">39</span></span><br><span class="line">&gt; ydhfu77 <span class="number">88</span></span><br><span class="line">&gt; a1903 <span class="number">66</span></span><br><span class="line">&gt; <span class="number">01234</span> <span class="number">58</span></span><br><span class="line">&gt; wehu8 <span class="number">84</span></span><br><span class="line">&gt; ydjh2 <span class="number">82</span></span><br><span class="line">&gt; missing <span class="number">99</span></span><br><span class="line">&gt; dx86w <span class="number">81</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>打印出获得合格证书的学生名单。每个学生占一行，格式为：</p><p><code>学生学号</code> Gp Gmid−term Gfinal G</p><p>如果有的成绩不存在（例如某人没参加期中考试），则在相应的位置输出“−1”。输出顺序为按照总评分数（四舍五入精确到整数）递减。若有并列，则按学号递增。题目保证学号没有重复，且至少存在1个合格的学生。</p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; missing <span class="number">400</span> <span class="number">-1</span> <span class="number">99</span> <span class="number">99</span></span><br><span class="line">&gt; ydjh2 <span class="number">200</span> <span class="number">98</span> <span class="number">82</span> <span class="number">88</span></span><br><span class="line">&gt; dx86w <span class="number">220</span> <span class="number">88</span> <span class="number">81</span> <span class="number">84</span></span><br><span class="line">&gt; wehu8 <span class="number">300</span> <span class="number">55</span> <span class="number">84</span> <span class="number">84</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name ;</span><br><span class="line">    <span class="keyword">int</span> gb, gz, gm, g ; </span><br><span class="line">&#125; ; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(st a, st b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( a.g != b.g ) </span><br><span class="line">        <span class="keyword">return</span> a.g &gt; b.g ; </span><br><span class="line">    <span class="keyword">return</span> a.name &lt; b.name ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b, z, m, i ,j, tmp ; </span><br><span class="line">    <span class="built_in">string</span> n ; </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; help ; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; b &gt;&gt; z &gt;&gt; m ; </span><br><span class="line">    <span class="built_in">vector</span>&lt;st&gt; sts ; </span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; b ; i++ ) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; tmp ; </span><br><span class="line">        <span class="keyword">if</span> ( tmp &lt; <span class="number">200</span> || tmp &gt; <span class="number">900</span> ) </span><br><span class="line">            <span class="keyword">continue</span> ; </span><br><span class="line">        st one ; </span><br><span class="line">        one.name = n ; </span><br><span class="line">        one.gb = tmp ; </span><br><span class="line">        one.gz = one.gm = <span class="number">-1</span> ; </span><br><span class="line">        sts.push_back(one) ; </span><br><span class="line">        help[n] = sts.size()<span class="number">-1</span> ; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; z ; i++ ) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; tmp ; </span><br><span class="line">        <span class="keyword">if</span> ( help.count(n) == <span class="number">0</span> ) </span><br><span class="line">            <span class="keyword">continue</span> ; </span><br><span class="line">        <span class="keyword">int</span> index = help[n] ; </span><br><span class="line">        sts[index].gz = tmp ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; m ; i++ ) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; tmp ; </span><br><span class="line">        <span class="keyword">if</span> ( help.count(n) == <span class="number">0</span> ) </span><br><span class="line">            <span class="keyword">continue</span> ; </span><br><span class="line">        <span class="keyword">int</span> index = help[n] ; </span><br><span class="line">        sts[index].gm = tmp ; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> len = sts.size() ; </span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; len ; i++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( sts[i].gm &gt;= sts[i].gz ) </span><br><span class="line">            sts[i].g = sts[i].gm ; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">float</span> k = sts[i].gz * <span class="number">0.4</span> + sts[i].gm * <span class="number">0.6</span> + <span class="number">0.5</span> ; </span><br><span class="line">            sts[i].g = (<span class="keyword">int</span>)k ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    sort(sts.begin(),sts.end(),cmp) ; </span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span> ; sts[i].g &gt;= <span class="number">60</span> ; i++ ) </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sts[i].name &lt;&lt; <span class="string">" "</span> &lt;&lt; sts[i].gb &lt;&lt; <span class="string">" "</span> &lt;&lt; sts[i].gz &lt;&lt; <span class="string">" "</span> &lt;&lt; sts[i].gm &lt;&lt; <span class="string">" "</span> &lt;&lt; sts[i].g &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1081、检查密码"><a href="#1081、检查密码" class="headerlink" title="1081、检查密码"></a>1081、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805261217153024" target="_blank" rel="noopener">检查密码</a></h4><p>本题要求你帮助某网站的用户注册模块写一个密码合法性检查的小功能。该网站要求用户设置的密码必须由不少于6个字符组成，并且只能有英文字母、数字和小数点 <code>.</code>，还必须既有字母也有数字。 </p><p><strong>输入描述</strong></p><p>输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行给出一个用户设置的密码，为不超过 80 个字符的非空字符串，以回车结束。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 123s</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zheshi.wodepw</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 1234.5678</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> WanMei23333</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> pass*word.6</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>对每个用户的密码，在一行中输出系统反馈信息，分以下5种：</p><ul><li>如果密码合法，输出<code>Your password is wan mei.</code>；</li><li>如果密码太短，不论合法与否，都输出<code>Your password is tai duan le.</code>；</li><li>如果密码长度合法，但存在不合法字符，则输出<code>Your password is tai luan le.</code>；</li><li>如果密码长度合法，但只有字母没有数字，则输出<code>Your password needs shu zi.</code>；</li><li>如果密码长度合法，但只有数字没有字母，则输出<code>Your password needs zi mu.</code>。</li></ul><blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; Your password is tai duan le.</span><br><span class="line">&gt; Your password needs shu zi.</span><br><span class="line">&gt; Your password needs zi mu.</span><br><span class="line">&gt; Your password is<span class="built_in"> wan </span>mei.</span><br><span class="line">&gt; Your password is tai luan le.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d\n"</span>,&amp;n);</span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">80</span>];</span><br><span class="line"><span class="keyword">int</span> xx = <span class="number">0</span>;</span><br><span class="line">gets(str);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(str) &lt; <span class="number">6</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"Your password is tai duan le.\n"</span>);</span><br><span class="line">xx = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag_zimu = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag_shuzi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] &gt;= <span class="string">'0'</span> &amp;&amp; str[i] &lt;= <span class="string">'9'</span>) flag_shuzi = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((str[i] &gt;= <span class="string">'a'</span> &amp;&amp; str[i] &lt;= <span class="string">'z'</span>) || (str[i] &gt;= <span class="string">'A'</span> &amp;&amp; str[i] &lt;= <span class="string">'Z'</span>)) flag_zimu = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">'.'</span>);</span><br><span class="line"><span class="keyword">else</span> flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) <span class="built_in">printf</span> (<span class="string">"Your password is tai luan le.\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!flag_zimu) <span class="built_in">printf</span> (<span class="string">"Your password needs zi mu.\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!flag_shuzi) <span class="built_in">printf</span> (<span class="string">"Your password needs shu zi.\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Your password is wan mei.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if (!xx&amp;&amp;!flag&amp;&amp;flag_zimu&amp;&amp;flag_shuzi) printf("Your password is wan mei.\n");</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1082、射击比赛"><a href="#1082、射击比赛" class="headerlink" title="1082、射击比赛"></a>1082、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805260990660608" target="_blank" rel="noopener">射击比赛</a></h4><p>本题目给出的射击比赛的规则非常简单，谁打的弹洞距离靶心最近，谁就是冠军；谁差得最远，谁就是菜鸟。本题给出一系列弹洞的平面坐标(x,y)，请你编写程序找出冠军和菜鸟。我们假设靶心在原点(0,0)。 </p><p><strong>输入描述</strong></p><p>输入在第一行中给出一个正整数 N（≤ 10 000）。随后 N 行，每行按下列格式给出：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ID x y</span></span><br></pre></td></tr></table></figure><p>其中 <code>ID</code> 是运动员的编号（由 4 位数字组成）；<code>x</code> 和 <code>y</code> 是其打出的弹洞的平面坐标(<code>x</code>,<code>y</code>)，均为整数，且 0 ≤ |<code>x</code>|, |<code>y</code>| ≤ 100。题目保证每个运动员的编号不重复，且每人只打 1 枪。</p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">3</span></span><br><span class="line">&gt; <span class="number">0001</span> <span class="number">5</span> <span class="number">7</span></span><br><span class="line">&gt; <span class="number">1020</span> <span class="number">-1</span> <span class="number">3</span></span><br><span class="line">&gt; <span class="number">0233</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>输出冠军和菜鸟的编号，中间空 1 格。题目保证他们是唯一的。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">0233</span> <span class="number">0001</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> id,x,y;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> max_id;</span><br><span class="line"><span class="keyword">int</span> min = <span class="number">999999</span>;</span><br><span class="line"><span class="keyword">int</span> min_id;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">while</span>(n--) &#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d %d %d"</span>,&amp;id,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">int</span> temp = x * x + y * y;</span><br><span class="line"><span class="keyword">if</span> (temp &gt; max) &#123;max_id = id;max = temp;&#125;;</span><br><span class="line"><span class="keyword">if</span> (temp &lt; min) &#123;min_id = id;min = temp;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%04d %04d"</span>,min_id,max_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1083、是否存在相等的差"><a href="#1083、是否存在相等的差" class="headerlink" title="1083、是否存在相等的差"></a>1083、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805260780945408" target="_blank" rel="noopener">是否存在相等的差</a></h4><p>给定 N 张卡片，正面分别写上 1、2、……、N，然后全部翻面，洗牌，在背面分别写上 1、2、……、N。将每张牌的正反两面数字相减（大减小），得到 N 个非负差值，其中是否存在相等的差？ </p><p><strong>输入描述</strong></p><p>输入第一行给出一个正整数 N（2 ≤ N ≤ 10 000），随后一行给出 1 到 N 的一个洗牌后的排列，第 i 个数表示正面写了 i 的那张卡片背面的数字。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">8</span></span><br><span class="line">&gt; <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">6</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>按照“差值 重复次数”的格式从大到小输出重复的差值及其重复的次数，每行输出一个结果。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">5</span> <span class="number">2</span></span><br><span class="line">&gt; <span class="number">3</span> <span class="number">3</span></span><br><span class="line">&gt; <span class="number">2</span> <span class="number">2</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> maxn = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">10000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">temp = (num &gt; i ? num-i:i-num);</span><br><span class="line">maxn = (temp &gt; maxn ? temp : maxn);</span><br><span class="line">ans[temp]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = maxn; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (ans[i] &gt;= <span class="number">2</span>) <span class="built_in">printf</span> (<span class="string">"%d %d\n"</span>,i,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1084、外观数列"><a href="#1084、外观数列" class="headerlink" title="1084、外观数列"></a>1084、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805260583813120" target="_blank" rel="noopener">外观数列</a></h4><p>外观数列是指具有以下特点的整数序列：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">d</span></span>, d1, d111, d113, d11231, d112213111, ...</span><br></pre></td></tr></table></figure><p>它从不等于 1 的数字 <code>d</code> 开始，序列的第 n+1 项是对第 n 项的描述。比如第 2 项表示第 1 项有 1 个 <code>d</code>，所以就是 <code>d1</code>；第 2 项是 1 个 <code>d</code>（对应 <code>d1</code>）和 1 个 1（对应 11），所以第 3 项就是 <code>d111</code>。又比如第 4 项是 <code>d113</code>，其描述就是 1 个 <code>d</code>，2 个 1，1 个 3，所以下一项就是 <code>d11231</code>。当然这个定义对 <code>d</code> = 1 也成立。本题要求你推算任意给定数字 <code>d</code> 的外观数列的第 N 项。</p><p><strong>输入描述</strong></p><p>输入第一行给出 [0,9] 范围内的一个整数 <code>d</code>、以及一个正整数 N（≤ 40），用空格分隔。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span> <span class="number">8</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中给出数字 <code>d</code> 的外观数列的第 N 项。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 1123123111</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">string</span> a;  </span><br><span class="line">    <span class="keyword">int</span> n;  </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; n;  </span><br><span class="line">    <span class="keyword">while</span>(--n)&#123;  </span><br><span class="line">        <span class="built_in">string</span> ans;  </span><br><span class="line">        <span class="keyword">char</span> c = a[<span class="number">0</span>];  </span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; a.length();i++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(a[i] == c)   cnt++;  </span><br><span class="line">            <span class="keyword">else</span>&#123;  </span><br><span class="line">                ans+=c;  </span><br><span class="line">                ans+=cnt+<span class="string">'0'</span>;  </span><br><span class="line">                c = a[i];  </span><br><span class="line">                cnt = <span class="number">1</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>)&#123;  </span><br><span class="line">            ans+=c;  </span><br><span class="line">            ans+=cnt+<span class="string">'0'</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        a = ans;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1085、PAT单位排行"><a href="#1085、PAT单位排行" class="headerlink" title="1085、PAT单位排行"></a>1085、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805260353126400" target="_blank" rel="noopener">PAT单位排行</a></h4><p><strong>输入描述</strong></p><p>输入第一行给出一个正整数 N（≤105），即考生人数。随后 N 行，每行按下列格式给出一个考生的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">准考证号 得分 学校</span><br></pre></td></tr></table></figure><p>其中<code>准考证号</code>是由 6 个字符组成的字符串，其首字母表示考试的级别：<code>B</code>代表乙级，<code>A</code>代表甲级，<code>T</code>代表顶级；<code>得分</code>是 [0, 100] 区间内的整数；<code>学校</code>是由不超过 6 个英文字母组成的单位码（大小写无关）。注意：题目保证每个考生的准考证号是不同的。</p><blockquote><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">10</span></span><br><span class="line">&gt; <span class="keyword">A</span><span class="number">57908 85</span> Au</span><br><span class="line">&gt; B<span class="number">57908 54</span> LanX</span><br><span class="line">&gt; <span class="keyword">A</span><span class="number">37487 60</span> au</span><br><span class="line">&gt; T<span class="number">28374 67</span> CMU</span><br><span class="line">&gt; T<span class="number">32486 24</span> hypu</span><br><span class="line">&gt; <span class="keyword">A</span><span class="number">66734 92</span> cmu</span><br><span class="line">&gt; B<span class="number">76378 71</span> AU</span><br><span class="line">&gt; <span class="keyword">A</span><span class="number">47780 45</span> lanx</span><br><span class="line">&gt; <span class="keyword">A</span><span class="number">72809 100</span> pku</span><br><span class="line">&gt; <span class="keyword">A</span><span class="number">03274 45</span> hypu</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>首先在一行中输出单位个数。随后按以下格式非降序输出单位的排行榜：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">排名 学校 加权总分 考生人数</span><br></pre></td></tr></table></figure><p>其中<code>排名</code>是该单位的排名（从 1 开始）；<code>学校</code>是全部按小写字母输出的单位码；<code>加权总分</code>定义为<code>乙级总分/1.5 + 甲级总分 + 顶级总分*1.5</code>的<strong>整数部分</strong>；<code>考生人数</code>是该属于单位的考生的总人数。</p><p>学校首先按加权总分排行。如有并列，则应对应相同的排名，并按考生人数升序输出。如果仍然并列，则按单位码的字典序输出。</p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">5</span></span><br><span class="line">&gt; <span class="number">1</span> cmu <span class="number">192</span> <span class="number">2</span></span><br><span class="line">&gt; <span class="number">1</span> au <span class="number">192</span> <span class="number">3</span></span><br><span class="line">&gt; <span class="number">3</span> pku <span class="number">100</span> <span class="number">1</span></span><br><span class="line">&gt; <span class="number">4</span> hypu <span class="number">81</span> <span class="number">2</span></span><br><span class="line">&gt; <span class="number">4</span> lanx <span class="number">81</span> <span class="number">2</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(<span class="keyword">int</span> n)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> n)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a,<span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a,<span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span>;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">char</span> school[<span class="number">10</span>];  </span><br><span class="line">    <span class="keyword">double</span> score;  </span><br><span class="line">    <span class="keyword">int</span> stu;  </span><br><span class="line">&#125;student[<span class="number">100000</span>];  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n,a;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%*c"</span>,&amp;n);  </span><br><span class="line">    input(n);  </span><br><span class="line">    qsort(&amp;student[<span class="number">0</span>],n,<span class="keyword">sizeof</span>(struct student),cmp);  </span><br><span class="line">    a=add(n);  </span><br><span class="line">    qsort(&amp;student[<span class="number">0</span>],n,<span class="keyword">sizeof</span>(struct student),cmp1);  </span><br><span class="line">    output(a);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(<span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i,j,score;  </span><br><span class="line">    <span class="keyword">char</span> c;  </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c%*c%*c%*c%*c%*c%*c%d%*c"</span>,&amp;c,&amp;score);  </span><br><span class="line">        <span class="keyword">if</span> (c==<span class="string">'B'</span>) student[i].score=score/<span class="number">1.5</span>;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">'T'</span>) student[i].score=score*<span class="number">1.5</span>;  </span><br><span class="line">        <span class="keyword">else</span> student[i].score=score*<span class="number">1.0</span>;  </span><br><span class="line">        j=<span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">do</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;student[i].school[j]);  </span><br><span class="line">            <span class="keyword">if</span> (student[i].school[j]&gt;=<span class="string">'A'</span> &amp;&amp; student[i].school[j]&lt;=<span class="string">'Z'</span>) student[i].school[j]=student[i].school[j]-<span class="string">'A'</span>+<span class="string">'a'</span>;  </span><br><span class="line">        &#125;<span class="keyword">while</span>(student[i].school[j++]!=<span class="string">'\n'</span>);  </span><br><span class="line">        student[i].school[--j]=<span class="string">'\0'</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i,j,a;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n);  </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        j=i;a=(<span class="keyword">int</span>)student[i].score;  </span><br><span class="line">        <span class="keyword">while</span>(j&lt;n &amp;&amp; (<span class="keyword">int</span>)student[j].score==a)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %s %d %d\n"</span>,i+<span class="number">1</span>,student[j].school,(<span class="keyword">int</span>)student[j].score,student[j].stu);  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        i=j<span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i,j,s=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        j=i+<span class="number">1</span>;student[i].stu=<span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">strcmp</span>(student[i].school,student[j].school)==<span class="number">0</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            student[i].score+=student[j].score;  </span><br><span class="line">            student[j].score=<span class="number">-1</span>;s++;                <span class="comment">//防止出现某人分数比别的整个学校总分还高的情况  </span></span><br><span class="line">            student[i].stu++;j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        student[i].score=(<span class="keyword">int</span>)student[i].score;  </span><br><span class="line">        i=j<span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> n-s;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a,<span class="keyword">const</span> <span class="keyword">void</span> *b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">aa</span>=(<span class="title">struct</span> <span class="title">student</span> *)<span class="title">a</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">bb</span>=(<span class="title">struct</span> <span class="title">student</span> *)<span class="title">b</span>;</span>  </span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">strcmp</span>(aa-&gt;school,bb-&gt;school));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a,<span class="keyword">const</span> <span class="keyword">void</span> *b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">aa</span>=(<span class="title">struct</span> <span class="title">student</span> *)<span class="title">a</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">bb</span>=(<span class="title">struct</span> <span class="title">student</span> *)<span class="title">b</span>;</span>  </span><br><span class="line">    <span class="keyword">if</span> (aa-&gt;score != bb-&gt;score)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> (aa-&gt;score &lt; bb-&gt;score ? <span class="number">1</span>:<span class="number">-1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (aa-&gt;stu != bb-&gt;stu )  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">return</span> (aa-&gt;stu &gt; bb-&gt;stu ? <span class="number">1</span>:<span class="number">-1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">strcmp</span>(aa-&gt;school,bb-&gt;school));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1086、就不告诉你"><a href="#1086、就不告诉你" class="headerlink" title="1086、就不告诉你"></a>1086、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/1038429065476579328" target="_blank" rel="noopener">就不告诉你</a></h4><p>做作业的时候，邻座的小盆友问你：“五乘以七等于多少？”你应该不失礼貌地围笑着告诉他：“五十三。”本题就要求你，对任何一对给定的正整数，倒着输出它们的乘积。 </p><p><strong>输入描述</strong></p><p>输入在第一行给出两个不超过 1000 的正整数 A 和 B，其间以空格分隔。 </p><blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">5</span> <span class="number">7</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中倒着输出 A 和 B 的乘积。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 53</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans = a*b;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (ans != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ans % <span class="number">10</span> != <span class="number">0</span> || flag )&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans % <span class="number">10</span>;</span><br><span class="line">flag++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans = (<span class="keyword">int</span>)ans / <span class="number">10</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1087、有多少不同的值"><a href="#1087、有多少不同的值" class="headerlink" title="1087、有多少不同的值"></a>1087、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/1038429191091781632" target="_blank" rel="noopener">有多少不同的值</a></h4><p>当自然数 n 依次取 1、2、3、……、N 时，算式 ⌊n/2⌋+⌊n/3⌋+⌊n/5⌋ 有多少个不同的值？（注：⌊x⌋ 为取整函数，表示不超过 x 的最大自然数，即 x 的整数部分。） </p><p><strong>输入描述</strong></p><p>输入给出一个正整数 N（2≤N≤10^4^）。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 2017</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p><strong>输出描述</strong></p><p>在一行中输出题面中算式取到的不同值的个数。 </p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 1480</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10005</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">5</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[n];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">6</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> ((i%<span class="number">2</span> == <span class="number">0</span>)||(i%<span class="number">3</span> == <span class="number">0</span>)|| (i%<span class="number">5</span> == <span class="number">0</span>))</span><br><span class="line">arr[i] = arr[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">arr[i] = arr[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1088、三人行"><a href="#1088、三人行" class="headerlink" title="1088、三人行"></a>1088、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/1038429286185074688" target="_blank" rel="noopener">三人行</a></h4><p>子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。”</p><p>本题给定甲、乙、丙三个人的能力值关系为：甲的能力值确定是 2 位正整数；把甲的能力值的 2 个数字调换位置就是乙的能力值；甲乙两人能力差是丙的能力值的 X 倍；乙的能力值是丙的 Y 倍。请你指出谁比你强应“从之”，谁比你弱应“改之”。</p><p><strong>输入描述</strong></p><p>输入在一行中给出三个数，依次为：M（你自己的能力值）、X 和 Y。三个数字均为不超过 1000 的正整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">48 3 7</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong></p><p>在一行中首先输出甲的能力值，随后依次输出甲、乙、丙三人与你的关系：如果其比你强，输出 <code>Cong</code>；平等则输出 <code>Ping</code>；比你弱则输出 <code>Gai</code>。其间以 1 个空格分隔，行首尾不得有多余空格。</p><p>注意：如果解不唯一，则以甲的最大解为准进行判断；如果解不存在，则输出 <code>No Solution</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">48 Ping Cong Gai</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">//键盘扫描类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">com</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="string">"Cong"</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="string">"Gai"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"Ping"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">solution</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"No Solution"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">99</span>; i &gt;= <span class="number">10</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = (i%<span class="number">10</span>)*<span class="number">10</span> + i/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">double</span> k = (<span class="keyword">double</span>)Math.abs(i - j) / x;</span><br><span class="line">            <span class="keyword">if</span> ( k == j * <span class="number">1.0</span>/ y) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="string">" "</span> + com(i,m) + <span class="string">" "</span> + com(j,m) + <span class="string">" "</span> + com(k,m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"No Solution"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> m = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> x = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> y = input.nextInt();</span><br><span class="line">        System.out.println(Main.solution(m,x,y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1089、狼人杀-简单版"><a href="#1089、狼人杀-简单版" class="headerlink" title="1089、狼人杀-简单版"></a>1089、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/1038429385296453632" target="_blank" rel="noopener">狼人杀-简单版</a></h4><p>以下文字摘自《灵机一动·好玩的数学》：“狼人杀”游戏分为狼人、好人两大阵营。在一局“狼人杀”游戏中，1 号玩家说：“2 号是狼人”，2 号玩家说：“3 号是好人”，3 号玩家说：“4 号是狼人”，4 号玩家说：“5 号是好人”，5 号玩家说：“4 号是好人”。已知这 5 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。扮演狼人角色的是哪两号玩家？</p><p>本题是这个问题的升级版：已知 <em>N</em> 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。要求你找出扮演狼人角色的是哪几号玩家？</p><p><strong>输入描述</strong></p><p>输入在第一行中给出一个正整数 <em>N</em>（5≤<em>N</em>≤100）。随后 <em>N</em> 行，第 <em>i</em> 行给出第 <em>i</em> 号玩家说的话（1≤<em>i</em>≤<em>N</em>），即一个玩家编号，用正号表示好人，负号表示狼人。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">-2</span><br><span class="line">+3</span><br><span class="line">-4</span><br><span class="line">+5</span><br><span class="line">+4</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong></p><p>如果有解，在一行中按递增顺序输出 2 个狼人的编号，其间以空格分隔，行首尾不得有多余空格。如果解不唯一，则输出最小序列解 —— 即对于两个序列 <em>A</em>=<em>a</em>[1],…,<em>a</em>[<em>M</em>] 和 <em>B</em>=<em>b</em>[1],…,<em>b</em>[<em>M</em>]，若存在 0≤<em>k</em>&lt;<em>M</em> 使得 <em>a</em>[<em>i</em>]=<em>b</em>[<em>i</em>] （<em>i</em>≤<em>k</em>），且 <em>a</em>[<em>k</em>+1]&lt;<em>b</em>[<em>k</em>+1]，则称序列 <em>A</em> 小于序列 <em>B</em>。若无解则输出 <code>No Solution</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 4</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">//键盘扫描类</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] talk = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            talk[i] = input.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">                ArrayList&lt;Integer&gt; lie = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                Arrays.fill(arr,<span class="number">1</span>);</span><br><span class="line">                arr[i] = arr[j] = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (talk[k] * arr[Math.abs(talk[k])] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        lie.add(k);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (lie.size() == <span class="number">2</span> &amp;&amp; ((arr[lie.get(<span class="number">0</span>)] + arr[lie.get(<span class="number">1</span>)]) == <span class="number">0</span>)) &#123;</span><br><span class="line">                    System.out.println(i + <span class="string">" "</span> + j);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"No Solution"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main.solution();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1090、危险品装箱"><a href="#1090、危险品装箱" class="headerlink" title="1090、危险品装箱"></a>1090、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/1038429484026175488" target="_blank" rel="noopener">危险品装箱</a></h4><p>集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。</p><p>本题给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。</p><p><strong>输入描述</strong></p><p>输入第一行给出两个正整数：<em>N</em> (≤104) 是成对的不相容物品的对数；<em>M</em> (≤100) 是集装箱货品清单的单数。</p><p>随后数据分两大块给出。第一块有 <em>N</em> 行，每行给出一对不相容的物品。第二块有 <em>M</em> 行，每行给出一箱货物的清单，格式如下：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">K G<span class="string">[1]</span> G<span class="string">[2]</span> ... G<span class="string">[K]</span></span><br></pre></td></tr></table></figure><p>其中 <code>K</code> (≤1000) 是物品件数，<code>G[i]</code> 是物品的编号。简单起见，每件物品用一个 5 位数的编号代表。两个数字之间用空格分隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">6 3</span><br><span class="line">20001 20002</span><br><span class="line">20003 20004</span><br><span class="line">20005 20006</span><br><span class="line">20003 20001</span><br><span class="line">20005 20004</span><br><span class="line">20004 20006</span><br><span class="line">4 00001 20004 00002 20003</span><br><span class="line">5 98823 20002 20003 20006 10010</span><br><span class="line">3 12345 67890 23333</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong></p><p>对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 <code>Yes</code>，否则输出 <code>No</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><p>这题目前用java写的一般都超时了，好像只适合用c++来写，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, t1, t2;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;t1, &amp;t2);</span><br><span class="line">        m[t1].push_back(t2);</span><br><span class="line">        m[t2].push_back(t1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt, flag = <span class="number">0</span>, a[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;cnt);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(cnt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[i]);</span><br><span class="line">            a[v[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m[v[i]].size(); j++)</span><br><span class="line">                <span class="keyword">if</span> (a[m[v[i]][j]] == <span class="number">1</span>) flag = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,flag ? <span class="string">"No"</span> :<span class="string">"Yes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1091、N-自守数"><a href="#1091、N-自守数" class="headerlink" title="1091、N-自守数"></a>1091、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/1071785664454127616" target="_blank" rel="noopener">N-自守数</a></h4><p>如果某个数 <em>K</em> 的平方乘以 <em>N</em> 以后，结果的末尾几位数等于 <em>K</em>，那么就称这个数为“<em>N</em>-自守数”。例如 3×92^2^=25392，而 25392 的末尾两位正好是 92，所以 92 是一个 3-自守数。</p><p>本题就请你编写程序判断一个给定的数字是否关于某个 <em>N</em> 是 <em>N</em>-自守数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出正整数 <em>M</em>（≤20），随后一行给出 <em>M</em> 个待检测的、不超过 1000 的正整数。</p><p><strong>输出格式</strong>：</p><p>对每个需要检测的数字，如果它是 <em>N</em>-自守数就在一行中输出最小的 <em>N</em> 和 <em>N**K</em>2 的值，以一个空格隔开；否则输出 <code>No</code>。注意题目保证 <em>N</em>&lt;10。</p><p><strong>输入样例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">92 5 233</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 25392</span><br><span class="line">1 25</span><br><span class="line">No</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"cstdio"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"algorithm"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">weishu</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> n / temp != <span class="number">0</span> ? temp*<span class="number">10</span> : weishu(n, (<span class="keyword">int</span>)temp/<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="keyword">int</span> num,i;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans = num*num;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; ans*i &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span>((ans*i)%weishu(num,<span class="number">100</span>) == num) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %lld\n"</span>,i,ans*i);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">10</span>) <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1092、最好吃的月饼"><a href="#1092、最好吃的月饼" class="headerlink" title="1092、最好吃的月饼"></a>1092、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/1071785779399028736" target="_blank" rel="noopener">最好吃的月饼</a></h4><p>月饼是久负盛名的中国传统糕点之一，自唐朝以来，已经发展出几百品种。若想评比出一种“最好吃”的月饼，那势必在吃货界引发一场腥风血雨…… 在这里我们用数字说话，给出全国各地各种月饼的销量，要求你从中找出销量冠军，认定为最好吃的月饼。</p><p><strong>输入格式</strong></p><p>输入首先给出两个正整数 <em>N</em>（≤1000）和 <em>M</em>（≤100），分别为月饼的种类数（于是默认月饼种类从 1 到 <em>N</em> 编号）和参与统计的城市数量。</p><p>接下来 <em>M</em> 行，每行给出 <em>N</em> 个非负整数（均不超过 1 百万），其中第 <em>i</em> 个整数为第 <em>i</em> 种月饼的销量（块）。数字间以空格分隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">1001 992 0 233 6</span><br><span class="line">8 0 2018 0 2008</span><br><span class="line">36 18 0 1024 4</span><br></pre></td></tr></table></figure><p><strong>输出格式</strong></p><p>在第一行中输出最大销量，第二行输出销量最大的月饼的种类编号。如果冠军不唯一，则按编号递增顺序输出并列冠军。数字间以 1 个空格分隔，行首尾不得有多余空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cstdio"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"algorithm"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> arr[<span class="number">10000</span>] =  &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> maxnum = <span class="number">-999999</span>;</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">arr[i] += temp;</span><br><span class="line">maxnum = maxnum &gt; arr[i] ? maxnum : arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,maxnum);</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (maxnum == arr[i]) &#123;</span><br><span class="line">!flag++ ? <span class="built_in">printf</span>(<span class="string">""</span>) : <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1093、字符串A-B"><a href="#1093、字符串A-B" class="headerlink" title="1093、字符串A+B"></a>1093、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/1071785884776722432" target="_blank" rel="noopener">字符串A+B</a></h4><p>给定两个字符串 <em>A</em> 和 <em>B</em>，本题要求你输出 <em>A</em>+<em>B</em>，即两个字符串的并集。要求先输出 <em>A</em>，再输出 <em>B</em>，但<strong>重复的字符必须被剔除</strong>。</p><p><strong>输入格式</strong></p><p>输入在两行中分别给出 <em>A</em> 和 <em>B</em>，均为长度不超过 106的、由可见 ASCII 字符 (即码值为32~126)和空格组成的、由回车标识结束的非空字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is a sample test</span><br><span class="line">to show you_How it works</span><br></pre></td></tr></table></figure><p><strong>输出格式</strong></p><p>在一行中输出题面要求的 <em>A</em> 和 <em>B</em> 的和。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This ampletowyu_Hrk</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">127</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> chr;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">while</span>(( chr = getchar()) != <span class="string">'\n'</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(arr[chr]++ == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;chr;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="1094、谷歌的招聘"><a href="#1094、谷歌的招聘" class="headerlink" title="1094、谷歌的招聘"></a>1094、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/1071785997033074688" target="_blank" rel="noopener">谷歌的招聘</a></h4><p>2004 年 7 月，谷歌在硅谷的 101 号公路边竖立了一块巨大的广告牌（如下图）用于招聘。内容超级简单，就是一个以 .com 结尾的网址，而前面的网址是一个 10 位素数，这个素数是自然常数 e 中最早出现的 10 位连续数字。能找出这个素数的人，就可以通过访问谷歌的这个网站进入招聘流程的下一步。自然常数 e 是一个著名的超越数，前面若干位写出来是这样的：e = 2.71828182845904523536028747135266249775724709369995957496696762772407663035354759457138217852516642<strong>7427466391</strong>932003059921… 其中粗体标出的 10 位数就是答案。</p><p>本题要求你编程解决一个更通用的问题：从任一给定的长度为 L 的数字中，找出最早出现的 K 位连续数字所组成的素数。</p><p><strong>输入格式</strong></p><p>输入在第一行给出 2 个正整数，分别是 L（不超过 1000 的正整数，为数字长度）和 K（小于 10 的正整数）。接下来一行给出一个长度为 L 的正整数 N。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">20 5</span><br><span class="line">23654987725541023819</span><br></pre></td></tr></table></figure><p><strong>输出格式</strong></p><p>在一行中输出 N 中最早出现的 K 位连续数字所组成的素数。如果这样的素数不存在，则输出 <code>404</code>。注意，原始数字中的前导零也计算在位数之内。例如在 200236 中找 4 位素数，0023 算是解；但第一位 2 不能被当成 0002 输出，因为在原始数字中不存在这个 2 的前导零。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">49877</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isprimer</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">string</span> s,s2;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=a-b;i++)&#123;</span><br><span class="line">s2=s.substr(i,b);</span><br><span class="line">n=stoi(s2);</span><br><span class="line"><span class="keyword">if</span>(isprimer(n))&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"404"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1095、解码PAT准考证"><a href="#1095、解码PAT准考证" class="headerlink" title="1095、解码PAT准考证"></a>1095、<a href="https://pintia.cn/problem-sets/994805260223102976/problems/1071786104348536832" target="_blank" rel="noopener">解码PAT准考证</a></h4><p>PAT 准考证号由 4 部分组成：</p><ul><li>第 1 位是级别，即 <code>T</code> 代表顶级；<code>A</code> 代表甲级；<code>B</code> 代表乙级；</li><li>第 2~4 位是考场编号，范围从 101 到 999；</li><li>第 5~10 位是考试日期，格式为年、月、日顺次各占 2 位；</li><li>最后 11~13 位是考生编号，范围从 000 到 999。</li></ul><p>现给定一系列考生的准考证号和他们的成绩，请你按照要求输出各种统计信息。</p><p><strong>输入格式</strong></p><p>输入首先在一行中给出两个正整数 <em>N</em>（≤104）和 <em>M</em>（≤100），分别为考生人数和统计要求的个数。</p><p>接下来 <em>N</em> 行，每行给出一个考生的准考证号和其分数（在区间 [0,100] 内的整数），其间以空格分隔。</p><p>考生信息之后，再给出 <em>M</em> 行，每行给出一个统计要求，格式为：<code>类型 指令</code>，其中</p><ul><li><code>类型</code> 为 1 表示要求按分数非升序输出某个指定级别的考生的成绩，对应的 <code>指令</code> 则给出代表指定级别的字母；</li><li><code>类型</code> 为 2 表示要求将某指定考场的考生人数和总分统计输出，对应的 <code>指令</code> 则给出指定考场的编号；</li><li><code>类型</code> 为 3 表示要求将某指定日期的考生人数分考场统计输出，对应的 <code>指令</code> 则给出指定日期，格式与准考证上日期相同。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">8 4</span><br><span class="line">B123180908127 99</span><br><span class="line">B102180908003 86</span><br><span class="line">A112180318002 98</span><br><span class="line">T107150310127 62</span><br><span class="line">A107180908108 100</span><br><span class="line">T123180908010 78</span><br><span class="line">B112160918035 88</span><br><span class="line">A107180908021 98</span><br><span class="line">1 A</span><br><span class="line">2 107</span><br><span class="line">3 180908</span><br><span class="line">2 999</span><br></pre></td></tr></table></figure><p><strong>输出格式</strong></p><p>对每项统计要求，首先在一行中输出 <code>Case #: 要求</code>，其中 <code>#</code> 是该项要求的编号，从 1 开始；<code>要求</code> 即复制输入给出的要求。随后输出相应的统计结果：</p><ul><li><code>类型</code> 为 1 的指令，输出格式与输入的考生信息格式相同，即 <code>准考证号 成绩</code>。对于分数并列的考生，按其准考证号的字典序递增输出（题目保证无重复准考证号）；</li><li><code>类型</code> 为 2 的指令，按 <code>人数 总分</code> 的格式输出；</li><li><code>类型</code> 为 3 的指令，输出按人数非递增顺序，格式为 <code>考场编号 总人数</code>。若人数并列则按考场编号递增顺序输出。</li></ul><p>如果查询结果为空，则输出 <code>NA</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 1 A</span><br><span class="line">A107180908108 100</span><br><span class="line">A107180908021 98</span><br><span class="line">A112180318002 98</span><br><span class="line">Case 2: 2 107</span><br><span class="line">3 260</span><br><span class="line">Case 3: 3 180908</span><br><span class="line">107 2</span><br><span class="line">123 2</span><br><span class="line">102 1</span><br><span class="line">Case 4: 2 999</span><br><span class="line">NA</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> t;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node &amp;a, <span class="keyword">const</span> node &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.value != b.value ? a.value &gt; b.value : a.t &lt; b.t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, num;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">vector</span>&lt;node&gt; v(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i].t &gt;&gt; v[i].value;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num &gt;&gt; s;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d %s\n"</span>, i, num, s.c_str());</span><br><span class="line">        <span class="built_in">vector</span>&lt;node&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (v[j].t[<span class="number">0</span>] == s[<span class="number">0</span>]) ans.push_back(v[j]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[j].t.substr(<span class="number">1</span>, <span class="number">3</span>) == s) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    sum += v[j].value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, cnt, sum);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (v[j].t.substr(<span class="number">4</span>, <span class="number">6</span>) == s) m[v[j].t.substr(<span class="number">1</span>, <span class="number">3</span>)]++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it : m) ans.push_back(&#123;it.first, it.second&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ans.begin(), ans.end(),cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ans.size(); j++) <span class="built_in">printf</span>(<span class="string">"%s %d\n"</span>, ans[j].t.c_str(), ans[j].value);</span><br><span class="line">        <span class="keyword">if</span> (((num == <span class="number">1</span> || num == <span class="number">3</span>) &amp;&amp; ans.size() == <span class="number">0</span>) || (num == <span class="number">2</span> &amp;&amp; cnt == <span class="number">0</span>)) <span class="built_in">printf</span>(<span class="string">"NA\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1001、害死人不偿命的-3n-1-猜想&quot;&gt;&lt;a href=&quot;#1001、害死人不偿命的-3n-1-猜想&quot; class=&quot;headerlink&quot; title=&quot;1001、害死人不偿命的(3n+1)猜想&quot;&gt;&lt;/a&gt;1001、&lt;a href=&quot;https://pintia.cn/problem-sets/994805260223102976/problems/994805325918486528&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;害死人不偿命的(3n+1)猜想&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;卡拉兹(Callatz)猜想：&lt;/p&gt;
&lt;p&gt;对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……&lt;/p&gt;
&lt;p&gt;我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1？&lt;/p&gt;
    
    </summary>
    
    
      <category term="PAT" scheme="http://yoursite.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>和为S的两个数字</title>
    <link href="http://yoursite.com/2020/12/07/%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/12/07/和为S的两个数字/</id>
    <published>2020-12-07T12:20:27.224Z</published>
    <updated>2020-12-07T12:43:36.067Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><p>一个递增排序的数组和一个数字S</p><blockquote><p>[1,2,4,7,11,15],15</p></blockquote><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><p>数字和等于S 的两个数，输出两个数，小的先输出。</p><blockquote><p>[4,11]</p></blockquote><a id="more"></a><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p><strong>方法一：双指针</strong></p><p>因为数组是有序的，所以可以用双指针，指向数组的首尾，具体步骤如下：</p><p>1，初始化：指针low指向数组首，指针high指向数组尾部。</p><p>2，如果arr[low] + arr[high] == sum，说明可能是解，判断是否乘积最小。</p><p>3，如果arr[low] + arr[high] &lt; sum，说明和太小，所以应该low++。</p><p>4，如果arr[low] + arr[high]  &gt; sum，说明和太大，所以应该high–。</p><p><strong>时间复杂度：</strong>O(n)</p><p><strong>空间复杂度：</strong>O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Solution;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">//键盘扫描类</span></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxFlag = <span class="number">9999999</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[low] + array[high] == sum) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[low] * array[high] &lt; maxFlag) &#123;</span><br><span class="line">                    arrayList.clear();</span><br><span class="line">                    arrayList.add(array[low]);</span><br><span class="line">                    arrayList.add(array[high]);</span><br><span class="line">                    maxFlag = array[low] * array[high];</span><br><span class="line">                &#125;</span><br><span class="line">                low++;</span><br><span class="line">                high--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[low] + array[high] &lt; sum) &#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n,k;</span><br><span class="line">        n = input.nextInt();</span><br><span class="line">        k = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> [] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; ++i) &#123;</span><br><span class="line">            arr[i] = input.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line"></span><br><span class="line">        System.out.print(solution.FindNumbersWithSum(arr,k));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。&lt;/p&gt;
&lt;h4 id=&quot;输入描述&quot;&gt;&lt;a href=&quot;#输入描述&quot; class=&quot;headerlink&quot; title=&quot;输入描述&quot;&gt;&lt;/a&gt;输入描述&lt;/h4&gt;&lt;p&gt;一个递增排序的数组和一个数字S&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[1,2,4,7,11,15],15&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;输出描述&quot;&gt;&lt;a href=&quot;#输出描述&quot; class=&quot;headerlink&quot; title=&quot;输出描述&quot;&gt;&lt;/a&gt;输出描述&lt;/h4&gt;&lt;p&gt;数字和等于S 的两个数，输出两个数，小的先输出。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[4,11]&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>数字在升序数组中出现的次数</title>
    <link href="http://yoursite.com/2020/12/05/%E6%95%B0%E5%AD%97%E5%9C%A8%E5%8D%87%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2020/12/05/数字在升序数组中出现的次数/</id>
    <published>2020-12-05T07:44:22.898Z</published>
    <updated>2020-12-05T08:05:51.213Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>统计一个数字在升序数组中出现的次数。</p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><p>一个升序数组，和一个待统计的数字</p><blockquote><p>[1,2,3,3,3,3,4,5] , 3</p></blockquote><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><p>数字的统计次数</p><blockquote><p>4</p></blockquote><a id="more"></a><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p><strong>方法一：暴力求解</strong></p><p>直接定义两个index，一个从数组的头往后遍历，寻找第一个K值的下标，即寻找k值的上界，一个从数组的最后往前遍历，寻找k值的下界，下界减上界即是k值的个数。</p><p><strong>时间复杂度：</strong>O(n)</p><p><strong>空间复杂度：</strong>O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( i &lt;= j ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] == array[j] &amp;&amp; array[i] == k) <span class="keyword">return</span> j-i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (array[i] != k ) i++;</span><br><span class="line">            <span class="keyword">if</span> (array[j] != k ) j--;</span><br><span class="line"><span class="comment">//            System.out.print(i + " " + j + "\n");</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：二分</strong></p><p>考虑到有序数组，可以通过二分查找的方式找出k的上界和下界。</p><p>下界定义为：如果存在目标值，则指向第一个目标数，如果不存在，则指向大于目标值的第一个值。</p><p>上界定义为：不管目标是否存在，都指向大于目标值的第一个值。</p><p><div align="center"><img src="/2020/12/05/数字在升序数组中出现的次数/1.png" alt></div></p><p><div align="center"><img src="/2020/12/05/数字在升序数组中出现的次数/2.png" alt></div></p><p>最后的答案就是<code>right - left</code></p><p><strong>时间复杂度：</strong>O(logN)</p><p><strong>空间复杂度：</strong>O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] &gt;= k) right = mid;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lbound = right;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = array.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] &lt;= k) left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ubound = left;</span><br><span class="line">        <span class="keyword">return</span> ubound-lbound;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;统计一个数字在升序数组中出现的次数。&lt;/p&gt;
&lt;h4 id=&quot;输入描述&quot;&gt;&lt;a href=&quot;#输入描述&quot; class=&quot;headerlink&quot; title=&quot;输入描述&quot;&gt;&lt;/a&gt;输入描述&lt;/h4&gt;&lt;p&gt;一个升序数组，和一个待统计的数字&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[1,2,3,3,3,3,4,5] , 3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;输出描述&quot;&gt;&lt;a href=&quot;#输出描述&quot; class=&quot;headerlink&quot; title=&quot;输出描述&quot;&gt;&lt;/a&gt;输出描述&lt;/h4&gt;&lt;p&gt;数字的统计次数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第一个只出现一次的字符</title>
    <link href="http://yoursite.com/2020/12/03/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2020/12/03/第一个只出现一次的字符/</id>
    <published>2020-12-03T08:36:48.758Z</published>
    <updated>2020-12-03T08:47:07.537Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数） </p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><p>一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)，区分大小写。</p><blockquote><p>wohenhaowWOHENHAO</p></blockquote><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><p>第一个只出现一次的字符的位置，如果没有输出-1，从0开始计数</p><blockquote><p>3</p></blockquote><a id="more"></a><h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p><strong>哈希法</strong></p><p>先遍历一遍字符串统计每个字符出现的次数，然后在遍历一遍字符串，输出只出现一次的的字符的位置。</p><p><strong>时间复杂度</strong>：O(2n)，需要遍历两遍字符串</p><p><strong>空间复杂度</strong>：O(1)，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">//键盘扫描类</span></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="string">'z'</span> - <span class="string">'A'</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            arr[str.charAt(i)-<span class="string">'A'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[str.charAt(i)-<span class="string">'A'</span>] == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span> </span>&#123;</span><br><span class="line">        String str;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        str = input.next();</span><br><span class="line"></span><br><span class="line">        System.out.print(str + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line"></span><br><span class="line">        System.out.print(solution.FirstNotRepeatingChar(str));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;在一个字符串(0&amp;lt;=字符串长度&amp;lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数） &lt;/p&gt;
&lt;h4 id=&quot;输入描述&quot;&gt;&lt;a href=&quot;#输入描述&quot; class=&quot;headerlink&quot; title=&quot;输入描述&quot;&gt;&lt;/a&gt;输入描述&lt;/h4&gt;&lt;p&gt;一个字符串(0&amp;lt;=字符串长度&amp;lt;=10000，全部由字母组成)，区分大小写。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;wohenhaowWOHENHAO&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;输出描述&quot;&gt;&lt;a href=&quot;#输出描述&quot; class=&quot;headerlink&quot; title=&quot;输出描述&quot;&gt;&lt;/a&gt;输出描述&lt;/h4&gt;&lt;p&gt;第一个只出现一次的字符的位置，如果没有输出-1，从0开始计数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>把数组排成最小的数</title>
    <link href="http://yoursite.com/2020/11/26/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
    <id>http://yoursite.com/2020/11/26/把数组排成最小的数/</id>
    <published>2020-11-26T07:59:16.617Z</published>
    <updated>2020-11-26T08:13:41.001Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个正整数数组，把数组里面所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3,32,321}，则打印出这三个数字能排成的最小数字为321323.</p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><blockquote><p>{3,32,321}</p></blockquote><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><blockquote><p>321323</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>将数组中的数字连接起来，排成一个最小的数字。将”大数“往后放，”小数“往前放</p><p>如何定义“大数”与“小数”，<strong>排序！！！</strong></p><p>例如当前两个数a和b</p><p>判断当前字符串a+b与字符串b+a对应的数字大小，如果ab&gt;ba。则a是大数，b是小数。</p><p>所以这道题变成了一个排序问题，将能把组合出来的数字变大的数字往后排，</p><p>这里我们只需要定义一个比较大小的判断。用冒泡排序如下：（其他排序类似）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">//键盘扫描类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numbers.length; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Integer.parseInt(numbers[i]+<span class="string">""</span>+numbers[j]) &gt; Integer.parseInt((numbers[j]+<span class="string">""</span>+numbers[i]))) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp;</span><br><span class="line">                    temp = numbers[i];</span><br><span class="line">                    numbers[i] = numbers[j];</span><br><span class="line">                    numbers[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String str=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; ++i) &#123;</span><br><span class="line">            str = str + numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        n = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            arr[i] = input.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.print(solution.PrintMinNumber(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;输入一个正整数数组，把数组里面所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3,32,321}，则打印出这三个数字能排成的最小数字为321323.&lt;/p&gt;
&lt;h4 id=&quot;输入描述&quot;&gt;&lt;a href=&quot;#输入描述&quot; class=&quot;headerlink&quot; title=&quot;输入描述&quot;&gt;&lt;/a&gt;输入描述&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;{3,32,321}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;输出描述&quot;&gt;&lt;a href=&quot;#输出描述&quot; class=&quot;headerlink&quot; title=&quot;输出描述&quot;&gt;&lt;/a&gt;输出描述&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;321323&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>连续子数组的最大和</title>
    <link href="http://yoursite.com/2020/11/12/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>http://yoursite.com/2020/11/12/连续子数组的最大和/</id>
    <published>2020-11-12T11:35:45.250Z</published>
    <updated>2020-11-12T11:58:41.169Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) </p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><p>[1,-2,3,10,-4,7,2,-5]</p><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><p>18</p><a id="more"></a> <h5 id="方法一-动态规划"><a href="#方法一-动态规划" class="headerlink" title="方法一 动态规划"></a>方法一 动态规划</h5><p>状态定义：dp[i]表示以i结尾的连续子数组的最大和。所以最终要求dp[n-1] </p><p>状态转移方程：dp[i] = max(array[i], dp[i-1]+array[i]) </p><p>解释：如果当前元素为整数，并且dp[i-1]为负数，那么当然结果就是只选当前元素 </p><p>技巧：这里为了统一代码的书写，定义dp[i]表示前i个元素的连续子数组的最大和，结尾元素为array[i-1] </p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = <span class="built_in">array</span>.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(sz+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 表示没有元素</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=sz; ++i) &#123;</span><br><span class="line">            dp[i] = max(<span class="built_in">array</span>[i<span class="number">-1</span>], dp[i<span class="number">-1</span>]+<span class="built_in">array</span>[i<span class="number">-1</span>]);</span><br><span class="line">            ret = max(ret, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxNum = -<span class="number">999999</span>;</span><br><span class="line">        <span class="keyword">int</span> res = -<span class="number">999999</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">            maxNum = array[i] &gt; array[i] + maxNum ? array[i] : array[i] + maxNum;</span><br><span class="line">            res = res &gt; maxNum ? res : maxNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>思想很简单，就是对下标为i的元素array[i]，先试探的加上array[i], 如果和为负数，显然，以i结尾的元素对整个结果不作贡献。<br>具体过程：</p><ol><li>初始化：维护一个变量tmp = 0</li><li>如果tmp+array[i] &lt; 0, 说明以i结尾的不作贡献，重新赋值tmp = 0</li><li>否则更新tmp = tmp + array[i]<br>最后判断tmp是否等于0， 如果等于0， 说明数组都是负数，选取一个最大值为答案。</li></ol><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> k : <span class="built_in">array</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp + k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                tmp = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp += k;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = max(ret, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">return</span> *max_element(<span class="built_in">array</span>.begin(), <span class="built_in">array</span>.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) &lt;/p&gt;
&lt;h4 id=&quot;输入描述&quot;&gt;&lt;a href=&quot;#输入描述&quot; class=&quot;headerlink&quot; title=&quot;输入描述&quot;&gt;&lt;/a&gt;输入描述&lt;/h4&gt;&lt;p&gt;[1,-2,3,10,-4,7,2,-5]&lt;/p&gt;
&lt;h4 id=&quot;输出描述&quot;&gt;&lt;a href=&quot;#输出描述&quot; class=&quot;headerlink&quot; title=&quot;输出描述&quot;&gt;&lt;/a&gt;输出描述&lt;/h4&gt;&lt;p&gt;18&lt;/p&gt;
    
    </summary>
    
    
      <category term="dp" scheme="http://yoursite.com/tags/dp/"/>
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>数组中出现次数超过一半的数字</title>
    <link href="http://yoursite.com/2020/11/09/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/11/09/数组中出现次数超过一半的数字/</id>
    <published>2020-11-09T08:44:24.319Z</published>
    <updated>2020-11-09T09:14:08.439Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字，例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]，由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2，如果不存在则输出0；</p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><p>[1,2,3,2,2,2,5,4,2]</p><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><p>2</p><a id="more"></a><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>现将数组排序，如果有超过数组长度一半的元素则该值一定会出现在数组的中间，然后将数组中间的该元素的个数判断一下是否有超过数组长度的一半。</p><p>时间复杂度：O(nlogn)</p><p>空间复杂度：O(1)</p><h5 id="方法二-候选法-最优解"><a href="#方法二-候选法-最优解" class="headerlink" title="方法二(候选法)最优解"></a>方法二(候选法)最优解</h5><p>首先先找出数组中的众数，然后判断该众数的个数是否超过了数组长度的一半。</p><p>具体做法：</p><ol><li>初始化当前众数值preValue = -1，以及目前出现该preValue的次数count = 0；</li><li>遍历数组：判断count是否 = 0，若为0，说明当前不存在众数值preValue，则把当前值存为preValue，次数为记为1，若不为0，说明当前存在众数值preValue且次数为count，则判断当前值是否与preValue相等，若相等则次数count+1，若不想等则次数count -1。</li><li>遍历完之后preValue中保存的则为数组中的众数，在判断此preValue的count是否超过数组长度的一半。若存在相等的情况，则preValue保存的为最后一次的众数值，但此情况下一定不存在次数超过数组长度一半的数字。</li></ol><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">//键盘扫描类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preValued = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                preValued = array[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                count = preValued == array[i] ? count + <span class="number">1</span> : count - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] == preValued) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &gt; array.length/<span class="number">2</span> ? preValued : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        n = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            arr[i] = input.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.print(solution.MoreThanHalfNum_Solution(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字，例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]，由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2，如果不存在则输出0；&lt;/p&gt;
&lt;h4 id=&quot;输入描述&quot;&gt;&lt;a href=&quot;#输入描述&quot; class=&quot;headerlink&quot; title=&quot;输入描述&quot;&gt;&lt;/a&gt;输入描述&lt;/h4&gt;&lt;p&gt;[1,2,3,2,2,2,5,4,2]&lt;/p&gt;
&lt;h4 id=&quot;输出描述&quot;&gt;&lt;a href=&quot;#输出描述&quot; class=&quot;headerlink&quot; title=&quot;输出描述&quot;&gt;&lt;/a&gt;输出描述&lt;/h4&gt;&lt;p&gt;2&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
</feed>
